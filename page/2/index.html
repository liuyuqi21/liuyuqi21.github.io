<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Cellophane&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Cellophane&#39;s blog">
<meta property="og:url" content="https://liuyuqi21.github.io/page/2/index.html">
<meta property="og:site_name" content="Cellophane&#39;s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Cellophane">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/icon.ico">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/css/prism-base16-ateliersulphurpool.light.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Cellophane&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://liuyuqi21.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-操作系统笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-02-02T06:33:12.000Z" itemprop="datePublished">2020-02-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/">操作系统笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>操作系统就是一个协调、管理和控制计算机硬件资源和软件资源的控制程序。</p>
<p><img src="https://gitee.com/cellophane/image/raw/master/yingjian.jpg" alt="硬件组织"></p>
<h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</p>
<p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p>
<p>操作系统通过引入进程和线程，使得程序能够并发运行。</p>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>共享是指系统中的资源可以被多个并发进程共同使用。</p>
<p>有两种共享方式：互斥共享和同时共享。</p>
<p>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p>
<h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>
<p>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</p>
<ul>
<li>时分复用：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</li>
<li>空分复用：虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</li>
</ul>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><ul>
<li>进程管理</li>
<li>内存管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
<h2 id="分时系统与实时系统"><a href="#分时系统与实时系统" class="headerlink" title="分时系统与实时系统"></a>分时系统与实时系统</h2><ul>
<li>分时系统（Sharing time system）：系统把 CPU 时间分成很短的时间片，轮流地分配给多个作业。对多个用户地多个作业都能保证足够快的响应时间，并且有效提高了资源利用率。</li>
<li>实时系统（Rael-time system）：系统对外部输入的信息，能够在规定的时间内处理完并做出反应。能够集中地即时地处理并做出反应，高可靠性、安全性。</li>
</ul>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>对于单核单线程 CPU 而言，在某一时刻只能执行一条 CPU 指令。上下文切换(Context Switch)是一种将 CPU 资源从一个进程分配给另一个进程的机制。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。在切换的过程中，操作系统需要先存储当前进程的状态(包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>编译系统的过程：预处理 - 编译 - 汇编 - 链接。</p>
<p>静态库是一个外部函数与变量的集合体。静态库的文件内容，通常包含一堆程序员自定的变量与函数，其内容不像动态链接库那么复杂，在编译期间由编译器与连接器将它集成至应用程序内，并制作成目标文件以及可以独立运作的可执行文件。而这个可执行文件与编译可执行文件的程序，都是一种程序的静态创建（static build）。</p>
<h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p>
<ul>
<li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li>
<li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li>
</ul>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>静态库有以下两个问题：</p>
<ul>
<li>当静态库更新时那么整个程序都要重新进行链接；</li>
<li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li>
</ul>
<p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p>
<ul>
<li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li>
<li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li>
</ul>
<h1 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h1><p>现代操作系统结构设计中，大多数采用了基于客户/服务器模式的微内核结构，将操作系统划分为两个部分：微内核和多个服务器。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>足够小的内核</li>
<li>基于客户/服务器模式：客户与服务器之间是借助微内核提供的消息传递机制来实现信息交互的。</li>
<li>应用“机制与策略分离”原理</li>
<li>采用面向对象技术</li>
</ul>
<h2 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h2><ul>
<li>进程/线程管理</li>
<li>低级存储器管理</li>
<li>中断和陷入处理</li>
</ul>
<p>微内核存在的问题：微内核 OS 采用客户/服务器模式，有许多优点，但是也存在一些缺点，如客户进程与服务进程，服务进程与服务进程通信时，都需要经过微内核，会存在多次用户/内核模式及上下文切换，这使得开销较大。</p>
<h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p>内核是一组程序模块，提供进程并发执行及基本功能和基本操作，通常驻留在内核空间，运行于内核态，具有直接访问硬件设备和所有内存空间的权限，是仅有的能够执行<strong>特权指令</strong>的程序。</p>
<h2 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h2><p><img src="https://gitee.com/cellophane/image/raw/master/1036857-20170118112402265-1697763795.png" alt=""></p>
<p>仅在内核态下才能使用的指令称为特权指令，非特权指令在用户态和内核态下都能工作。</p>
<p>用户态向内核态转换的情况：</p>
<ul>
<li>程序请求操作系统服务，执行<strong>系统调用</strong>。</li>
<li>在程序运行时产生中断事件(如 I/O 操作完成)，运行程序被中断，转向中断处理程序处理。 </li>
<li>在程序运行时产生异常事件(如在目态下执行特权指令)，运行程序被打断，转向异常处理程序工作。</li>
</ul>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用是程序向系统内核请求服务的方式。</p>
<p>程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，比如说打开某一设备、创建文件、读写文件等，就需要向操作系统发出调用服务的请求，这就是系统调用。</p>
<p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断就是在计算机执行程序的过程中，由于出现了某些特殊事情，使得 CPU 暂停对程序的执行，转而去执行处理这一事件的程序。等这些特殊事情处理完之后再回去执行之前的程序，中断一般分为三类。</p>
<ul>
<li>外中断：由外部设备请求引起的中断，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</li>
<li>异常：由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</li>
<li>陷入（软中断）：在用户程序中执行了引起中断的指令（系统调用）而造成的中断。</li>
</ul>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程-Process"><a href="#进程-Process" class="headerlink" title="进程(Process)"></a>进程(Process)</h2><p>进程是资源分配的基本单位。</p>
<p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p>
<p><img src="https://gitee.com/cellophane/image/raw/master/ProcessState.png" alt=""></p>
<ul>
<li>就绪状态（ready）：等待被调度</li>
<li>运行状态（running）</li>
<li>阻塞状态（waiting）：等待资源</li>
</ul>
<p>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</p>
<p>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源<strong>不包括 CPU 时间</strong>，缺少 CPU 时间会从运行态转换为就绪态。</p>
<h2 id="线程-Thred"><a href="#线程-Thred" class="headerlink" title="线程(Thred)"></a>线程(Thred)</h2><p>线程是独立调度的基本单位。</p>
<p>一个进程中可以有多个线程，它们共享进程资源。</p>
<p>每个线程有自己独立的栈空间，线程彼此之间无法访问其他线程栈上的内容。作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和 PC 即可，相比进程切换开销小很多。</p>
<h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><ul>
<li>拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</li>
<li>调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>
<li>系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</li>
<li>通信方面：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</li>
</ul>
<p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p>
<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="调度种类"><a href="#调度种类" class="headerlink" title="调度种类"></a>调度种类</h3><ul>
<li><strong>高级调度</strong>(High-Level Scheduling)：又称为作业调度，它决定把后备作业调入内存运行。</li>
<li><strong>中级调度</strong>(Intermediate-Level Scheduling)：又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。</li>
<li><strong>低级调度</strong>(Low-Level Scheduling)：又称为进程调度，它决定把就绪队列的某进程获得CPU。</li>
</ul>
<h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><ul>
<li>批处理系统：批处理系统没有太多的用户操作，在该系统总，调度算法目标是保障吞吐量和周转时间。<ul>
<li>先来先服务：非抢占式</li>
<li>最短作业优先：非抢占式</li>
<li>最短剩余时间优先：抢占式</li>
</ul>
</li>
<li>交互式系统<ul>
<li>时间片轮转</li>
<li>优先级调度</li>
<li>多级反馈队列</li>
</ul>
</li>
</ul>
<h3 id="非抢占式调度与抢占式调度"><a href="#非抢占式调度与抢占式调度" class="headerlink" title="非抢占式调度与抢占式调度"></a>非抢占式调度与抢占式调度</h3><ul>
<li><strong>非抢占式</strong>：分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生进程调度进程调度某事件而阻塞时，才把处理机分配给另一个进程。</li>
<li><strong>抢占式</strong>：操作系统将正在运行的进程强行暂停，由调度程序将 CPU 分配给其他就绪进程的调度方式。</li>
</ul>
<h3 id="衡量调度算法的性能指标"><a href="#衡量调度算法的性能指标" class="headerlink" title="衡量调度算法的性能指标"></a>衡量调度算法的性能指标</h3><ul>
<li><strong>响应时间</strong>: 从用户输入到产生反应的时间</li>
<li><strong>周转时间</strong>: 从任务开始到任务结束的时间</li>
</ul>
<p>CPU任务可以分为<strong>交互式任务</strong>和<strong>批处理任务</strong>，调度最终的目标是<strong>合理的使用CPU，使得交互式任务的响应时间尽可能短，用户不至于感到延迟，同时使得批处理任务的周转时间尽可能短，减少用户等待的时间。</strong></p>
<h2 id="守护、孤儿、僵尸进程"><a href="#守护、孤儿、僵尸进程" class="headerlink" title="守护、孤儿、僵尸进程"></a>守护、孤儿、僵尸进程</h2><ul>
<li><p>守护进程：运行在后台的一种特殊进程，独立于控制终端并周期性地执行某些任务。</p>
</li>
<li><p>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将会成为孤儿进程。</p>
<p>孤儿进程将会被 init 进程（进程号为1）所收养，并由 init 进程对他们完成状态收集工作。由于孤儿进程会被 init 所收养，所以孤儿进程不会对系统造成危害。</p>
</li>
<li><p>僵尸进程：如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。</p>
<p>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 所收养，这样 init 就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。</p>
</li>
</ul>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>当用户创立多个线程／进程时，如果不同线程／进程同时读写相同的内容，则可能造成读写错误，或者数据不一致。此时，需要通过加锁的方式，控制临界区(critical section)的访问权限。对于semaphore而言，在初始化变量的时候可以控制允许多少个线程／进程同时访问一个临界区，其他的线程／进程会被堵塞，直到有人解锁。</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>只能被一个进程占用的资源就是临界资源。进程内访问临界的代码被称为临界区。</p>
<p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p>
<h3 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h3><ul>
<li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li>
<li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li>
</ul>
<h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
<ul>
<li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li>
<li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>
<li>当 s &gt;= 0，表示系统中当前可用资源的数目。</li>
<li>当 s&lt;0，其绝对值表示系统中因请求该类资源而被阻塞的进程数目。</li>
</ul>
<p>PV操作被设计成原语，不可分割。</p>
<p>如果信号量的取值只能为 0 或者 1，那么就成为了<strong>互斥量</strong>，0 代表临界区已经加锁，1 代表临界区解锁。</p>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>Monitor（管程）是用来实现并发的一种技术，用来解决互斥与同步问题。<br>管程的定义是：用来管理共享变量以及对共享变量操作的过程。</p>
<p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p>
<h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><p>使用信号量实现</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> N 100</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> semaphore<span class="token punctuation">;</span>
semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
semaphore empty <span class="token operator">=</span> N<span class="token punctuation">;</span>
semaphore full <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> item <span class="token operator">=</span> <span class="token function">produce_item</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">insert_item</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> item <span class="token operator">=</span> <span class="token function">remove_item</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">consume_item</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信(IPC)"></a>进程间通信(IPC)</h2><p>进程通信是指进程间传输信息，而进程同步是控制多个进程按一定顺序执行。</p>
<p>进程通信是一种手段，而进程同步是一种目的。</p>
<ul>
<li>管道：无名管道是一种特殊的文件，只存在于内存中，只支持半双工通信，只能在父子进程中使用。通过 <code>pipe</code>函数创建，fd[0] 用于读，fd[1] 用于写。</li>
<li>FIFO：命名管道，是 FIFO 文件，存在于文件系统中，去除了管道只能在父子进程中使用的限制。FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</li>
<li>消息队列：相比于 FIFO，消息队列具有以下优点：<ul>
<li>消息队列可以独立于读写进程存在，从而避免了FIFO 中同步管道的打开和关闭时可能产生的困难。</li>
<li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收</li>
</ul>
</li>
<li>共享数据：允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。需要使用信号量用来同步对共享存储的访问。多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用使用内存的匿名段。</li>
<li>信号量：它是一个计数器，用于为多个进程提供共享数据对象的访问。</li>
<li>套接字：与其它通信机制不同的是，它可用于不同机器间的进程通信。</li>
</ul>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p><a href="https://www.cnblogs.com/raichen/p/5768752.html" target="_blank" rel="noopener">线程同步方式比较</a></p>
<p>即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态，实现线程同步的方法有很多，临界区对象就是其中一种。</p>
<ul>
<li>互斥量 Mutex：互斥量跟临界区很相似，只有拥有互斥对象的线程才具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后得以访问资源。互斥量比临界区复杂。因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。 </li>
<li>临界区：在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么 在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操 作共享资源的目的。 仅能在同一进程内使用。</li>
<li>信号量：信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源 ，这与操作系统中的PV操作相同。</li>
<li>事件：事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。</li>
</ul>
<p>Java 中可以使用 synchronized、volatile、ReentrantLock、ThredLocal、阻塞队列、原子变量 实现线程同步。</p>
<h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p>
<p>线程通信有两种方式：内存共享与发送消息</p>
<ul>
<li>锁机制：包括互斥锁、条件变量、读写锁</li>
<li>信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量</li>
<li>信号机制(Signal)：类似进程间的信号处理</li>
</ul>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞现象。<br>比如线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>
<h2 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h2><ol>
<li>系统资源不足</li>
<li>系统运行推进的顺序不合适</li>
<li>资源分配不当</li>
</ol>
<h2 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h2><ul>
<li>互斥：资源不能被共享，只能由一个进程使用。</li>
<li>请求与保持：已经得到资源的进程可以再次申请新的资源。</li>
<li>不可剥夺：已经分配的资源不能从相应的进程中被强制地剥夺。</li>
<li>循环等待：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。<br>上述条件之一不满足，就不会发生死锁。</li>
</ul>
<h2 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h2><p>死锁的预防就是打破产生死锁的必要条件。</p>
<ul>
<li>破坏请求与保持：实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源。</li>
<li>破坏不可剥夺：即允许进程强行从占有者那里夺取某些资源。</li>
<li>破坏循环等待：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。<br>线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁</li>
</ul>
<h2 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h2><p>它不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态的检查，并根据额检查结果决定是否进行资源分配。<br>银行家算法就是一个避免死锁的办法。</p>
<h2 id="Java-实现死锁"><a href="#Java-实现死锁" class="headerlink" title="Java 实现死锁"></a>Java 实现死锁</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> Object a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> Object b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Thread threadA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"now i in threadA-locka"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>1000l<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"now i in threadA-lockb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">// ignore</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    Thread threadB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"now i in threadB-lockb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>1000l<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"now i in threadB-locka"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">// ignore</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    threadA<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    threadB<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p>
<p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p>
<p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>页表存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p>
<ul>
<li><p>最佳（OPT, Optimal replacement algorithm）</p>
</li>
<li><p>先进先出（FIFO，First In First Out）：淘汰最先进入的页面</p>
</li>
<li><p>最近最久未使用（LRU, Least Recently Used）：淘汰访问时间最久的页面</p>
</li>
<li><p>最近最少使用（LFU，Least Frequently Used）：淘汰访问次数最少的页面</p>
</li>
<li><p>最近未使用（NRU，Not Recently Used）：每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p>
<ul>
<li>R=0，M=0</li>
<li>R=0，M=1</li>
<li>R=1，M=0</li>
<li>R=1，M=1</li>
</ul>
<p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p>
<p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p>
</li>
<li><p>时钟（CLOCK）：在页表项加入 访问位 Access 位 描述页面在过去一段时间内访问情况，各页面组织成环形链表。</p>
<ul>
<li>页面装入内存时 访问位 置 0</li>
<li>访问页面 (读/写) 时 访问位 置 1</li>
<li>缺页时 从指针当前位置顺序检查环形链表</li>
<li>访问位为 0 则置换此页</li>
<li>访问位为 1 则访问位置 0 指针继续移动到下一个页面 直到找到可置换页面</li>
</ul>
</li>
</ul>
<h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p>
<p>编译器在编译过程中会建立多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p>
<p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p>
<h2 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h2><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p>
<h2 id="分页与分段的区别"><a href="#分页与分段的区别" class="headerlink" title="分页与分段的区别"></a>分页与分段的区别</h2><ul>
<li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</li>
<li>地址空间的维度：分页是一维地址空间，分段是二维的。</li>
<li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li>
<li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li>
</ul>
<h1 id="网络-I-O-模型"><a href="#网络-I-O-模型" class="headerlink" title="网络 I/O 模型"></a>网络 I/O 模型</h1><p><img src="https://gitee.com/cellophane/image/raw/master/20200408142823.png" alt=""></p>
<p>假设服务器已经在监听用户请求，建立连接后服务器调用 read() 函数等待读取用户发过来的数据流，之后将接收到的数据打印出来。 服务器端简单的流程是：建立连接 -&gt; 监听请求 -&gt; 等待用户数据 -&gt; 打印数据。总结网络通信中的等待：</p>
<ul>
<li>建立连接时等待对方的 ACK 包（TCP）</li>
<li>等待客户端请求（HTTP）</li>
<li>输入等待：服务器用户数据到达内核缓冲区（read 函数等待）</li>
<li>输出等待：用户端等待缓冲区有足够空间可以输入（write 函数等待）</li>
</ul>
<p>服务器首先 accept 用户连接请求后调用 read 函数等待数据，<strong>read 函数是系统调用，运行于内核态</strong>，使用的也是内核地址空间并且从网络中取得的数据需要先写入到内核缓冲区。当 read 系统调用获取到数据后将这个数据再复制到用户地址空间的用户缓冲区中，之后返回用户态执行 printf 函数打印字符串。</p>
<ul>
<li>read 执行在内核态且数据流先流入内核区，printf 运行于用户态，打印的数据会先从内核缓冲区复制到进程的用户缓冲区，之后打印出来</li>
<li>printf 函数一定是在 read 函数已经准备好数据之后才能执行，但 read 函数作为 I/O 操作通常需要等待而触发阻塞。调用 read 函数的是服务器进程，一旦被 read 调用阻塞，整个服务器在获取到用户数据前都不能接受其他任何用户的请求（单进程/线程）</li>
</ul>
<h2 id="阻塞式-I-O"><a href="#阻塞式-I-O" class="headerlink" title="阻塞式 I/O"></a>阻塞式 I/O</h2><p>一旦调用 I/O 函数必须等整个 I/O 完成才返回。如果用户输入数据迟迟不到，整个服务器就会一直被阻塞。</p>
<p>在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。</p>
<h2 id="非阻塞-I-O"><a href="#非阻塞-I-O" class="headerlink" title="非阻塞 I/O"></a>非阻塞 I/O</h2><p>应用程序执行系统调用后会立即返回，内核返回一个错误码，如果返回值大于 0 标识完成了数据读取，返回值即读取的字节数。返回 0 表示连接已经正常断开，返回 -1 表示错误，接下来用户进程可以继续执行，但是会会不停地执行系统调用来获取 kernel 是否准备完毕，这种方式称为轮询。</p>
<p>非阻塞I/O虽然不再会完全阻塞用户进程，但实际上由于用户进程需要不停地询问 kernel 是否准备完数据，所以 CPU 利用率比较低，不适合做并发。</p>
<h2 id="I-O-多路复用（事件驱动模型）"><a href="#I-O-多路复用（事件驱动模型）" class="headerlink" title="I/O 多路复用（事件驱动模型）"></a>I/O 多路复用（事件驱动模型）</h2><p>是前两种一样是<strong>同步</strong> I/O。使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这个过程也会使线程阻塞，但是和阻塞 I/O 所不同的是，这两个函数可以同时阻塞多个 I/O 操作。而且可以同时对多个读操作，多个写操作的 I/O 函数进行检测，直到有数据可读或可写时，才真正调用 I/O 操作函数。它可以让单个进程具有处理多个 I/O 事件的能力。</p>
<p>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。</p>
<p>应用场景：select 适用于实时性较高的场景。移植性更好，几乎被所有主流平台所支持。</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>与 select 功能基本相同。select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。</p>
<p>不同点：</p>
<ul>
<li>select 会修改描述符，poll不会</li>
<li>select 的描述符类型使用数组实现，默认为 1024，而 poll 没有描述符数量限制</li>
<li>poll 提供了更多的事件类型，并且对描述符的复用利用上比 select 高</li>
</ul>
<p>应用场景：poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll 调用 epoll_ctl 时拷贝进内核并放到事件表中，但用户进程和内核通过 mmap 映射共享同一块存储，避免了 fd 从内核赋值到用户空间。</p>
<p>epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。</p>
<p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。</p>
<p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p>
<ul>
<li><p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p>
</li>
<li><p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p>
<p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
</li>
</ul>
<p>应用场景：需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。如果需要监控的小于 1000 个描述符，就没有必要使用 epoll。如果需要监控的描述符状态变化多，也没有必要使用 epoll。</p>
<h2 id="信号驱动-I-O"><a href="#信号驱动-I-O" class="headerlink" title="信号驱动 I/O"></a>信号驱动 I/O</h2><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>
<p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。</p>
<h2 id="异步-I-O"><a href="#异步-I-O" class="headerlink" title="异步 I/O"></a>异步 I/O</h2><p>异步 I/O 就是当用户进程发起 I/O 请求后立即返回，直到内核发送一个信号，告知进程 I/O 已完成，在整个过程中，都没有进程被阻塞。</p>
<p>异步I/O和非阻塞I/O的区别在于，判断数据是否准备完毕的任务从用户进程本身被委托给内核来完成。</p>
<p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://github.com/linw7/Skill-Tree/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md" target="_blank" rel="noopener">Skill-Tree 操作系统</a></li>
<li><a href="https://juejin.im/entry/59cf00646fb9a00a5c3c7715" target="_blank" rel="noopener">浅析操作系统的进程、线程区别</a></li>
<li><a href="https://mp.weixin.qq.com/s/6jvA5jnnMkr5l-IliDL8yw" target="_blank" rel="noopener">管程:并发编程的基石</a></li>
<li>[<a href="https://segmentfault.com/a/1190000011028633" target="_blank" rel="noopener">操作系统面试常见题型</a></li>
<li><a href="[https://yuerer.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/](https://yuerer.com/操作系统之-虚拟存储页面置换算法/)">操作系统之 虚拟存储页面置换算</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liuyuqi21.github.io/2020/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/" data-id="ckd5czhim003rnnnrclwlby26" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络常见问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-01-29T07:16:20.000Z" itemprop="datePublished">2020-01-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">计算机网络常见问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="七层协议"><a href="#七层协议" class="headerlink" title="七层协议"></a>七层协议</h1><h2 id="各层协议的作用"><a href="#各层协议的作用" class="headerlink" title="各层协议的作用"></a>各层协议的作用</h2><p><img src="https://gitee.com/cellophane/image/raw/master/20200408113004.png" alt=""></p>
<h3 id="七层协议-1"><a href="#七层协议-1" class="headerlink" title="七层协议"></a>七层协议</h3><p>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
<p>各层传输单位：</p>
<ul>
<li>物理层：比特流</li>
<li>数据链路层：帧</li>
<li>网络层：包</li>
<li>传输层：报文</li>
</ul>
<h3 id="五层协议"><a href="#五层协议" class="headerlink" title="五层协议"></a>五层协议</h3><ul>
<li>应用层：为特定应用程序提供数据传输服务。 </li>
<li>传输层：为进程提供通用数据传输服务。提供端对端的接口。</li>
<li>网络层：为主机提供数据传输服务。为数据包选择路由。</li>
<li>数据链路层：传输有地址的帧以及差错校验功能。</li>
<li>物理层：以二进制在物理媒体上传输数据。</li>
</ul>
<p>各层中的协议和设备：</p>
<ul>
<li>物理层：集线器、中继器</li>
<li>数据链路层：网桥、交换机、PPP、ARP、RARP</li>
<li>网络层：路由器、IP、ICMP、OSPF、RIP</li>
<li>传输层：TCP、UDP</li>
<li>应用层：HTTP、FTP、DNS、SMTP、Telnet</li>
</ul>
<h3 id="TCP-IP-协议"><a href="#TCP-IP-协议" class="headerlink" title="TCP/IP 协议"></a>TCP/IP 协议</h3><p>只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。TCP/IP 协议体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p>
<h2 id="数据链路层和传输层的差错控制有什么区别"><a href="#数据链路层和传输层的差错控制有什么区别" class="headerlink" title="数据链路层和传输层的差错控制有什么区别"></a>数据链路层和传输层的差错控制有什么区别</h2><ul>
<li>数据链路层使用循环冗余检验码（CRC）校验</li>
<li>TCP使用校验和：TCP 的首部字段中有一个字段是校验和，发送方将伪首部、TCP首部、TCP数据使用累加和校验的方式计算出一个数字，然后存放在首部的校验和字段里，接收者收到TCP包后重复这个过程，然后将计算出的校验和和接收到的首部中的校验和比较，如果不一致则说明数据在传输过程中出错。</li>
</ul>
<p>数据链路层的校验只覆盖物理链路，当以太网离开主机网卡前，添加了 CRC 校验，顺着物理链路流动到另一头，进入路由器接口之后。接收方（路由器）开始计算 CRC 校验，计算得到的 CRC 如果与接收的 CRC 相同，校验通过。将 CRC 剥离，接受并路由到另一个接口。</p>
<p>因为IP 报文在路由器内部可能需要做 “QPS”、“NAT” 等操作，这些操作都需要修改 IP、TCP 头的某些字段，所以还需要传输层校验。</p>
<h2 id="以太网的特点，以及帧结构。"><a href="#以太网的特点，以及帧结构。" class="headerlink" title="以太网的特点，以及帧结构。"></a>以太网的特点，以及帧结构。</h2><ul>
<li>以太网是一种星型拓扑结构局域网。</li>
<li>以太网帧格式</li>
<li>类型：标记上层使用的协议；</li>
<li>数据：长度在 46-1500 之间秒如果太小则需要填充；</li>
<li>FCS：帧检验序列，使用的是 CRC 检验方法；</li>
</ul>
<h2 id="集线器、交换机、路由器的作用，以及所属的网络层"><a href="#集线器、交换机、路由器的作用，以及所属的网络层" class="headerlink" title="集线器、交换机、路由器的作用，以及所属的网络层"></a><a href="https://www.tianmaying.com/tutorial/NetWorkInstrument" target="_blank" rel="noopener">集线器、交换机、路由器的作用，以及所属的网络层</a></h2><ul>
<li>集线器：物理层设备。作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其他所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。</li>
<li>交换机：链路层设备。是一种基于 MAC 识别，能完成封装转发数据包功能的网络设备。它不会发生碰撞，能根据 MAC 地址进行存储转发。</li>
<li>路由器：网络层设备。是一种连接多个网络或网段的网络设备，根据 IP 进行转发。</li>
</ul>
<h2 id="IP-数据数据报常见字段的作用。"><a href="#IP-数据数据报常见字段的作用。" class="headerlink" title="IP 数据数据报常见字段的作用。"></a>IP 数据数据报常见字段的作用。</h2><ul>
<li>版本：有 4（IPv4）和 6（IPv6）两个值；</li>
<li>首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li>
<li>区分服务 : 用来获得更好的服务，一般情况下不使用。</li>
<li>总长度 : 包括首部长度和数据部分长度。</li>
<li>生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li>
<li>协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li>
<li>首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li>
<li>标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li>
<li>片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li>
</ul>
<h2 id="ARP-协议的作用，以及维护-ARP-缓存的过程。"><a href="#ARP-协议的作用，以及维护-ARP-缓存的过程。" class="headerlink" title="ARP 协议的作用，以及维护 ARP 缓存的过程。"></a>ARP 协议的作用，以及维护 ARP 缓存的过程。</h2><ul>
<li>ARP 实现由 IP 地址得到 MAC 地址</li>
<li>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到MAC 地址的映射。</li>
</ul>
<h2 id="ICMP-报文种类以及作用；和-IP-数据报的关系；Ping-和-Traceroute-的具体原理。"><a href="#ICMP-报文种类以及作用；和-IP-数据报的关系；Ping-和-Traceroute-的具体原理。" class="headerlink" title="ICMP 报文种类以及作用；和 IP 数据报的关系；Ping 和 Traceroute 的具体原理。"></a>ICMP 报文种类以及作用；和 IP 数据报的关系；Ping 和 Traceroute 的具体原理。</h2><ul>
<li>ICMP 报文分为差错报告报文和询问报文</li>
<li>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但不属于高层协议</li>
<li>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功相应次数估算出数据包往返时间以及丢包率</li>
<li>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</li>
<li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li>
<li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li>
<li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li>
<li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li>
</ul>
<h2 id="UDP-与-TCP-比较，分析上层协议应该使用-UDP-还是-TCP。"><a href="#UDP-与-TCP-比较，分析上层协议应该使用-UDP-还是-TCP。" class="headerlink" title="UDP 与 TCP 比较，分析上层协议应该使用 UDP 还是 TCP。"></a>UDP 与 TCP 比较，分析上层协议应该使用 UDP 还是 TCP。</h2><ul>
<li>传输控制协议 TCP：是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。TCP 主要提供完整性服务。</li>
<li>用户数据报协议 UDP：是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。主要提供及时性服务。</li>
</ul>
<p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP 等邮件传输的协议。当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP（如视频传输、实时通信等）。</p>
<h2 id="理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME-WAIT-的作用。"><a href="#理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME-WAIT-的作用。" class="headerlink" title="理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME_WAIT 的作用。"></a>理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME_WAIT 的作用。</h2><p><img src="https://gitee.com/cellophane/image/raw/master/sanciwoshou.jpg" alt=""></p>
<p>三次握手过程：</p>
<ol>
<li>服务器处于 LISTEN 状态，等待来自客户端的连接请求</li>
<li>客户端向服务器发送连接请求报文 SYN 段，并指明客户端的初始序列号 ISN(c)</li>
<li>服务器收到客户端发来的 SYN，如果同意建立连接，则向客户端发送确认报文 SYN = ISN(s)，并将 ISN(c)+1 作为ACK 数值，这样每发送一个 SYN，序列号加1，如果有丢失的情况，就会重传。</li>
<li>客户端收到 SYN ACK 后，还要向服务器发出确认报文 ACK，ACK 的值为 ISN(s)+1。</li>
<li>服务器收到 ACK 后，连接建立</li>
</ol>
<ul>
<li><p>连接建立以后，ACK 都置为 1</p>
</li>
<li><p>第三次握手可以携带数据，如果不携带数据则不消耗序号</p>
</li>
<li><p>三次握手的原因：第三次握手是为了确认客户端的接收能力。</p>
</li>
</ul>
<p>如果是两次，客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认，客户端超时重发连接请求，这样服务器会对同一个客户端保持多个连接，造成资源浪费。</p>
<p>握手只需要确认双方通信时的初始化序号（ISN 是随机的，防止攻击者猜出确认号和防止同一个连接的不同实例），保证通信不会乱序。</p>
<p><img src="http://q6z2k96rl.bkt.clouddn.com/Fi4rFhwnndiBxPW-Sk-VlXqvr49a" alt=""></p>
<p>四次挥手：</p>
<ul>
<li>客户端（主动关闭方）发送释放报文 FIN</li>
<li>服务器（被动关闭方）收到 FIN 后发出确认 ACK，此时 TCP 属于半关闭状态（CLOSED_WAIT），服务器能向客户端发送数据但是客户端不能向服务器发送数据</li>
<li>当服务器不再需要连接时，发送连接释放报文 FIN</li>
<li>客户端收到 FIN 后发出确认 ACK，进入 TIME-WAIT 状态，等待 2 倍的 MSL（最大报文存活时间）后释放连接</li>
<li>服务器收到 ACK 后释放连接</li>
</ul>
<p>四次挥手的原因：客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器发送还未传送完毕的数据，传送完毕后，服务器会发送 FIN 连接释放报文。</p>
<p>TIME_WAIT：客户端收到服务端的 FIN 报文址后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ol>
<li>确保最后一个报文能够到达。如果服务器没收到客户端发送来的确认报文（网络不好），那么就会重新发送连接释放请求报文（被动方重传或延迟的 FIN 包），收到后会给被动方回一个 RST 包，可能会影响被动方其他的服务连接。</li>
<li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，确保下一个连接不会出现旧的连接请求报文。有可能新连接和老连接的端口号是相同的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达 Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。</li>
</ol>
<h2 id="TIME-WAIT-过多造成的问题"><a href="#TIME-WAIT-过多造成的问题" class="headerlink" title="TIME-WAIT 过多造成的问题"></a>TIME-WAIT 过多造成的问题</h2><p>在<strong>高并发短连接</strong>的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量 socket 处于 TIME_WAIT 状态，系统会把多余的 TIME_WAIT socket 删除掉，并且显示警告信息。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。</p>
<p>MSL 时间：maximum segment lifetime(最大分节生命期），这是一个IP数据包能在互联网上生存的最长时间，超过这个时间IP数据包将在网络中消失 。MSL在RFC 793上建议是2分钟。</p>
<p>在流量大的网站或者服务器上，可以调整 Windows 预设的 TIME-WAIT，微软建议最低可设 30 秒。</p>
<pre class="line-numbers language-shell"><code class="language-shell">vim /etc/sysctl.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>编辑文件，加入以下内容</p>
<pre class="line-numbers language-conf"><code class="language-conf">net.ipv4.tcp_syncookies = 1 //表示开启 SYN Cookies。当出现 SYN 等待队列溢出时，启用 Cookies 来处理，可防范少量 SYN 攻击，默认为 0，表示关闭；
net.ipv4.tcp_tw_reuse = 1 //表示开启重用，允许将 TIME-WAIT sockets 重新用于新的 TCP 连接，默认为 0，表示关闭；
net.ipv4.tcp_tw_recycle = 1 //表示开启 TCP 连接中的 TIME-WAIT sockets 的快速回收，默认为 0，表示关闭（尽量不要开启）；
net.ipv4.tcp_fin_timeout = 30 //修改系统默认的 TIMEOUT 时间
tcp_max_tw_buckets = 256000 // 当出现 TCP: time wait bucket table overflow 时，调大这个参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>造成 TIME-WAIT 过多的原因还有可能是 http 连接未关闭。</p>
<p>由于 keepalive 存在，一般服务端都会有 keepalive 超时设置。如果到了超时时间，客户端没有断开连接，服务端会主动断开。这种情况下，服务端会采用四次挥手方式断开连接，但是由于客户端对象已经没有任何引用，不会调用 close 方法，客户端虽然接收到了服务端发过来的fin包，但是不会回fin包，所以连接无法正常断开：客户端将处于 close-wait 状态，等待 gc 回收，服务端将处于 fin-wait-2 状态，并等待超时，进入 time-wait 状态。</p>
<h2 id="说说半连接队列和-SYN-Flood-攻击的关系"><a href="#说说半连接队列和-SYN-Flood-攻击的关系" class="headerlink" title="说说半连接队列和 SYN Flood 攻击的关系"></a>说说半连接队列和 SYN Flood 攻击的关系</h2><p>三次握手前，服务端的状态从 CLOSED  变为 LISTEN，同时在内部创建了两个队列：半连接队列和全连接队列，即 SYN 队列和 ACCEPT 队列。</p>
<ul>
<li>半连接队列：当客户端发送 SYN 到服务端，服务端收到以后回复 ACK 和 SYN，状态由 LISTEN 变为SYN_RCVD，此时这个连接就被推入了 SYN 队列，也就是半连接队列。</li>
<li>全连接队列：当客户端返回ACK, 服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个 TCP 维护的队列，也就是全连接队列(Accept Queue)。</li>
</ul>
<p>SYN Flood 攻击原理：SYN Flood 属于典型的 DoS/DDoS 攻击。其攻击的原理很简单，就是用客户端在短时间内伪造大量不存在的 IP 地址，并向服务端疯狂发送 SYN。对于服务端而言，会产生两个危险的后果:</p>
<ol>
<li>处理大量的 SYN 包并返回对应 ACK, 势必有大量连接处于 SYN_RCVD 状态，从而占满整个半连接队列，无法处理正常的请求。</li>
<li>由于是不存在的 IP，服务端长时间收不到客户端的 ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。</li>
</ol>
<p>如何应对：</p>
<ol>
<li>增加 SYN 连接，也就是增加半连接队列的容量。</li>
<li>减少 SYN + ACK 重试次数，避免大量的超时重发。</li>
<li>利用 SYN Cookie 技术，在服务端接收到 SYN 后不立即分配连接资源，而是根据这个 SYN 计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复 ACK 的时候带上这个 Cookie 值，服务端验证 Cookie 合法之后才分配连接资源。</li>
</ol>
<h2 id="可靠传输原理，并设计可靠-UDP-协议。"><a href="#可靠传输原理，并设计可靠-UDP-协议。" class="headerlink" title="可靠传输原理，并设计可靠 UDP 协议。"></a>可靠传输原理，并设计可靠 UDP 协议。</h2><ul>
<li>建立连接（标志位）：通信前确认通信实体存在</li>
<li>序号机制（序号、确认号）：确保了数据是按序、完整到达</li>
<li>数据校验（校验和）：CRC 校验全部数据，校验包出错，丢弃报文段，不给出响应，超时重发</li>
<li>超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。<ul>
<li>RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。</li>
<li>RTO：重传间隔，通常每次重传 RTO 是前一次重传间隔的两倍，重传次数达到上限后停止重传。RTO = RTTs + 4*RTTd</li>
</ul>
</li>
<li>流量控制（流量窗口）</li>
<li>拥塞控制（拥塞窗口）</li>
</ul>
<h2 id="流量控制的作用，原理。"><a href="#流量控制的作用，原理。" class="headerlink" title="流量控制的作用，原理。"></a>流量控制的作用，原理。</h2><p>目的是避免发送过量，接收方通过 TCP 头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。</p>
<ul>
<li>发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段来告诉发送方自己的窗口大小，发送方根据这个值来设置自己窗口大小。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态，接收窗口类似。</li>
<li>TCP 是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中发送窗 = 已发送未确认部分 + 未发但可发送部分。接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 = 未接收但准备接收部分。</li>
<li>发送窗内的数据只有当收到接收端某段发送数据的 ACK 响应时才移动发送窗。接收窗口只会对窗口最后一个<strong>按序</strong>到达的字节进行确认。</li>
</ul>
<h2 id="TCP-拥塞控制的作用，理解具体原理。"><a href="#TCP-拥塞控制的作用，理解具体原理。" class="headerlink" title="TCP 拥塞控制的作用，理解具体原理。"></a>TCP 拥塞控制的作用，理解具体原理。</h2><p>作用：为了降低整个网络的拥塞程度。</p>
<p>拥塞控制使用拥塞窗口。TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p>
<ul>
<li>慢开始：发送的最初执行慢开始，令拥塞窗口 cwnd（congestion window） = 1，发送方只能发送一个报文段，当收到确认后，将 cwnd 加倍。</li>
<li>拥塞避免：设置一个慢开始门限 ssthresh ，当cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</li>
<li>快重传：在发送方，如果收到 3 个重复确认，那么知道下一个报文段丢失，此时执行快重传，立刻重传下一个报文段。</li>
<li>快恢复：快重传之后执行快恢复，令 ssthresh = cwnd / 2，cwnd = ssthresh，此时直接进入拥塞避免。</li>
</ul>
<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>
<ul>
<li>流量控制和拥塞控制：<ul>
<li>流量控制属于通信双方协商，拥塞控制涉及通信链路全局</li>
<li>实际最终发送窗口 = min{awnd（流量控制发送窗口）,cwnd（拥塞窗口）}</li>
</ul>
</li>
</ul>
<h2 id="DNS-的端口号；TCP-还是-UDP；作为缓存、负载均衡。"><a href="#DNS-的端口号；TCP-还是-UDP；作为缓存、负载均衡。" class="headerlink" title="DNS 的端口号；TCP 还是 UDP；作为缓存、负载均衡。"></a>DNS 的端口号；TCP 还是 UDP；作为缓存、负载均衡。</h2><p>DNS可以使用 UDP 和 TCP 进行传输，使用的端口号都为53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超市和重传来保证可靠性。在两种情况下会使用 TCP 进行传输：</p>
<ol>
<li>如果返回的响应超过 512 字节（UDP 最大只支持 512 字节的数据）。</li>
<li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li>
</ol>
<h2 id="IP-协议的作用"><a href="#IP-协议的作用" class="headerlink" title="IP 协议的作用"></a>IP 协议的作用</h2><h2 id="DNS-寻址过程"><a href="#DNS-寻址过程" class="headerlink" title="DNS 寻址过程"></a>DNS 寻址过程</h2><ul>
<li>浏览器 DNS 缓存</li>
<li>系统 DNS 缓存</li>
<li>本地 DNS 服务器</li>
<li>根 DNS 服务器</li>
<li>顶级 DNS 服务器</li>
<li>域名 DNS 服务器</li>
</ul>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="GET-与-POST-比较：作用、参数、安全性、幂等性、可缓存。"><a href="#GET-与-POST-比较：作用、参数、安全性、幂等性、可缓存。" class="headerlink" title="GET 与 POST 比较：作用、参数、安全性、幂等性、可缓存。"></a>GET 与 POST 比较：作用、参数、安全性、幂等性、可缓存。</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET</a></p>
<table>
<thead>
<tr>
<th></th>
<th>GET</th>
<th>POST</th>
</tr>
</thead>
<tbody><tr>
<td>请求是否有主体</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>安全</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>幂等</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>可缓存</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>作用</td>
<td>获取资源</td>
<td>传输实体主体</td>
</tr>
<tr>
<td>参数</td>
<td>以查询字符串出现在 URL 中</td>
<td>存储在实体主体中</td>
</tr>
</tbody></table>
<p>安全性：安全的 HTTP 方法不会改变服务器状态，也就是说他只是可读的。</p>
<p>幂等性：幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。所有的安全方法也都是幂等的。在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p>
<h2 id="HTTP-状态码。"><a href="#HTTP-状态码。" class="headerlink" title="HTTP 状态码。"></a>HTTP 状态码。</h2><table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接受的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Successful（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器请求处理出错</td>
</tr>
</tbody></table>
<ul>
<li><p>100 Continue：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</p>
</li>
<li><p>200 Ok</p>
</li>
<li><p>204 No Content：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</p>
</li>
<li><p>206 Partial Content：表示客户端进行了范围请求，响应报文包含由 Conent-Range 指定范围的实体内容。</p>
</li>
<li><p>301 Moved Permanently：永久重定向</p>
</li>
<li><p>302 Found：临时性重定向</p>
</li>
<li><p>303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</p>
<p>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</p>
</li>
<li><p>304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</p>
</li>
<li><p>307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</p>
</li>
<li><p>400 Bad Request：请求报文中存在语法错误</p>
</li>
<li><p>401 Unauthorized：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</p>
</li>
<li><p>403 Fobidden：请求被拒绝</p>
</li>
<li><p>404 Not Found</p>
</li>
<li><p>500 Internal Server Error ：服务器正在执行请求时发生错误。</p>
</li>
<li><p>503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p>
</li>
</ul>
<h2 id="Cookie-作用、安全性问题、和-Session-的比较。"><a href="#Cookie-作用、安全性问题、和-Session-的比较。" class="headerlink" title="Cookie 作用、安全性问题、和 Session 的比较。"></a>Cookie 作用、安全性问题、和 Session 的比较。</h2><ul>
<li><p>Session 在服务端，Cookie 在客户端（浏览器）</p>
</li>
<li><p>Session 的运行依赖 session_id，session_id 存在 Cookie 中，如果浏览器禁用可以用其他方式实现，比如在 URL 中传递 session_id。</p>
</li>
</ul>
<p>用途：</p>
<ol>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ol>
<ul>
<li>标记为 HttpOnly 的 Cookie 不能被 Javascript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>document.cookie</code> API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</li>
<li>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</li>
</ul>
<p>Cookie 与 Session 选择</p>
<ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session；</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li>
<li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li>
</ul>
<h2 id="缓存的-Cache-Control-字段，特别是-Expires-和-max-age-的区别。ETag-验证原理。"><a href="#缓存的-Cache-Control-字段，特别是-Expires-和-max-age-的区别。ETag-验证原理。" class="headerlink" title="缓存的 Cache-Control 字段，特别是 Expires 和 max-age 的区别。ETag 验证原理。"></a>缓存的 Cache-Control 字段，特别是 Expires 和 max-age 的区别。ETag 验证原理。</h2><p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</p>
<ul>
<li><p>no-store 指令规定不能对请求或响应的任何一部分进行缓存 <code>Cache-Control：no-store</code></p>
</li>
<li><p>no-cache 指令规定缓存服务器需要先向源服务器验证缓存的有效性，只有当缓存服务器有效才将能使用该缓存对客户端的请求进行相应</p>
</li>
<li><p>private 指令规定了将资源作为私有缓存，只能被单独用户所使用，一般存储在用户浏览器中。public 指令规定了将资源作为公共缓存，可以被多个用户所使用，一般存储在代理服务器中。</p>
</li>
<li><p>max-age 指令出现在请求报文中，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。max-age 指令出现在响应报文中，表示缓存资源在缓存服务器中保存的时间。Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。在 HTTP/1.1 中，会优先处理 max-age 指令；在 HTTP/1.0 中，max-age 指令会被忽略掉。 </p>
</li>
</ul>
<p>ETag：它是资源的唯一标识。URL 不能唯一表示资源，例如 <code>http://www.google.com/</code> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。<code>ETag: &quot;82e22293907ce725faf67773957acd12&quot;</code>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。 <code>If-None-Match: &quot;82e22293907ce725faf67773957acd12&quot;</code></p>
<p>304 也是一种很好的缓存手段：服务器响应文件内容时，同时响应 etag 标签(内容的签名，内容变了他就变)， 和 last_modified_since 两个标签值。浏览器下次去请求时，头信息发送这两个标签,，服务器检测文件有没有发生变化,如无,直接头信息返回 etag，last_modified_since。浏览器知道内容无改变，于是直接调用本地缓存。这个过程，也请求了服务器，但是传输的内容极少。对于变化周期较短的，如静态 html、js、css 比较适于用这个方式。</p>
<h2 id="长连接与短连接原理以及使用场景，流水线。"><a href="#长连接与短连接原理以及使用场景，流水线。" class="headerlink" title="长连接与短连接原理以及使用场景，流水线。"></a>长连接与短连接原理以及使用场景，流水线。</h2><p><a href="https://cloud.tencent.com/developer/article/1115572" target="_blank" rel="noopener">关于HTTP协议中的保持连接</a></p>
<ul>
<li><p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p>
</li>
<li><p>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</p>
</li>
<li><p>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</p>
</li>
<li><p>短连接：连接-&gt;传输数据-&gt;关闭连接</p>
</li>
<li><p>长连接：连接-&gt;传输数据-&gt;保持连接 -&gt; 传输数据-&gt; ………..-&gt;直到一方关闭连接，多是客户端关闭连接。</p>
</li>
</ul>
<p>HTTP的长连接和短连接本质上是 TCP 长连接和短连接。</p>
<ul>
<li>HTTP 1.0 默认使用短连接，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。</li>
<li>HTTP 1.1 默认使用长连接。使用长连接的HTTP协议，会在响应头有加入这行代码 <code>Connection:keep-alive</code>。</li>
<li>TCP 短连接：短连接一般只会在 client/server 间传递一次读写操作。优点是管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。</li>
<li>TCP 长连接：Client 与 server 完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</li>
</ul>
<p>心跳包用来解决半连接问题。<br>当服务器断电、断网、丢弃三次握手的ack包都可能造成客户端半连接，同时客户端断电、断网，或者中间设备故障也可能造成服务器端半连接。<br>半连接出现后，从系统层面考虑，对服务器而言，害怕的是量大导致资源耗尽从而拒绝服务；对客户端而言，系统危害不大，连接一致性无法保证。从业务层面而言，如果是长连接的推送服务，如果客户端故障导致，将导致推送数据失败。</p>
<p>TCP 的保活功能：主要为服务器应用提供。如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务端器端检测到这种半开放的连接。在 Linux 操作系统中，我们可以通过代码启用一个 socket 的心跳检测（即每隔一定时间间隔发送一个心跳检测包给对端）。</p>
<p>应用层心跳包：TCP 提供的 KeepAlive 机制无法代替心跳包。为了保持长连接，它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活着。</p>
<h2 id="HTTP-存在的安全性问题，以及-HTTPs-的加密、认证和完整性保护作用。"><a href="#HTTP-存在的安全性问题，以及-HTTPs-的加密、认证和完整性保护作用。" class="headerlink" title="HTTP 存在的安全性问题，以及 HTTPs 的加密、认证和完整性保护作用。"></a>HTTP 存在的安全性问题，以及 HTTPs 的加密、认证和完整性保护作用。</h2><p>安全性问题：</p>
<ul>
<li>使用明文进行通信，内容可能会被窃听</li>
<li>不验证通信方身份，通信方的身份可能遭遇伪装</li>
<li>无法验证报文的完整性，报文有可能遭篡改</li>
</ul>
<p>HTTPs：让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPs 使用了隧道进行通信。通过使用 SSL，HTTPs 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p>
<ol>
<li>客户端请求服务器获取<code>证书公钥</code></li>
<li>客户端(SSL/TLS)解析证书（无效会弹出警告）</li>
<li>生成随机值</li>
<li>用<code>公钥加密</code>随机值生成<strong>密钥</strong></li>
<li>客户端将<code>秘钥</code>发送给服务器</li>
<li>服务端用<code>私钥</code>解密<code>秘钥</code>得到随机值</li>
<li><code>将信息和随机值混合在一起</code>进行对称加密</li>
<li>将加密的内容发送给客户端</li>
<li>客户端用<code>秘钥</code>解密信息</li>
</ol>
<h2 id="什么是队头阻塞"><a href="#什么是队头阻塞" class="headerlink" title="什么是队头阻塞"></a>什么是队头阻塞</h2><h3 id="TCP-队头阻塞"><a href="#TCP-队头阻塞" class="headerlink" title="TCP 队头阻塞"></a>TCP 队头阻塞</h3><p>TCP 要求数据严格按照序号顺序，如果第一个 TCP 分节丢失了，客户端将一直等待丢失的分节重传成功，这样就延缓了后面数据的接收。</p>
<p>如何解决：不使用 TCP 协议，比如 google 推出的 quic 协议，它是在 UDP 基础上实现的可靠传输。还有一个 SCTP（流控制传输协议），它是和 TCP，UDP 在同一层次的传输协议。SCTP 的多流特性也可以尽可能的避免队头阻塞的情况。</p>
<h3 id="HTTP-1-1-队头阻塞"><a href="#HTTP-1-1-队头阻塞" class="headerlink" title="HTTP 1.1 队头阻塞"></a>HTTP 1.1 队头阻塞</h3><p>HTTP 1.1 允许在持久连接上可选的使用管道化（pipeline）特性。管道化允许客户端在已发送的请求收到服务端的响应之前发送下一个请求，，借此来减少等待时间提高吞吐；如果多个请求能在同一个TCP分节发送的话，还能提高网络利用率。</p>
<p>但是管道化要求服务端按照请求发送的顺序返回响应，因为 HTTP 请求和响应没有序号标识，无法将乱序的响应与请求关联起来。所以一个响应返回延迟了，后续的响应都会被延迟，直到队头的响应送达。</p>
<p>如何解决：使用 HTTP 2.0。HTTP 2.0 采用二进制分帧，将阐述信息分割为更小的消息和帧，对他们采用二进制格式编码。比如 header 帧，Data 帧。这些帧可以打散乱序发送，然后根据每个帧首部的流标识符重新组装，并且可以根据优先级，决定优先处理哪个流的数据。</p>
<h2 id="HTTP-1-x-的缺陷，以及-HTTP-2-的特点。"><a href="#HTTP-1-x-的缺陷，以及-HTTP-2-的特点。" class="headerlink" title="HTTP/1.x 的缺陷，以及 HTTP/2 的特点。"></a>HTTP/1.x 的缺陷，以及 HTTP/2 的特点。</h2><ul>
<li>HTTP/1.X 缺陷：<ul>
<li>客户端需要使用多个连接才能实现并发和缩短延迟</li>
<li>不会压缩请求和响应首部，从而导致不必要的网络流量</li>
<li>不支持有效的资源优先级，导致底层 TCP 连接的利用率低下</li>
<li>客户端需要主动请求</li>
<li>队头阻塞</li>
</ul>
</li>
<li>HTTP/2：<ul>
<li>二进制分帧层：HTTP 2 是二进制协议，他下用二进制格式传输数据而不是 1.x 的文本格式。它将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。在通信过程中，只会有一个 TCP 连接存在，它承载力任意数量的数据流。</li>
<li>服务器推送：HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</li>
<li>首部压缩：HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</li>
<li>多路复用：HTTP2 让所有的通信都在一个 TCP 连接上完成，实现了请求并发，后面的请求不用再等待，解决了队头阻塞。</li>
</ul>
</li>
</ul>
<h2 id="HTTP-1-1-的特性。"><a href="#HTTP-1-1-的特性。" class="headerlink" title="HTTP/1.1 的特性。"></a>HTTP/1.1 的特性。</h2><ul>
<li>默认是长连接</li>
<li>支持流水线</li>
<li>支持同时打开多个 TCP 连接</li>
<li>支持虚拟主机</li>
<li>新增状态码 100</li>
<li>支持分块传输编码</li>
<li>新增缓存处理指令 max-age</li>
</ul>
<h2 id="HTTP-与-FTP-的比较。"><a href="#HTTP-与-FTP-的比较。" class="headerlink" title="HTTP 与 FTP 的比较。"></a>HTTP 与 FTP 的比较。</h2><ul>
<li>FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件</li>
<li>控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答</li>
<li>数据连接：用来传送一个文件数据</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://juejin.im/post/5ce37660f265da1bb13f05f0" target="_blank" rel="noopener">什么是队头阻塞以及如何解决</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP 协议入门</a></li>
<li><a href="https://www.cnblogs.com/qcrao-2018/p/10182185.html" target="_blank" rel="noopener">“三次握手，四次挥手”你真的懂吗？</a></li>
<li><a href="https://juejin.im/post/5e527c58e51d4526c654bf41" target="_blank" rel="noopener">TCP协议灵魂之问，巩固你的网路底层基础</a></li>
<li><a href="https://juejin.im/post/5d9c284b518825095879e7a5" target="_blank" rel="noopener">面试官，不要再问我三次握手和四次挥手</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liuyuqi21.github.io/2020/01/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" data-id="ckd5czhio003ynnnrcp3hdu4c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java 虚拟机" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/28/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/" class="article-date">
  <time datetime="2020-01-28T14:40:27.000Z" itemprop="datePublished">2020-01-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/28/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/">Java 虚拟机</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现。目的是使用相同的字节码，他们都会给出相同的结果。</p>
<blockquote>
<p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
</blockquote>
<p>JVM 由三个主要的子系统构成</p>
<ul>
<li>类加载子系统</li>
<li>运行时数据区（内存结构）</li>
<li>执行引擎</li>
</ul>
<p>JDK 包含 JRE，JRE 包含 JVM，JVM 用来运行 class 文件，对对象的自动管理、内存管理，JDK 多了 Tools，方便你进行 Java 开发，最终还是交给 JVM 运行。</p>
<h1 id="Java-内存区域（运行时数据区）"><a href="#Java-内存区域（运行时数据区）" class="headerlink" title="Java 内存区域（运行时数据区）"></a>Java 内存区域（运行时数据区）</h1><p><img src="https://gitee.com/cellophane/image/raw/master/20200408010428.png" alt=""></p>
<p><img src="https://gitee.com/cellophane/image/raw/master/20200408003517.png" alt=""></p>
<p><img src="https://gitee.com/cellophane/image/raw/master/20200408003720.png" alt=""></p>
<p><img src="https://gitee.com/cellophane/image/raw/master/20200407211124.png" alt=""></p>
<h2 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h2><p>程序计数器就是记录当前线程执行程序的位置，改变计数器的值来确定执行的下一条指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</p>
<p>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。所以他是<strong>线程私有</strong>的。</p>
<p>程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
<h2 id="Java-虚拟机栈（Stack）"><a href="#Java-虚拟机栈（Stack）" class="headerlink" title="Java 虚拟机栈（Stack）"></a>Java 虚拟机栈（Stack）</h2><p>Java 虚拟机栈线程私有的，生命周期和线程相同，创建线程的时候就会创建一个 Java 虚拟机栈。</p>
<p>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack)，其中栈就是现在说的虚拟机栈。</p>
<p>虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储<strong>局部变量表、操作栈、动态链接、方法出口</strong>等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p><strong>局部变量存放在 Java 虚拟机栈的局部变量表中</strong>。Java8 中基本类型的局部变量的值存放在虚拟机栈的局部变量表中，如果是引用型的变量，则只存储对象的引用地址。</p>
<p>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError（OOM）。</p>
<ul>
<li>StackOverFlowError：若 Java 虚拟机栈的内存大小不允许动态扩展，那么当<strong>线程请求栈的深度超过当前 Java 虚拟机栈的最大深度</strong>的时候，就抛出 StackOverFlowError 异常。</li>
<li>OutOfMemoryError：若 Java 虚拟机栈的内存大小允许动态扩展，且当<strong>线程请求栈时内存用完了</strong>，无法再动态扩展了，此时抛出 OutOfMemoryError 异常。比如当用户请求 web 服务器，每个请求开启一个线程负责用户的响应计算（每个线程分配一个虚拟机栈空间），如果并发量大时，可能会导致内存溢出（OutOfMemoneyError），可以适当的把每个虚拟机栈的大小适当调小一点，减少内存的使用量来提高系统的并发量。</li>
</ul>
<p>当前栈帧对应方法，没有放对象，但是放了对象的引用。</p>
<h2 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h2><p>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的本地方法（Native）服务。线程在调用本地方法时，来存储本地方法的局部变量表，本地方法的操作数栈等等。</p>
<blockquote>
<p>本地方法：是非 Java 语言实现的方法，例如 Java 调用 C 语言，来操作某些硬件信息。</p>
</blockquote>
<p>线程的 start() 方法是本地方法。</p>
<p>在 Java 虚拟机栈调用本地方法栈是动态链接的一种。 </p>
<h2 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h2><p><img src="https://gitee.com/cellophane/image/raw/master/20200407215851.png" alt=""></p>
<p>堆里面存放的都是<strong>对象的实例</strong>，几乎所有的对象实例以及数组都在这里分配内存，当对象无法在该空间申请到内存时将抛出 OutOfMemoryEror 异常。Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC堆</strong>（Garbage Collected Heap）。</p>
<p>普通成员变量存储在堆中，因为成员变量随着对象的创建而存在。静态变量存储在方法区中，因为静态变量随着类加载的创建而存在。</p>
<p>堆由年轻代和老年代组成，老年代占堆的2/3空间，而年轻代内存又被分为三部分：Eden 空间、From Survivaor 空间、To Survivor 空间。默认情况下 Eden:From Survivor:To Survivor 按照 8:1:1 的比例来分配。没有直接设置老年代的参数，可以通过堆空间大小和新生代空间大小两个参数来间接控制。</p>
<blockquote>
<p>老年代空间大小 = 堆空间大小 - 年轻代空间大小</p>
</blockquote>
<ul>
<li>Eden：新创建的对象放在 Eden 区，如果 Eden 区放不下，就直接放到老年代里面去（分配担保机制）。</li>
<li>From Survivor 和 To Survivor：保存新生代 gc 后还存活的对象。</li>
<li>老年代：对象存活时间比较长（经过多次新生代的垃圾收集，默认是15次）的对象则进入老年的。当堆中分配的对象实例过多，且大部分对象都在使用，就会报内存溢出异常（OutOfMemoneyError）。</li>
</ul>
<p>新生代 GC 叫做 Young GC/Minor GC，老年代 GC 叫做 Old GC/Major GC，Full GC = Yong GC + Old GC + MetaSpace。</p>
<p>在 JDK 1.8 中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是 JVM 的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。</p>
<h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p>方法区存储<strong>已被虚拟机加载</strong>的类信息（构造方法/接口定义）、常量、静态变量、运行时常量池、即时编译器编译后的代码等数据，是线程共享的内存区域。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。（jdk1.8之前hotsopt虚拟机叫永久代/持久代，jdk1.8时叫元空间（MetaSpace））</p>
<p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了，方法的垃圾回收主要针对常量池回收、类型卸载（比如反射生成大量的临时使用的Class等信息）。</p>
<ul>
<li>会发生内存溢出</li>
</ul>
<h3 id="运行时常量池（Run-Time-Constant-Pool）"><a href="#运行时常量池（Run-Time-Constant-Pool）" class="headerlink" title="运行时常量池（Run-Time Constant Pool）"></a>运行时常量池（Run-Time Constant Pool）</h3><p>常量池用于存放<strong>编译期</strong>生成的各种字节码和符号引用，常量池具有一定的动态性，里面可以存放编译期生成的常量；<strong>运行期间</strong>的常量也可以添加进入常量池中，比如 string 的 intern() 方法。</p>
<p>JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。</p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>JVM 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，内存垃圾回收主要集中于<strong>堆和方法区</strong>中，在程序运行期间，这部分内存的分配和使用都是动态的。</p>
<p><img src="https://gitee.com/cellophane/image/raw/master/20200408005510.png" alt=""></p>
<h2 id="对象存活判断"><a href="#对象存活判断" class="headerlink" title="对象存活判断"></a>对象存活判断</h2><ul>
<li><p>引用计数：每个对象有一个引用计数属性，新增一个引用时计数加 1，引用释放时计数减 1，计数为 0 可回收。引用计数简单但无法解决对象相互循环引用的问题，所以 Java 虚拟机不适用引用计数法。</p>
</li>
<li><p>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的，不可达对象。 </p>
<p>GC Roots 一般包含以下内容：</p>
<ul>
<li>虚拟机栈中局部变量表中引用的对象</li>
<li>本地方法栈中 JNI 中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用对象</li>
</ul>
</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。</p>
<p>缺点：</p>
<ul>
<li>效率不高</li>
<li>产生大量不连续的内存碎片</li>
</ul>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>实现简单，运行高效。代价是将内存缩小为原来的一半，持续复制长生存期的对象导致效率降低。</p>
<p>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</p>
<p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。</p>
<ul>
<li>优点：不会产生内存碎片</li>
<li>缺点：需要移动大量对象，处理效率比较低</li>
</ul>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>
<p>一般将堆分为新生代和老年代。</p>
<ul>
<li>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</li>
<li>而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“<strong>标记-清理</strong>”或“<strong>标记-整理</strong>”算法来进行回收。</li>
</ul>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="https://gitee.com/cellophane/image/raw/master/20200408010311.png" alt=""></p>
<h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>以串行的方式执行，只使用一个线程去回收，垃圾收集的过程中会 Stop The World（服务暂停）。是新生代收集器，使用 <strong>复制</strong> 算法。</p>
<p>它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p>
<p>它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</p>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>它是 Serial 收集器的多线程版本。它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</p>
<h3 id="Parallel-Scavenge-收集器（1-8默认）"><a href="#Parallel-Scavenge-收集器（1-8默认）" class="headerlink" title="Parallel Scavenge 收集器（1.8默认）"></a>Parallel Scavenge 收集器（1.8默认）</h3><p>是多线程收集器（并行），采用<strong>复制</strong>算法。</p>
<p>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目的是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。</p>
<h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p>是 Parallel Scavenge 收集器的老年代版本，使用多线程和<strong>标记－整理</strong>算法。</p>
<p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p>是 Serial 收集器的老年代版本，算法使用的是 <strong>标记-整理</strong> 也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：</p>
<ul>
<li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ul>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，适用于 <strong>老年代</strong>。Mark Sweep 指的是 <strong>标记-清除</strong> 算法。</p>
<p>分为以下四个流程：</p>
<ul>
<li><p>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</p>
</li>
<li><p>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</p>
</li>
<li><p>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</p>
</li>
<li><p>并发清除：不需要停顿。</p>
</li>
</ul>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<ul>
<li>优点：并发收集，低停顿</li>
<li>缺点：<ul>
<li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li>
<li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li>
<li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li>
</ul>
</li>
</ul>
<h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p>G1 是目前技术发展的最前沿成果之一，HotSpot 开发团队赋予它的使命是未来可以替换掉 JDK1.5 中发布的 CMS 收集器。</p>
<p>G1 直接对新生代和老年代一起回收，把堆划分为多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p>
<p>具备以下特点：</p>
<ul>
<li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
<h2 id="内存分配策略与回收策略"><a href="#内存分配策略与回收策略" class="headerlink" title="内存分配策略与回收策略"></a>内存分配策略与回收策略</h2><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p><img src="https://gitee.com/cellophane/image/raw/master/classload.png" alt=""></p>
<p><img src="https://gitee.com/cellophane/image/raw/master/20200407201734.png" alt=""></p>
<p><img src="https://gitee.com/cellophane/image/raw/master/20200407232110.png" alt=""></p>
<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载-验证-准备-解析-初始化-使用-卸载七个阶段。其中<strong>验证、准备、解析</strong>三个部分统称为<strong>连接</strong>。</p>
<p>准备：给静态变量赋初始值，比如<code>public static int a = 10</code>，在准备的时候赋值为 0，初始化的时候才赋值为 10。</p>
<p>解析：符号引用转化为直接引用。</p>
<p>ClassLoader 类加载器</p>
<p><img src="https://gitee.com/cellophane/image/raw/master/20200407233339.png" alt=""></p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ul>
<li>通过类的完全限定名称获取定义该类的二进制字节流</li>
<li>将该字节流表示的静态存储结构转换为方法去的运行时存储结构</li>
<li>在内存中生成一个代表该类的 class 对象，作为方法区中该类各种数据的访问入口 </li>
</ul>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托到父加载器去完成，依此向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
<p>意义：</p>
<ul>
<li>系统类防止内存中出现多份同样的字节码，同样全限定名的类只加载一次</li>
<li>保证 Java 程序安全稳定运行</li>
</ul>
<p>全盘负责委托机制</p>
<h3 id="如何破坏双亲委派"><a href="#如何破坏双亲委派" class="headerlink" title="如何破坏双亲委派"></a>如何破坏双亲委派</h3><h2 id="类加载器的种类"><a href="#类加载器的种类" class="headerlink" title="类加载器的种类"></a>类加载器的种类</h2><p>启动类加载器</p>
<p>扩展类加载器</p>
<p>系统类加载器</p>
<p>用户自定义加载器</p>
<h1 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h1><blockquote>
<p>cpu 的处理速度远快于内存的读写速度，因此 Java 采用高速缓存建立其桥梁。</p>
</blockquote>
<p><img src="https://gitee.com/cellophane/image/raw/master/20200409012349.png" alt=""></p>
<p><img src="https://gitee.com/cellophane/image/raw/master/20200409112634.png" alt=""></p>
<p>Java 内存模型规范数抽象的概念，描述的是程序间变量的访问规则（多线程程序允许表现出的行为），Java 线程内存模型与 CPU 缓存模型类似，它是标准化的，用于屏蔽掉各种硬件和操作系统内存访问差异。</p>
<p>在 JDK1.2 之前，Java 的内存模型实现总是从<strong>主存</strong>（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。</p>
<p><img src="https://gitee.com/cellophane/image/raw/master/%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4.png" alt=""></p>
<p>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。</p>
<p>Java 内存模型（Java Memory Model，JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了 Java 程序在各种平台下对内存的访问都能保证效果一致的机制及规范。<br>目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。</p>
<ol>
<li>Java 内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存</li>
<li>线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。</li>
<li>不同的线程之间无法直接访问对方工作内存中的变量</li>
<li>线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行</li>
</ol>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>当一个变量被定义成 <code>volatile</code> 后，它具备两种特性</p>
<ol>
<li>可见性：当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。</li>
</ol>
<p>volatile 变量在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中 volatile 变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是 Java 里面的<strong>运算并非原子操作</strong>，导致 volatile 变量的运算在并发下一样是不安全的。</p>
<p>示例：</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> race <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    race<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果发起 20 个线程，每个线程对 race 变量进行 10000 次自增操作，如果这段代码能够正确并发的话，最后输出的结果应该是200000。但是实际上每次运行程序，输出的结果都不一样，都是一个小于 200000 的数字。</p>
<p>因为自增运算 <code>race++</code> 不是原子的。导致 <code>volatile</code> 变量的<strong>运算</strong>在并发下一样是不安全的，仍然要通过 <code>synchorized</code> 加锁来保证原子性。</p>
<p>volatile 的使用场景：下面的代码能保证当 shutdown() 方法被调用时，能保证所有线程中执行的 doWork() 方法都立即停下来。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">volatile</span> <span class="token keyword">boolean</span> shutdownRequested<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    shutdownRequested <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>shutdownRequested<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//do stuff</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="2">
<li>禁止指令重排序</li>
</ol>
<h2 id="synchorized"><a href="#synchorized" class="headerlink" title="synchorized"></a>synchorized</h2><p>synchorized 块之间的操作具备原子性。</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>1000 个线程同时对 num 执行自增的操作，得到的结果可能是 980，因为一个线程执行自增过程中，另一个线程也执行了自增，两个线程同时写入了主内存。<br>解决方式：</p>
<ul>
<li>原子类（Atomic）：使用 <code>AutomicInteger</code> 来保证原子性</li>
</ul>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> AtomicInteger num <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>互斥锁：<code>synchronized</code> 用来保证方法和代码块内的操作是原子性的。</li>
</ul>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>在下列情况下，线程 B 读取的值可能不是线程 A 写入的最新值。</p>
<ul>
<li>执行线程 A 的处理器把变量 V 缓存到寄存器中</li>
<li>执行线程 A 的处理器吧变量 V 缓存到自己的缓存中，但还没有同步刷新到主内存中去</li>
<li>执行线程 B 的处理器的缓存中有变量 V 的旧值</li>
</ul>
<p>解决方式：</p>
<ul>
<li>使用 <code>volatile</code> 来保证多线程操作时变量的可见性。被其修饰的变量在被修改后可以立即同步到主内存，在每次是用之前都从主内存刷新。</li>
<li>使用 <code>synchorized</code> 加锁，同步块的可见性是由“对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存”这条规则获得的。</li>
<li>使用 <code>final</code> 关键字。</li>
</ul>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>无序是因为<strong>指令重排</strong>。单线程下提高代码效率，但会影响多线程并发执行的正确性。</p>
<p>指令重排：</p>
<ul>
<li>编译器生成指令的次序，可以不同于源代码的版本。</li>
<li>处理器可以乱序或者并行的执行指令。</li>
<li>缓存会改变写入提交到主内存的变量的次序。</li>
</ul>
<p>解决方式：</p>
<ul>
<li><code>volatile</code> 关键字会禁止指令重排</li>
<li><code>synchronized</code> 关键字保证同一时刻只允许一条线程操作。</li>
</ul>
<h1 id="JVM-性能调优工具"><a href="#JVM-性能调优工具" class="headerlink" title="JVM 性能调优工具"></a>JVM 性能调优工具</h1><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>查看正在运行的 java 程序，可以查看到死锁。</p>
<p><img src="https://gitee.com/cellophane/image/raw/master/20200407225324.png" alt=""></p>
<h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p>查看正在运行的 Java 程序的扩展</p>
<h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p>可以查看堆内存各部分的使用量，以及加载类的数量。</p>
<p><code>jstat [-命令选项] [vmid] [间隔时间/毫秒] [查询次数]</code></p>
<h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p>堆内存 dump，可以在设置内存溢出的时候自动导出 dump 文件。在内存溢出的时候，拿到这个文件进行分析，比如使用 jvisualvm。</p>
<ol>
<li>-XX:+HeapDumpOnOutOfMemoryError</li>
<li>-XX:HeapDumpPath=输出路径</li>
</ol>
<h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li>图基本来自网上视频（鲁班、咕泡、图灵等，b站有）</li>
<li><a href="http://www.ityouknow.com/java.html" target="_blank" rel="noopener">JVM 系列文章</a></li>
<li><a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener">Java 虚拟机</a></li>
<li><a href="https://juejin.im/post/5dd627efe51d4536be153b7a" target="_blank" rel="noopener">再有人问你 Java 内存模型是什么，就把这篇文章发给他</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/index.html" target="_blank" rel="noopener">探索 ConcurrentHashMap 高并发性的实现机制</a></li>
<li><a href="https://juejin.im/post/5cb5d419e51d456e500f7d02" target="_blank" rel="noopener">关于Java内存模型的三个特性</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liuyuqi21.github.io/2020/01/28/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA/" data-id="ckd5czhhj000gnnnr0jx6hjio" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-秋招面经" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/20/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/" class="article-date">
  <time datetime="2020-01-20T11:22:05.000Z" itemprop="datePublished">2020-01-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/20/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/">秋招面经</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h1><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>一面面试官人真的很好，我项目介绍这块真的太垃圾了，他都叫我慢慢说，画张图理清思路，我画完图说了一遍他都觉得我这个项目没啥特点，他就随便问，好多地方我就是没过脑子随便乱说，他就说我不能这么说，面试完了他还跟我说了很多建议，说我学一个东西不能就随便学一下，要去了解他的原理，还说很多中小型企业的人，都是停留在写业务代码的阶段，写个十几年都跟两三年没什么区别，哎。一共聊了一个多小时，估计我是他最后一个面试的人他也不着急，有时间就多说会儿吧。</p>
<ul>
<li>自我介绍，介绍项目</li>
<li>项目中es的使用，写了一条sql语句，让我转换为es</li>
<li>项目的难点</li>
<li>在项目中学到了什么</li>
<li>定时发送邮件怎么实现的 我说框架里的，但是最终会转换为 shell 脚本，他问我 crontab 用过吗，我。学过，没怎么用，我就记得他那个分时日月周</li>
<li>队列怎么实现的，除了 redis 有用过其他的队列吗 我，没用过，知道一点，比如 RabbitMQ 他问我，RabbitMQ 又是怎么实现队列的呢</li>
<li>redis 有什么特点</li>
<li>zset 怎么使用</li>
<li>数据库中什么时候要建立索引</li>
<li>乐观锁和悲观锁，读锁是乐观锁还是悲观锁</li>
<li>mysql 主从复制</li>
<li>binlog 里存的是什么</li>
<li>项目中数据库的量级多少 我脑袋一片空白，说了句不大，他说我不能这么说。</li>
<li>tcp 和 udp 介绍一下</li>
<li>进程间通信的方式，并说出每一种的特点</li>
<li>大小堆了解吗 用在什么地方</li>
<li>linux 内存泄漏怎么解决</li>
<li>c 语言学的如何</li>
<li>算法 链表中倒数第k个节点，只能遍历一次 </li>
<li>算法 跳台阶</li>
<li>单元测试了解吗</li>
<li>在生活中和别人遇到冲突怎么解决</li>
<li>觉得自己的表现怎么样</li>
<li>给我提了一些建议</li>
<li>有什么想问他的</li>
</ul>
<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><p>二面面试官拿到我的简历看了几秒就在笑，我？？？，他说你这怎么是群众，我，没交团费吧，我也不知道是团员还是群众了，反正不入党都一样，他说，24岁以后没入党才会变为群众，或者没交团费，幽默的面试官~</p>
<ul>
<li>又是介绍项目，我巴拉巴拉说完了，他。。啥也没问，估计他觉得这项目太没意思了</li>
<li>redis 里的数据结构 zset 底层是怎么样的</li>
<li>链表怎么插入和删除</li>
<li>b+ 树是怎么样的</li>
<li>b+ 树的根节点是怎么存放索引的，我。。不知道，瞎扯了半天开始说聚簇索引非聚簇。。。他又笑我然后不问了</li>
<li>nginx 和 php 怎么通信的</li>
<li>tcp 和 udp</li>
<li>linux 问一个日志文件里，每行都是 key=xxx，如何计算出每一种key的数量，我在纸上先写了gerp。。然后写了个awk。。我是真不会写。他就说我用grep但是不知道xxx是什么，所以要先得到xxx，我说用awk，awk可以得到第几列的字段，但是他怎么写我忘了，反正能这么做，他说好，可以。那么得到以后如何去重呢，我想了会儿，说linux应该是有一个命令去重的，看过来着，他说有，但是我可以用别的方式，我就说，那php就是放到数组里，然后用一个函数去重吧。ok。</li>
<li>他盯着我的简历，说，诶，发现一个有意思的了，然后又问我es。 match 和 match_parse 有什么区别，match 和 term 有什么区别。</li>
<li>算法 反转二叉树</li>
<li>算法 接雨水问题  哎，这个我看到过但是不记得怎么做了，临时想了半天给他解释了好久思路，最后他认可了，说了句挺聪明，然后就结束面试了，然后我就被小姐姐带走，小姐姐告诉我出门左转</li>
</ul>
<h1 id="奇安信"><a href="#奇安信" class="headerlink" title="奇安信"></a>奇安信</h1><p>不想吐槽这个辣鸡公司，0好感，面试觉得自己像个犯人被拷问。后来又被拉起来面了一次，那次的一二面面试官态度都不错但是没问什么东西，最后开价太低拒了。</p>
<ul>
<li>Mvc 解释</li>
<li>面向对象</li>
<li>单例模式</li>
<li>闭包</li>
<li>yield </li>
<li>Self 和 static 区别 </li>
<li>MySQL int 类型可以存多大的数字</li>
<li>Linux 命令 crontab ps </li>
<li>Xss csrf </li>
<li>Redis 怎么查看内存占用</li>
<li>rdb aof，rdb 磁盘上怎么写</li>
<li>Redis 数据类型</li>
<li>32 位是多少字节</li>
<li>Nginx</li>
<li>Php 怎么起一个进程后台运行</li>
<li>Php 怎么返回一个状态码</li>
<li>Curl 怎么用的，怎么得到状态码</li>
<li>Php 怎么下载扩展</li>
<li>Redis 内部结构动态字符串</li>
<li>Redis 过期策略：惰性过期和定期过期</li>
<li>nginx 禁止访问目录</li>
<li>git 撤销暂存</li>
</ul>
<h1 id="美团-2019-12-31"><a href="#美团-2019-12-31" class="headerlink" title="美团 2019/12/31"></a>美团 2019/12/31</h1><p>转 Java 后的第一面，开头就跟面试官说我学 Java 才两个多月。。然后他问了挺多 Java 的问题，好多我就说没学到，最后他问我在不在北京，下周去现场面。然后两天后又告诉我没 hc 了。</p>
<ul>
<li>介绍项目</li>
<li>分布式锁的实现</li>
<li>分布式锁过期解决</li>
<li>分布式数据库主从复制</li>
<li>前缀树是什么 前缀树的使用场景</li>
<li>MySQL 死锁发生的原因和解决</li>
<li>MySQL 分别建立索引 a,b,c 语句 <code>select ...where b=x,c=x,a=x</code> 能不能用到索引，建立联合索引能不能用到，<code>a=x,b&gt;x</code> 能不能用到，用到几个索引</li>
<li>B 树和 b+ 树的区别 b+ 树的优点</li>
<li>MVCC 怎么实现的</li>
<li>Linux cpu 满了怎么排查</li>
<li>怎么查看占 cpu 最多的线程</li>
<li>Linux 怎么搜索文件中的字符串，写到另一个文件中</li>
<li>liunx 网络相关命令</li>
<li>Java == 和 equals</li>
<li>Java contentMap 线程安全怎么实现</li>
<li>哈希冲突解决的方法</li>
<li>Java 异常</li>
<li>Java 类加载</li>
<li>什么是泛型 泛型的使用场景</li>
<li>面向过程和面向对象</li>
<li>多态 父类如何调用子类的方法</li>
<li>单例模式的用途 静态内部类实现单例模式的方式</li>
<li>工厂模式的用途</li>
<li>策略模式的用途</li>
<li>Get 和 post 请求的区别</li>
<li>网页请求的整个过程</li>
<li>说说自己的优缺点，对缺点的改进</li>
</ul>
<h1 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h1><p>最想去的公司，没想到投简历后不到半天就约面试了，1.5 号约的 1.16 又被我改到 1.19。一面结束的时候以为自己凉凉，因为算法题没想出来，没想到第二天 hr 约了年后二面。</p>
<h2 id="一面-2020-1-19"><a href="#一面-2020-1-19" class="headerlink" title="一面 2020/1/19"></a>一面 2020/1/19</h2><ul>
<li>介绍项目</li>
<li>分布式锁的实现 如果判断锁是不是自己的（value = 线程 ID来判断，面试官说线程 ID 不可以，问我线程 ID 长啥样， 不知道，你们实际用的是什么，记不清）</li>
<li>java 有什么数据类型</li>
<li>float 和 double 分别占用多少字节</li>
<li>java 有哪些集合 map 有几种</li>
<li>hashMap 怎么实现的</li>
<li>hashMap 怎么插入的，只是插入到链表不会变吗（大于8变成红黑树），怎么哈希的，怎么扩容的</li>
<li>ConcurrentHashMap 怎么实现的，分段锁怎么实现的</li>
<li>数据库 索引怎么实现的 为什么用 b+ 树</li>
<li>b+ 树为什么左右节点用指针连接 我：b 树没有左右指针需要中序遍历 面试官：什么时候需要中序遍历</li>
<li>为什么二级索引存主键 ID 不直接存数据位置</li>
<li>sql 语句怎么执行的，比如 select</li>
<li>索引覆盖是什么</li>
<li>tcp 如何建立连接</li>
<li>为什么三次握手 第二次握手后没有回复会怎么样 重发 会一直重发吗，我：有一定次数（不确定）</li>
<li>tcp 怎么保证可靠性</li>
<li>拥塞控制的详细过程 在现代网络环境中，拥塞控制有什么问题</li>
<li>设计可靠 udp</li>
<li>如何判断一个字符串是否合法，括号配对问题，如 (() 非法<ul>
<li>时间复杂度 空间复杂度（我用栈 O(n)）</li>
<li>空间复杂度优化（用变量计数） </li>
<li>如果 * 可以代表 ( 或者 ) 或者空怎么做 <a href="https://leetcode-cn.com/problems/valid-parenthesis-string/" target="_blank" rel="noopener">原题链接</a></li>
</ul>
</li>
</ul>
<h2 id="一面-2020-2-3"><a href="#一面-2020-2-3" class="headerlink" title="一面 2020/2/3"></a>一面 2020/2/3</h2><p>哦，面完才知道，我重来了一次，这又是一面。小哥哥挺年轻的人也挺好的。</p>
<ul>
<li>介绍自己在项目里做了啥</li>
<li>分布式锁</li>
<li>面向对象的特性 多态怎么实现的</li>
<li>三次握手的过程，为什么需要第三次</li>
<li>滑动窗口是什么，干什么用的</li>
<li>tcp 和 udp 的区别</li>
<li>mysql 数据库事务的隔离级别</li>
<li>事务隔离级别的实现</li>
<li>mysql 有哪些锁，如何加锁</li>
<li>单例模式代码实现，还有其他方式吗。 静态内部类，枚举</li>
<li>找出链表的第一个公共节点</li>
<li>二叉树的公共祖先 <ul>
<li>不用递归怎么做</li>
<li>面试官提示：找到根节点到目标结点的路径（与剑指 offer 同思路）</li>
<li>找到两条路径后转化为找链表第一个公共节点，写出找路径的代码</li>
</ul>
</li>
</ul>
<h2 id="二面-2020-2-3"><a href="#二面-2020-2-3" class="headerlink" title="二面 2020/2/3"></a>二面 2020/2/3</h2><ul>
<li>上来就是算法题，还是我没做过的（只会剑指 Offer 的菜鸡），只能想出暴力解法，最后思路稍微接近了点答案，然后在面试官的提示下，死活想不出最优解。</li>
<li>二叉树中和为某一值的路径。巴拉巴拉写完了，面试官问，为什么最后要 removeLast</li>
<li>http 协议是怎么样的</li>
<li>get 和 post 的区别</li>
<li>cookie 和 session，session 在多台不同服务器怎么办</li>
<li>数据库的主键索引和普通索引的区别，哪个查询更快</li>
<li>索引是越多越好吗，索引建多了会有什么问题，对什么操作有影响</li>
<li>问我 passport 的项目，叫我说几个接口的实现，用户登录后，业务调 api 怎么判断用户是否登录。哦凑，每天光看基础什么业务都忘干净了</li>
</ul>
<h2 id="三面-20202-5"><a href="#三面-20202-5" class="headerlink" title="三面 20202/5"></a>三面 20202/5</h2><ul>
<li>项目介绍 分布式锁</li>
<li>分布式锁除了 redis 还有其他实现吗，我说有数据库和 zookeeper，说了数据库的实现，zk 不了解</li>
<li>团队之间如何分工</li>
<li>题目1：链表奇数位升序，偶数位降序，如何改为有序链表</li>
<li>题目二：百万的数据，找出最大的 100 个<ul>
<li>用最小堆</li>
<li>如果这 100 万个数据都是 0-100 之间的有什么其他办法，用一个大小为 100 的哈希结构存储数据</li>
<li>如果数据是 100 亿，大到内存存不下怎么办，我说就分次读取</li>
</ul>
</li>
<li>redis 有哪些数据结构</li>
<li>redis 的有序列表怎么实现</li>
<li>跳表有什么优势，比如和二叉树比较</li>
<li>mysql 用的是什么数据结构存储</li>
<li>b+ 树是什么样的，b 树和 b+ 树的区别，为什么用 b+ 不用 b 树</li>
<li>题目三：有一个函数 random(5) 产生随机数 0-5，如何用它来实现 random(7)<ul>
<li>产生随机数的概率得是均匀的</li>
<li>leetcode <a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7" target="_blank" rel="noopener">random 7 实现 random 10</a></li>
</ul>
</li>
<li>场景设计题：抖音点赞，QPS 是百万级，如何设计<ul>
<li>用 redis 做缓存</li>
<li>数据最终写到哪：数据库</li>
<li>怎么写：定期写入</li>
<li>有没有不一致问题：机器出问题数据丢了就可能不一致吧</li>
<li>怎么解决：redis 的持久存储 rdb 和 aof</li>
<li>磁盘出问题怎么办，rdb 和 aof 都有问题：redis 集群，用多台 redis 保证高可用</li>
<li>redis 集群怎么设计的：一台写其他读</li>
</ul>
</li>
</ul>
<h1 id="小米-2020-2-27"><a href="#小米-2020-2-27" class="headerlink" title="小米 2020/2/27"></a>小米 2020/2/27</h1><ul>
<li>介绍项目</li>
<li>rocketmq 的架构</li>
<li>brocker 是集群的吗 slave 挂掉怎么办 consumer 从哪里得到消息</li>
<li>下游 消费了 consumer 后挂掉怎么办，执行了操作但是没有返回通知</li>
<li>下游 A B C 中其中一个挂掉其他成功了怎么办<ul>
<li>通过定时任务系统创建延时回滚任务，如果其中一个下游未完成，则创建回滚任务发送给其他系统。</li>
</ul>
</li>
<li>介绍设计模式</li>
<li>分布式锁 锁过期 锁误删 锁超时之类的</li>
<li>数据库有哪些锁</li>
<li>delete from id &lt;= 1000 和 select 出所有要删除的 id 后传给 delete 去删除哪个更快，id是主键</li>
<li>数据量大的时候数据库分页操作有什么问题，怎么优化</li>
<li>数据库事务的隔离级别</li>
<li>可重复读是指什么 可重复读的实现</li>
<li>数据库有哪些引擎，InnoDB 和 MyISAM 的区别，聚簇索引和非聚簇索引的区别</li>
<li>spring 的核心思想是什么，依赖注入解决了什么问题，类 A 依赖 B，B 依赖 C，C 依赖 A的时候怎么加载（循环依赖问题）</li>
<li>HashMap 的实现</li>
<li>ConcurrentHashMap 的实现</li>
<li>介绍多线程</li>
<li>分层打印二叉树</li>
</ul>
<h1 id="祖龙娱乐-2020-3-2"><a href="#祖龙娱乐-2020-3-2" class="headerlink" title="祖龙娱乐 2020/3/2"></a>祖龙娱乐 2020/3/2</h1><ul>
<li>事务消息的作用</li>
<li>Java 接口和类和抽象类的区别</li>
<li>Java 有哪些集合。HashMap 怎么实现</li>
<li>MySQL 事务隔离级别，可重复读的实现，MVCC 实现原理，多版本的数据存放在哪里</li>
<li>Spring 有什么特性，依赖注入的实现，假如有两个类都被依赖注入了，Spring 里面会 new 几个类</li>
<li>设计一个缓存池（队列），最多存储 10000 个数据，每个数据存活时间 30 分钟，过期则丢弃，实现 push 和 pull 方法。</li>
<li>有一个对象数组对应一个权重数组，随机取出最大的 10 个元素，权重越大取到的概率越高，但是权重低的也有被取到的可能性</li>
</ul>
<h1 id="字节跳动-3-5"><a href="#字节跳动-3-5" class="headerlink" title="字节跳动 3/5"></a>字节跳动 3/5</h1><ul>
<li>分布式锁是锁住一部分还是整个系统，既然是锁住整个，为什么不用消息队列</li>
<li>详细讲下怎么用 mq 实现的最终一致性，还有怎么利用的消息事务</li>
<li>hashmap 的结构，讲到一半，不用讲了，你来写一下它的 put 方法吧，不考虑扩容，简单写下。。</li>
<li>Array 和 ArrayList 的区别</li>
<li>tcp 于 http 的关系，如何基于 tcp 实现 http</li>
<li>java 打开一个 http 流不关闭的后果 <a href="http://tacy.github.io/post/java-http-connect-unclose/" target="_blank" rel="noopener">http://tacy.github.io/post/java-http-connect-unclose/</a></li>
<li>io 流是基于抽象类还是接口实现的</li>
<li>数据库的乐观锁和悲观锁是什么</li>
<li>乐观锁实现原理，讲到一半，来写一个乐观锁吧</li>
<li>java 的类中有什么方法</li>
<li>线程安全是什么</li>
<li>voliate 和 synchorized 的区别</li>
<li>假如有一个类 A 和一个 类 B，这两个类都有一个变量和一个自增操作，A 类的变量用 voliate 修饰，B 类没有，B 类的自增操作用 synchorized 修饰，他们都是线程安全的吗，如果都是，那为什么要用 synchorized ，voliate 不是更轻量吗，synchorized 有什么作用。</li>
<li>8 个 CPU ，4 个线程，16个线程什么的。。问题我忘了，因为我不懂</li>
<li>最后提问环节，我。。有什么学习的建议吗，怎么学习。面试官答：看官方文档不要看博客看源码。好的。。</li>
</ul>
<h1 id="阿里-支付宝-3-6"><a href="#阿里-支付宝-3-6" class="headerlink" title="阿里 支付宝 3/6"></a>阿里 支付宝 3/6</h1><p>阿里的面试官真是一如既往的人好，去年我印象中也是阿里的面试官态度最好。<br>其实我觉得我的表现其实很一般，还是比较差的那种，但是他说，其实我的表现还是挺优秀的，作为一个还没毕业的应届生。然后因为他们要招的是实习生，就是21届的，所以我的情况比较特殊，但是他会跟同事讨论的，最后说虽然这次也许没有机会但是我可以加他微信，以后社招会考虑我的。</p>
<ul>
<li>介绍项目</li>
<li>为什么使用消息队列，已经使用了 dubbo 了为什么还要使用 MQ</li>
<li>使用模板方法模式重构有什么好处</li>
<li>还知道哪些设计模式</li>
<li>乐观锁和悲观锁 使用场景</li>
<li>用 redis 实现乐观锁</li>
<li>从 passport 这个系统中，做了哪些有挑战性的事，亮点</li>
<li>如何防止恶意用户的攻击 限流</li>
<li>使用什么方式限流</li>
<li>使用 redis 限流的话，redis 可能就扛不住了，在 redis 集群里如果有一台机器挂掉会出现什么问题</li>
<li>线程和进程</li>
<li>synchorized 关键字作用</li>
<li>喜欢技术吗 想往什么技术深入发展</li>
<li>想去哪个城市 为什么要离职</li>
<li>问了下建议：对工作经历描述的不够流畅，沟通表达能力有待提高，对工作内容没有介绍出挑战点与亮点让他没有找到发问的地方</li>
</ul>
<h1 id="Shopee"><a href="#Shopee" class="headerlink" title="Shopee"></a>Shopee</h1><h2 id="一面-3-11"><a href="#一面-3-11" class="headerlink" title="一面 3/11"></a>一面 3/11</h2><ul>
<li>ArrayList 和 LinkedList 区别，使用场景</li>
<li>堆是什么，数据结构，时间复杂度</li>
<li>排序算法有哪些，归并排序时间复杂度，是不是稳定的</li>
<li>Map 有几种，LinkedHashMap 的数据结构，怎么实现的</li>
<li>数据库三大范式 有哪些反范式的设计</li>
<li>join 和 left join、right join 的区别</li>
<li>数据库事务 什么是持久性 隔离级别 幻读是什么</li>
<li>进程和线程的区别</li>
<li>线程同步</li>
<li>页面置换算法有哪些 LRU 和 LFU 分别是什么意思</li>
<li>TCP 和 UDP </li>
<li>TCP 怎么保证可靠性</li>
<li>拥塞控制是什么</li>
<li>三次握手 </li>
<li>HTTP 状态码有哪些</li>
<li>GET POST 区别 他们系统里有些 GET 请求 用了 POST 为什么</li>
<li>乐观锁和悲观锁  CAS 的过程</li>
<li>Redis 分布式锁使用在了什么地方 怎么实现的 除了 Redis 还有什么方式可以实现</li>
</ul>
<h2 id="二面-3-19"><a href="#二面-3-19" class="headerlink" title="二面 3/19"></a>二面 3/19</h2><ul>
<li>介绍项目</li>
<li>介绍自己做了哪些</li>
<li>springboot 和 dubbo 特点</li>
<li>用什么做的服务发现 zookeeper，zookeeper 内部原理</li>
<li>用什么实现的负载均衡 知道哪些负载均衡算法</li>
<li>不同消息队列的特点选型</li>
<li>rocketmq brocker 内部进程</li>
<li>kafka 的IO模型，多进程</li>
<li>redis 集群怎么做的</li>
<li>redis 单点故障怎么办 还有什么保证可靠性的方法</li>
<li>rocketmq 在使用过程中遇到了什么问题</li>
<li>自己的职业规划</li>
<li>对 shopee 的了解</li>
</ul>
<h1 id="中邮消费金融-3-16"><a href="#中邮消费金融-3-16" class="headerlink" title="中邮消费金融 3/16"></a>中邮消费金融 3/16</h1><h2 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h2><ul>
<li>什么是高内聚低耦合</li>
<li>讲一下设计模式</li>
<li>讲一下 Java 虚拟机 </li>
<li>讲一下堆的结构</li>
</ul>
<h2 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h2><ul>
<li>消息队列如何保证读取时候的性能</li>
<li>消息队列什么时机得到消息有没有被消费</li>
<li>常用数据结构，数组会用在项目的什么地方</li>
<li>多线程出现什么问题 怎么解决</li>
<li>乐观锁和悲观锁</li>
</ul>
<h1 id="百度-3-24"><a href="#百度-3-24" class="headerlink" title="百度 3/24"></a>百度 3/24</h1><ul>
<li><p>介绍项目</p>
</li>
<li><p>OOM 怎么定位问题</p>
</li>
<li><p>内部类编译成 .class 文件以后是怎么体现的</p>
</li>
<li><p>如何使 final 修饰的变量可修改</p>
</li>
<li><p>Java 里面使用精度很高数字的用什么类</p>
</li>
<li><p>对一个自定义的类创建 HashMap 有什么要注意的（重写 hashCode 和 equals 方法）</p>
</li>
<li><p>线程并发的处理方法</p>
</li>
<li><p>awk 的作用 </p>
</li>
<li><p>linux 如何查看 cpu 使用量</p>
</li>
<li><p>将一个数组去重后排序打印输出</p>
</li>
</ul>
<h1 id="途游-3-27"><a href="#途游-3-27" class="headerlink" title="途游 3/27"></a>途游 3/27</h1><h1 id="中信银行-3-30"><a href="#中信银行-3-30" class="headerlink" title="中信银行 3/30"></a>中信银行 3/30</h1><h1 id="字节跳动-1"><a href="#字节跳动-1" class="headerlink" title="字节跳动"></a>字节跳动</h1><h2 id="一面-4-12"><a href="#一面-4-12" class="headerlink" title="一面 4/12"></a>一面 4/12</h2><ul>
<li>介绍了下重构支付订单的东西，订单的状态机</li>
<li>ip 协议，DNS 寻址过程</li>
<li>https加密过程</li>
<li>死锁怎么形成，java 代码里死锁的解决</li>
<li>线程同步 （我说了操作系统的 java 的）那php里怎么实现（php？单线程呀。。）那多进程呢，怎么同步（不。。不了解，写php的我对线程进程一无所知）</li>
<li>三次握手四次挥手的作用</li>
<li>算法 旋转数组的最小数字</li>
<li>线程和进程的区别 为什么进程切换慢</li>
</ul>
<h2 id="二面-4-12"><a href="#二面-4-12" class="headerlink" title="二面 4/12"></a>二面 4/12</h2><ul>
<li>问项目中消息队列的使用<ul>
<li>我做的是生产者这边还是消费者这边</li>
<li>什么是最大努力通知</li>
<li>如何保证投递可靠（事务消息，半消息）</li>
<li>下游消费失败怎么办</li>
<li>消息重复投递怎么办</li>
<li>消息id存在哪里，消息里吗</li>
</ul>
</li>
<li>分布式事务除了消息队列还有什么解决办法<ul>
<li>我说分布式锁，叫我讲个场景，然后说如果是两个数据库，从一个数据库里减金额，另一个数据库里加金额，怎么办</li>
<li>好不容易想起了2pc，讲2pc，然后面试官提出2pc的问题，投票完成后其中一个参与者失败怎么办 （这里当初理解的不透彻，忘了，就扯 3pc，扯又没扯明白，面试官问我回答他问题了吗，很是尴尬）</li>
</ul>
</li>
<li>看我项目有个redisson，他说他不太懂这个redisson，给他讲讲（你不懂，骗鬼吧）<ul>
<li>如果有个线程执行时间过长超过了设置的超时时间被释放了怎么办</li>
</ul>
</li>
<li>对微服务治理架构的了解（Dobble Zookeeper）</li>
<li>TIME-WAIT 发生在哪个阶段<ul>
<li>为什么等待 2 MSL</li>
<li>2MSL 大概是多久，现实中的时间（秒？毫秒，布吉岛）</li>
<li>正常上网请求网页的时候，进入 TIME-WAIT 的是服务器还是客户端（指网页请求的那个服务器，主动关闭连接的一方会进入 TIME-WAIT，一般是服务器主动关闭连接）。那他等待的 2MSL 对他性能有没有影响（emm，时间久就有影响吧）问题又回到了多久，布吉岛。。</li>
</ul>
</li>
<li>id 生成器怎么做 数据库分表</li>
<li>聚簇索引和非聚簇索引的区别 一个表里可以有几个聚簇索引</li>
<li>幻读是什么 mysql 怎么解决（我答临键锁，面试官问我刚才提到的mvcc是否可以解决）</li>
<li>设计一个加权随机算法（思考加修修改改搞了好几十分钟，面试官也亏他有耐心）</li>
</ul>
<h2 id="三面-4-14"><a href="#三面-4-14" class="headerlink" title="三面 4/14"></a>三面 4/14</h2><p>面试官态度非常好，没有压迫感</p>
<ul>
<li>问我有其他offer没</li>
<li>设计一个String 转 Int 的方法，做成一个基础库<ul>
<li>判断负数、字符串、溢出</li>
<li>我用的是<code>res &gt; Integer.MAX_VALUE / 10 || res == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; 7</code>这种方式判断溢出，他问我有没有更优雅的其他方法，比如我这个为什么要判断最后一个字符，这个Integer.MAX_VALUE不就是最大数吗，我脑子抽了下，说那就直接加起来判断吧，我想复杂了，他说那要是加的时候就溢出了呢，我。。。那。。那还是就我那样判断吧。。</li>
<li>为什么我一开始写的是抛异常，后来改成了return 0；我，运行的时候报错了，懒得改，反正觉得return 0也没啥问题，面试官：那要是人家就传 0 呢，我，那，那还是抛异常吧。</li>
</ul>
</li>
<li>TCP/IP是哪四层</li>
<li>ip 和 mac 什么关系，<ul>
<li>为什么要有 ip</li>
<li>mac不可以划分子网吗</li>
<li>mac 属于哪一层</li>
<li>ip 属于哪一层</li>
<li>端口属于哪一层</li>
<li>端口的作用</li>
<li>多个进程可以监听同一个端口吗</li>
</ul>
</li>
<li>sleep() 是什么<ul>
<li>sleep 是怎么实现的，我说运行态变阻塞态</li>
<li>这个状态的转换是中断吗，一番思考，我猜是吧，他问我这么猜的理由，我就念了遍中断的定义，说看起来是符合sleep的</li>
<li>sleep 里面有个休眠时间，是如何实现的，怎么做到到了时间就唤醒。瞎逼逼了两下，不知道，就说linux有个crontab，内部啥原理，不懂</li>
</ul>
</li>
<li>实习的收获</li>
<li>redis 的原理是怎么学习的，看了源码吗。我说看书，redis 设计与实现。为什么要学习呢，为什么要学这个redis 的原理</li>
<li>面试就到这里，有啥想问的，我又开始emm（回答每个问题的我都这个状态），他赶紧说，没啥想问的可以不问，emm，那，那没了。</li>
</ul>
<h1 id="Boss直聘"><a href="#Boss直聘" class="headerlink" title="Boss直聘"></a>Boss直聘</h1><h2 id="一面-4-21"><a href="#一面-4-21" class="headerlink" title="一面 4/21"></a>一面 4/21</h2><ul>
<li>static 修饰的代码块，执行顺序</li>
<li>final 修饰的基本类型，在 lambada 表达式里面能不能更改</li>
<li>Java 有哪些锁 synchronized 是哪种锁，可重入锁的意思</li>
<li>公平锁和非公平锁的区别</li>
<li>进程与线程的区别</li>
<li>Java 线程的状态</li>
<li>数据库索引的数据结构</li>
<li>Java 基本类型的大小</li>
<li>十亿个手机号里面，怎么找到一个手机号存不存在，用什么样的数据结构</li>
<li>求一个数由哪些完全平方数构成</li>
<li>怎么平衡工作与学习的时间</li>
</ul>
<h2 id="二面-4-30"><a href="#二面-4-30" class="headerlink" title="二面 4/30"></a>二面 4/30</h2><ul>
<li>java 集合体系</li>
<li>hashset 有一个user类要存入 hashset 需要做什么</li>
<li>安全的 hashset</li>
<li>long access(String ip) 得到ip返回次数 并发环境下</li>
<li>浏览器输入网址过程</li>
<li>cookie session</li>
<li>乐观锁 悲观锁</li>
<li>http 响应字段</li>
<li>数据库 索引 更新数据主键，唯一，普通的区别</li>
<li>线程池参数</li>
<li>redis 数据结构 hash使用场景</li>
</ul>
<h1 id="字节跳动广告部门-4-21"><a href="#字节跳动广告部门-4-21" class="headerlink" title="字节跳动广告部门 4/21"></a>字节跳动广告部门 4/21</h1><ul>
<li>Java 有哪些集合类</li>
<li>Array list 和linked list 扩容</li>
<li>Hashmap怎么插入，扩容</li>
<li>conrruent hashmap Hashset</li>
<li>数据结构有哪些线程结构，非线性结构</li>
<li>二叉树有哪几种 二三树？红黑树 b树 b+树</li>
<li>Java有哪些锁 实现原理</li>
<li>Wait与sleep </li>
<li>Cas是什么 是操作系统的指令吗</li>
<li>线程状态</li>
<li>Jvm内存结构</li>
<li>垃圾回收</li>
<li>Aop ioc 怎么实现的</li>
<li>Maven生命周期</li>
<li>Bean factory 和factory bean</li>
<li>Springboot与springmvc</li>
<li>800万条数据，优化查询</li>
<li>缓存雪崩</li>
<li>大数据有了解么</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liuyuqi21.github.io/2020/01/20/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/" data-id="ckd5czhip0042nnnrezpefewl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag">面经</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA 集合框架" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/19/JAVA%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" class="article-date">
  <time datetime="2020-01-19T07:17:43.000Z" itemprop="datePublished">2020-01-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/19/JAVA%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">Java 集合框架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>容器主要包括 Collection 和 Map 两种，Collection 存储对象的集合，而 Map 存储键值对的映射表。</p>
<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p><img src="https://gitee.com/cellophane/image/raw/master/20200412000220.png" alt=""></p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul>
<li>TreeSet：基于红黑树实现，<strong>保证元素的自然顺序</strong>，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li>
<li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li>
<li>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的<strong>插入顺序</strong>。</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>基于动态数组，实现了 list，RandomAccess（支持快速随机访问），Cloneable（能被克隆），java.io.Serializeable（支持序列化） 接口。不支持线程安全，多线程可以使用 CopyOnWriteArrayList 或者使用 <code>Collections.synchronizedList();</code>。</p>
<ul>
<li>扩容：数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的 1.5 倍。</li>
<li>删除元素：将 index + 1 后面的元素都复制到 index 位置上，时间复杂度为O(N)。</li>
<li>Fail-Fast：modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。</li>
<li>asList()： 参数是泛型的变长参数，不能使用基本类型数组作为参数，只能使用响应的包装类型数组，或者 <code>List list = Arrays.asList(1, 2, 3);</code>。asList() 产生的列表不可变。</li>
</ul>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>是一个实现了 List 和 Deque 的双向链表，只能顺序访问，但是可以快速地在链表中间插入和删除元素。</p>
<p>不是线程安全的，要想实现线程安全，可以调用 Collections 类中的 synchorizedList 方法。</p>
<pre class="line-numbers language-java"><code class="language-java">List list <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">synchorizedList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><ul>
<li>和 ArrayList 类似，但它是线程安全的，使用 synchorized 进行同步。</li>
<li>Vector 每次扩容请求其大小的 2 倍（可以通过构造函数设置增长的容量）。</li>
</ul>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>读写分离：写操作再一个复制的数组上进行，读操作还是在原始数组中进行。写操作需要加锁，防止并发写入时导致数据丢失。写操作结束之后需要把原始数组指向新的复制数组。</p>
<p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，适合读多写少的场景。</p>
<p>缺陷：</p>
<ul>
<li>内存占用：写操作时需要复制一个新的数组，内存占用为原来的两倍左右</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写擦偶哦的数据还未同步到读数组中</li>
</ul>
<p>不适合内存敏感以及实时性要求很高的场景。</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><ul>
<li>LinkedList：可以用它来实现双向队列。</li>
<li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</li>
<li>add/offer 将元素添加到队尾（add 添加元素失败时 throw Exception，offer 返回 false 或 null）</li>
<li>remove/poll 从队首获取元素并删除</li>
<li>element/peek 从队首获取元素但不删除</li>
</ul>
<p>Queue 是个接口，它提供的 add, offer 方法初衷是希望子类能够禁止添加元素为 null，这样可以避免在查询时返回 null 究竟是正确还是错误。<br>事实上大多数 Queue 的实现类的确响应了 Queue 接口的规定，比如 ArrayBlockingQueue，PriorityBlockingQueue 等等。<br>但还是有一些实现类没有这样要求，比如 LinkedList。<br>虽然 LinkedList 没有禁止添加 null，但是一般情况下 Queue 的实现类都不允许添加 null 元素，为啥呢？因为 poll(), peek() 方法在异常的时候会返回 null，你添加了 null　以后，当获取时不好分辨究竟是否正确返回。<br>add() 方法在添加失败（比如队列已满）时会报 一些运行时错误 错；而 offer() 方法即使在添加失败时也不会奔溃，只会返回 false。</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><img src="https://gitee.com/cellophane/image/raw/master/20200412000235.png" alt=""></p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>底层数据结构是数组加链表。默认容量是 16。</p>
<p>从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树。</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>HashMap 中的哈希桶数组是 Node[] table，是一个 Node 数组。Node 是 HashMap 的一个内部类，实现了 Map.Entry 接口，本质是一个映射（键值对）。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//用来定位数组索引位置</span>
    <span class="token keyword">final</span> K key<span class="token punctuation">;</span>
    V value<span class="token punctuation">;</span>
    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//链表的下一个node</span>

    <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">setValue</span><span class="token punctuation">(</span>V newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>新来的 Entry 节点插入链表时，JDK 1.7 之前使用头插法、JDK 1.8 使用尾插法。</p>
<p>HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null。但是无法调用 null 的 hashCode() 方法。所以使用第 0 个桶存放 null 的键值对。</p>
<h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><p>resize 方法负责初始化和扩容，衡量 HashMap 是否进行 Resize 的条件 <code>HashMap.Size &gt;= Capacity * LoadFactor</code></p>
<ul>
<li>扩容：创建一个新的 Entry 空数组，长度是原数组的 2 倍。</li>
<li>ReHash：遍历原 Entry 数组，把所有的 Entry 重新 Hash 到新数组。因为长度扩大后，Hash 规则也随之改变。</li>
</ul>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>如果通过 <code>key.hashCode()</code> 函数调用 key 键值类型自带的哈希函数，返回 int 型散列值。如果直接拿散列值作为下标访问 HashMap 主数组的话，考虑到 2 二进制 32 位带符号的 int 表值范围从 -2147483648 到 2147483648。前后加起来大概 40 亿的映射空间。但问题是一个 40 亿长度得数组，内存是放不下的。所以用之前还要先对数组得长度取模运算，得到的余数用来访问数组下标。这个取模运算在 <code>indexFor()</code> 函数里完成。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span><span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>Hash 公式：<code>index = HashCode(key) &amp; (Length - 1)</code> 使用位运算方式而不采用取模，提高了性能。</p>
<pre class="line-numbers language-none"><code class="language-none">x   : 00010000
x-1 : 00001111

y       : 10110010
x-1     : 00001111
y&(x-1) : 00000010 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>令一个数 y 与 x-1 做与运算，得到的结果就是截取了 y 的最低四位值，这个效果和 y 对 x 取模是一样的。</p>
<p>桶的数量，总容量默认值是 16，只有保证 capacity 为 <strong>2 的 n 次方</strong>，才能将这个操作转换为位运算。</p>
<ul>
<li>HashMap 允许用户传入的容量不是 2 的 n 次方，它可以自动的将传入的容量转换成 2 的 n 次方。</li>
</ul>
<h4 id="扰动函数"><a href="#扰动函数" class="headerlink" title="扰动函数"></a>扰动函数</h4><p>但是就算散列值分布再松散，只是取最后几位的话，碰撞也会很严重，所以需要扰动函数。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//jdk1.8 &amp; jdk1.7</span>
     <span class="token keyword">int</span> h<span class="token punctuation">;</span>
     <span class="token comment" spellcheck="true">// h = key.hashCode() 为第一步 取hashCode值</span>
     <span class="token comment" spellcheck="true">// h ^ (h >>> 16)  为第二步 高位参与运算</span>
     <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个过程参考下图</p>
<p><img src="https://gitee.com/cellophane/image/raw/master/4acf898694b8fb53498542dc0c5f765a_720w.jpg" alt=""></p>
<p>右位移 16 位，正好是 32 bit 的一半。自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来<strong>加大低位的随机性</strong>。</p>
<h3 id="负载系数（load-factor）"><a href="#负载系数（load-factor）" class="headerlink" title="负载系数（load factor）"></a>负载系数（load factor）</h3><ul>
<li>建议不要设置超过 0.75 的数值，因为会显著增加冲突</li>
<li>如果使用太小的负载因子，按照上面的公式，预设容量值也进行调整，否则可能会导致更加频繁的扩容。</li>
</ul>
<h3 id="高并发情况下，为什么-HashMap-可能会出现死循环"><a href="#高并发情况下，为什么-HashMap-可能会出现死循环" class="headerlink" title="高并发情况下，为什么 HashMap 可能会出现死循环"></a>高并发情况下，为什么 HashMap 可能会出现死循环</h3><p><a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">疫苗：JAVA HASHMAP的死循环</a><br>使用头插会改变链表的上的顺序，但是如果使用尾插，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。所以 Java 8 不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系。</p>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>HashTable 是线程安全的，使用 synchronized 来进行同步，不允许插入为 null 的键，但是它是遗留类不推荐使用。</p>
<p>与 HashMap 的比较：</p>
<ul>
<li>Hashtable 使用 synchronized 来进行同步。</li>
<li>HashMap 可以插入键为 null 的 Entry。</li>
<li>HashMap 的迭代器是 fail-fast 迭代器。</li>
<li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li>
</ul>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>ConcurrentHashMap 不允许键值中出现 null。</p>
<h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。多线程可以同时访问不同分段锁上的桶，从而使并发度更高。默认的并发级别为 16，默认创建 16 个 Segment。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Segment</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 2249069246763182397L<span class="token punctuation">;</span>    

    <span class="token keyword">transient</span> <span class="token keyword">volatile</span> HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶     </span>
    <span class="token keyword">transient</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>          
    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 记得快速失败（fail—fast）么？         </span>
    <span class="token keyword">transient</span> <span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 大小         </span>
    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 负载因子 </span>
    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="size-操作"><a href="#size-操作" class="headerlink" title="size 操作"></a>size 操作</h3><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中及键值对个数。在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p>
<p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果是一致的，那么可以认为这个结果是正确的。尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p>
<h3 id="JDK-1-8-的改动"><a href="#JDK-1-8-的改动" class="headerlink" title="JDK 1.8 的改动"></a>JDK 1.8 的改动</h3><p>JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。</p>
<p>并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。</p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>继承自 HashMap，内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</p>
<p>accessOrder 决定顺序，false 为插入顺序，true 为 LRU，默认为 fasle。</p>
<h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>在 put() 等操作执行之后，会执行 afterNodeInsertion() 方法，removeEldestEntry() 为 true 时会移除最晚的节点。方法，removeEldestEntry() 默认为 fasle，如果要让他为 true，需要继承 LinkhashMap 并且覆盖这个方法的实现。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_ENTRIES <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置最大缓存空间</span>

<span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry eldest<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> MAX_ENTRIES<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//在节点多于 MAX_ENTRIES 时移除最近最久未使用数据</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>基于红黑树实现</p>
<h1 id="容器中的设计模式"><a href="#容器中的设计模式" class="headerlink" title="容器中的设计模式"></a>容器中的设计模式</h1><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p>
<p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>java.util.Arrays#asList() 可以把数组类型转换为 List 类型。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/LinkedList.md" target="_blank" rel="noopener">Java Guide LinkedList</a></p>
</li>
<li><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList.md" target="_blank" rel="noopener">Java Guide ArrayList</a></p>
</li>
<li><p><a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%AE%B9%E5%99%A8" target="_blank" rel="noopener">CS-Notes Java 容器</a></p>
</li>
<li><p><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a></p>
</li>
<li><p><a href="https://www.zhihu.com/question/20733617/answer/111577937" target="_blank" rel="noopener">JDK 源码中 HashMap 的 hash 方法原理是什么？ - 胖君的回答 - 知乎 </a></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liuyuqi21.github.io/2020/01/19/JAVA%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" data-id="ckd5czhhi000cnnnrcmaw8zrj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MySQL-事务-日志-锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/17/MySQL-%E4%BA%8B%E5%8A%A1-%E6%97%A5%E5%BF%97-%E9%94%81/" class="article-date">
  <time datetime="2020-01-17T10:43:41.000Z" itemprop="datePublished">2020-01-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/17/MySQL-%E4%BA%8B%E5%8A%A1-%E6%97%A5%E5%BF%97-%E9%94%81/">MySQL 事务 日志 锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>事务是<strong>并发控制的基本单位</strong>。事务要做到 <strong>可靠性</strong> 和 <strong>并发处理</strong>。</p>
<h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>要么全部都执行，要都不执行。</p>
<p>原子性通过<strong>回滚日志</strong>实现。</p>
<h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>持久化是为了能应对系统崩溃的情况。</p>
<p>当事务已经被提交之后，就无法再次回滚了，唯一能够撤回已经提交的事务的方式就是创建一个相反的事务对原操作进行『补偿』，这也是事务持久性的体现之一。</p>
<p>事务的持久性通过<strong>重做日志（Redo Log）</strong>实现。在事务提交后，数据没来得及写会磁盘就宕机时，在下次重新启动后能够成功恢复数据。</p>
<h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>一个事务在所做的修改最终提交以前，对其他事务时不可见的。</p>
<h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>所有事务对于同一个数据的读取结果都是相同的。通过原子性，持久性，隔离性来实现。</p>
<h1 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h1><ul>
<li>丢失修改：A、B 两个事务同时对一个数据进行修改，A 先修改，B 后修改，B 的修改覆盖了 A 的修改。</li>
<li>脏读：A 修改一个数据，B 读取这个数据，如果 A 撤销了修改，那么 B 读取的数据是脏数据。</li>
<li>不可重复读：B 读取一个数据，A 对该数据进行修改后提交事务，如果 B 再次读取这个数据，此时读取结果和第一次不同。（针对 update 操作）</li>
<li>幻读：A 读取某个范围内的数据，B 在这个范围内插入数据，A再次读取这个范围的数据，此时读取的结果和第一次不同。（针对的是 insert 和 delete 操作）</li>
</ul>
<p>产生并发不一致的问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>
<h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><ul>
<li>READ UNCOMMITED (未提交读)：事务中的修改，没有提交的时候对其他事务是可见的。会产生<strong>脏读</strong>。好处是提升并发处理性能，能做到<strong>读写并行</strong></li>
<li>READ COMMITED (提交读)：事务的修改在提交前对其他事务不可见。该级别会产生<strong>不可重读</strong>以及<strong>幻读</strong>问题。</li>
<li>REPEATABLE READ (可重复读)：保证同一个事务中多次读取同一数据的结果相同，可能发生<strong>幻读</strong>。</li>
<li>SERIALIZABLE (可串行化)：强制事务串行执行，多个事务互不干扰。解决了幻读的问题。</li>
</ul>
<p>以上的所有的事务隔离级别都不允许脏写入（Dirty Write），也就是当前事务更新了另一个事务已经更新但是还未提交的数据，大部分的数据库中都使用了 READ COMMITED 作为默认的事务隔离级别，但是 <strong>MySQL 使用了 REPEATABLE READ</strong> 作为默认配置。</p>
<h1 id="多版本和快照隔离（MVCC）"><a href="#多版本和快照隔离（MVCC）" class="headerlink" title="多版本和快照隔离（MVCC）"></a>多版本和快照隔离（MVCC）</h1><p>多版本并发控制是 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读。</p>
<p>在 MVCC 中事务的增删改操作会为数据行新增一个版本快照，保证事务并行执行时能够不等待互斥锁的释放直接获取数据。<br>快照存储在 <strong>Undo Log</strong> 中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。</p>
<p>InnoDB 对所有的 row 数据增加三个内部属性</p>
<ol>
<li>DB_TRX_ID 记录每一行最近一次修改它的事务 ID</li>
<li>DB_ROLL_PTR 记录指向回滚段的 undo 日志的指针</li>
<li>DB_ROW_ID 单调递增的行 ID</li>
</ol>
<h2 id="简单理解"><a href="#简单理解" class="headerlink" title="简单理解"></a>简单理解</h2><p>通过在每行记录后面保存两个隐藏的列来实现，这两个列，分别保存了这个行的创建时间，一个保存的是行的删除时间。这里存储的并不是实际的时间值,而是系统版本号(可以理解为事务的ID)。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>创建时间</th>
<th>删除时间</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>rolling stones</td>
<td>1</td>
<td>undefined</td>
</tr>
<tr>
<td>2</td>
<td>deep purple</td>
<td>1</td>
<td>undefined</td>
</tr>
<tr>
<td>3</td>
<td>dio</td>
<td>1</td>
<td>undefined</td>
</tr>
</tbody></table>
<h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><p>需要同时满足以下条件：</p>
<ol>
<li>InnoDB 只会查找版本早于当前事务版本的数据行</li>
<li>行的删除版本要么未定义，要么大于当前事务版本号（这可以确保事务读取到的行，在事务开始之前未被删除）</li>
</ol>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>InnoDB 会为删除的每一行保存当前系统的版本号(事务的 ID)作为删除标识。</p>
<h2 id="MVCC-能否解决幻读"><a href="#MVCC-能否解决幻读" class="headerlink" title="MVCC 能否解决幻读"></a>MVCC 能否解决幻读</h2><p>其实在MySQL可重复读的隔离级别中并不是完全解决了幻读的问题，而是解决了读数据情况下的幻读问题。而对于修改的操作依旧存在幻读问题，就是说MVCC对于幻读的解决时不彻底的。</p>
<p>MVCC 是对单条数据的版本进行控制，不能保证一个区间内的数据。</p>
<h1 id="隔离级别的实现"><a href="#隔离级别的实现" class="headerlink" title="隔离级别的实现"></a>隔离级别的实现</h1><h2 id="未提交读"><a href="#未提交读" class="headerlink" title="未提交读"></a>未提交读</h2><p>select 语句不加锁。</p>
<h2 id="提交读"><a href="#提交读" class="headerlink" title="提交读"></a>提交读</h2><ul>
<li>读取不加锁，是快照读。</li>
<li>增删改加锁，加锁的语句，除了在外键约束检查以及重复键检查时会封锁区间，其他时刻只使用记录锁。此时，其他事务的插入依然可以执行，就可能导致读取到幻影记录。</li>
</ul>
<h2 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h2><ul>
<li>读取使用快照读，底层用 MVCC 实现。</li>
<li>增删改加锁，加锁的语句（select … in share mode / select … for update），他们的锁，依赖于他们是否在唯一索引上使用了唯一的查询条件，或者范围查询条件。<ul>
<li>在唯一索引上使用唯一的查询条件会使用记录锁，不会使用间隙锁和临键锁。</li>
<li>范围查询条件会在记录之间加间隙锁和临键锁，索引之间的范围，避免范围间插入记录，以避免产生幻影行记录，以及避免不可重复的读。</li>
</ul>
</li>
</ul>
<h2 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h2><p>所有 select 语句被隐式转化为 select … in share mode。</p>
<p>如果有未提交的事务正在修改某些行，所有读取这些行的 select 都会被阻塞住。</p>
<h1 id="两阶段事务提交"><a href="#两阶段事务提交" class="headerlink" title="两阶段事务提交"></a>两阶段事务提交</h1><p>MySQL采用了两阶段事务提交(Two-Phase Commit Protocol)协议，当操作完成后，首先 prepare 事务，在 binlog 中实际只是 fake 一下，不做任何事情，而 innodb 层需要将 prepare 写入 redolog 中。然后执行 commit 事务，首先在 binlog 文件中写入这些操作的 binlog 日志，完成之后在 innodb 的 redolog 写入 commit 日志。</p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><table>
<thead>
<tr>
<th>undo log</th>
<th>redo log</th>
<th>binlog</th>
</tr>
</thead>
<tbody><tr>
<td>逻辑日志</td>
<td>物理日志</td>
<td>逻辑日志</td>
</tr>
</tbody></table>
<h2 id="回滚日志（Undo-Log）"><a href="#回滚日志（Undo-Log）" class="headerlink" title="回滚日志（Undo Log）"></a>回滚日志（Undo Log）</h2><p>用于实现事务的原子性，还有多版本并发控制（MVCC）。</p>
<ul>
<li>是<strong>逻辑日志</strong>，跟据回滚日志做逆向操作，比如 delete 的逆向操作为 insert，insert 的逆向操作为 delete，update 的逆向为 update 等。</li>
<li>每条数据变更 (insert/update/delete) 操作都伴随一条 undo log 的生成。</li>
</ul>
<p>回滚日志除了能够在发生错误或者用户执行 ROLLBACK 时提供回滚相关的信息，它还能够在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立刻通过查询回滚日志将之前未完成的事务进行回滚，这也就需要回滚日志必须先于数据持久化到磁盘上，是我们需要<strong>先写日志后写数据库</strong>的主要原因。</p>
<h2 id="重做日志（Redo-Log）"><a href="#重做日志（Redo-Log）" class="headerlink" title="重做日志（Redo Log）"></a>重做日志（Redo Log）</h2><p>重做日志由两部分组成。</p>
<ul>
<li>内存中的重做日志缓冲区（redo log buffer）</li>
<li>磁盘上的重做日志文件</li>
</ul>
<p>缓冲池（Buffer Pool）是为了提升性能的，缓冲池中的数据定期同步到磁盘。</p>
<p>在一个事务中尝试对数据进行修改时的过程：</p>
<ol>
<li>先将数据从磁盘读入内存，并更新内存中缓存的数据。</li>
<li>然后生成一条重做日志并写入重做日志。</li>
<li>当事务真正提交时，MySQL 会将日志缓存中的内容刷新到重做日志文件。</li>
<li>最后再将内存中的日志缓冲区数据更新到磁盘上。</li>
</ol>
<p>为了保证持久性，数据必须要晚于 redo log 写入持久存储。当<strong>系统崩溃</strong>时，系统可以根据 Redo Log 的内容，将所有数据恢复到最新的状态。</p>
<h3 id="既然-redo-log-也涉及磁盘-IO，为什么还要用？"><a href="#既然-redo-log-也涉及磁盘-IO，为什么还要用？" class="headerlink" title="既然 redo log 也涉及磁盘 IO，为什么还要用？"></a>既然 redo log 也涉及磁盘 IO，为什么还要用？</h3><ol>
<li>Redo Log 会尽量存储在一段连续的空间上，因此在系统第一次启动时就会将日志文件的空间完全分配，以<strong>顺序追加</strong>的方式记录 Redo Log，而缓存同步是<strong>随机操作</strong>。</li>
<li>缓存同步是以数据页为单位的，每次传输的数据小于 redo log。</li>
<li>批量写入日志。日志并不是直接写入文件，而是先写入日志缓冲区。当需要将日志刷新到磁盘时(如事务提交)，将许多日志一起写入磁盘。</li>
<li>重做日志都是以 512 字节的块的形式进行存储的，同时因为块的大小与磁盘扇区大小相同，所以重做日志的写入可以保证<strong>原子性</strong>，不会由于机器断电导致重做日志仅写入一半并留下脏数据。</li>
</ol>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>因为批量写入日志的原因,当一个事务将 Redo Log 写入磁盘时，也会将其他未提交的事务的日志写入磁盘。</li>
<li>Redo Log 上只进行顺序追加的操作，当一个事务需要回滚时，它的 Redo Log 记录也不会从 Redo Log 中删除掉。</li>
</ol>
<h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><p>进行恢复时，重做所有事务包括未提交的事务和回滚了的事务。然后通过 Undo Log 回滚那些提交的事务。</p>
<p>使用这种策略进行恢复就必须要在写 Redo Log 之前将对应的 Undo Log 写入磁盘。Undo 和 Redo Log 的这种关联，使得持久化变得复杂起来。为了降低复杂度，InnoDB 将 Undo Log 看作数据，因此记录 Undo Log 的操作也会记录到 Redo Log 中。这样 Undo Log 就可以像数据一样缓存起来，而不用在 Redo Log 之前写入磁盘了。</p>
<h2 id="二进制日志（binlog）"><a href="#二进制日志（binlog）" class="headerlink" title="二进制日志（binlog）"></a>二进制日志（binlog）</h2><p>binlog 是 Mysql sever 层维护的一种二进制日志，与 innodb 引擎中的 redo/undo log 是完全不同的日志。其主要是用来记录对mysql 数据更新或潜在发生更新的 SQL 语句，并以”事务”的形式保存在磁盘中。</p>
<p>作用:</p>
<ol>
<li>主从复制：MySQL Replication 在 Master 端开启 binlog，Master 把它的二进制日志传递给 slaves 并回放来达到master-slave 数据一致的目的。</li>
<li>数据恢复：通过mysqlbinlog工具恢复数据。</li>
<li>增量备份。</li>
</ol>
<h3 id="redo-log-和-binlog："><a href="#redo-log-和-binlog：" class="headerlink" title="redo log 和 binlog："></a>redo log 和 binlog：</h3><ol>
<li>作用不同：redo log 是保证事务的持久性的，是事务层面的，binlog 作为还原的功能，是数据库层面的（当然也可以精确到事务层面的），虽然都有还原的意思，但是其保护数据的层次是不一样的。</li>
<li>内容不同：redo log 是<strong>物理日志</strong>，是数据页面的修改之后的物理记录，binlog 是<strong>逻辑日志</strong>，可以简单认为记录的就是sql语句</li>
<li>另外，两者日志产生的时间，可以释放的时间，在可释放的情况下清理机制，都是完全不同的。</li>
<li>恢复数据时候的效率，基于物理日志的 redo log 恢复数据的效率要高于语句逻辑日志的 binlog。</li>
</ol>
<h1 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h1><p>show engine innodb status; 可以查看 InnoDB 的锁情况，也可以调试死锁。</p>
<h2 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h2><ul>
<li>表锁：系统性能开销最小，会锁定整张表,<strong>MyISAM</strong> 使用表锁。</li>
<li>行锁：最大程度的支持并发处理,但是也带来最大的锁开销，<strong>InnoDB</strong> 使用行级锁。</li>
</ul>
<p>为了支持多粒度锁定，InnoDB 引入了意向锁，意向锁是一种表级锁。</p>
<p>InnoDB 的行锁是实现在索引上的，而不是锁在物理行记录上，如果访问没有命中索引，也无法使用行锁，将退化为表锁。</p>
<h1 id="InnoDB-的七种锁"><a href="#InnoDB-的七种锁" class="headerlink" title="InnoDB 的七种锁"></a>InnoDB 的七种锁</h1><h2 id="共享-排他锁"><a href="#共享-排他锁" class="headerlink" title="共享/排他锁"></a>共享/排他锁</h2><ul>
<li>多个事务可以拿到一把共享锁，读读并行</li>
<li>只有一个事务可以拿到排他锁，写写/读写并行</li>
<li>读锁：共享，不堵塞 <code>select ... lock in share mode</code></li>
<li>写锁: 排他，堵塞 <code>select ... for update</code></li>
<li>InnoDB 引擎中的 update，delete，insert 语句自动加排他锁</li>
</ul>
<h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><p>意向锁是一个表级的锁。</p>
<ul>
<li>意向共享锁（IS）：事务有意向对表中的某些行加 S 锁</li>
<li>意向排他锁（IX）：事务有意向对表中的某些行加 X 锁</li>
</ul>
<pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share mode</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//要设置 IS 锁</span>
<span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> <span class="token keyword">update</span>；<span class="token comment" spellcheck="true">//要设置IX锁</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>意向锁的意义：</p>
<ol>
<li>IX，IS 是表级锁，不会和行级的 X，S 锁发生冲突。只会和表级的 X，S 发生冲突。</li>
<li>意向锁是在添加行锁之前添加。</li>
<li>如果没有意向锁，当向一个表添加表级 X 锁时，就需要遍历整张表来判断是否存行锁，以免发生冲突。</li>
<li>如果有了意向锁，只需要判断该意向锁与表级锁是否兼容即可。</li>
</ol>
<h2 id="记录锁（Record-Lock）"><a href="#记录锁（Record-Lock）" class="headerlink" title="记录锁（Record Lock）"></a>记录锁（Record Lock）</h2><p>对单条索引记录进行加锁，锁住的是索引记录而非记录本身，即使表中没有任何索引，MySQL会自动创建一个隐式的row_id作为聚集索引来进行加锁。</p>
<pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>它会在 <code>id = 1</code> 的索引上加锁，以防止其他事务插入、更新、删除 id = 1 的这一行。</p>
<h2 id="间隙锁（GAP-Lock）"><a href="#间隙锁（GAP-Lock）" class="headerlink" title="间隙锁（GAP Lock）"></a>间隙锁（GAP Lock）</h2><p>封锁索引记录中的间隔，如</p>
<pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> id <span class="token operator">between</span> <span class="token number">8</span> <span class="token operator">and</span> <span class="token number">15</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>会封锁区间，阻止其他事务在 8-15 之间插入。</p>
<h2 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h2><p>是间隙锁的一种，所以也是实施在索引上的，专门针对 insert 操作。</p>
<p>多个事务，在同一个索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此。</p>
<h2 id="临键锁（Next-key-Lock）"><a href="#临键锁（Next-key-Lock）" class="headerlink" title="临键锁（Next-key Lock）"></a>临键锁（Next-key Lock）</h2><p>临键锁是记录锁与间隙锁的组合，会封锁索引记录本身以及索引记录之前的区间。</p>
<p>目的是为了避免幻读，如果把事务的隔离级别降级为提交读，临键锁会失效。</p>
<h2 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h2><p>是一种表级别的锁，专门针对事务插入 AUTO_INCREAMENT 类型的列。如果一个事务正在往表中插入记录，所有其他事务必须等待，一边第一个事务插入的行，是连续的主键值。</p>
<h1 id="并发控制机制（乐观锁和悲观锁）"><a href="#并发控制机制（乐观锁和悲观锁）" class="headerlink" title="并发控制机制（乐观锁和悲观锁）"></a>并发控制机制（乐观锁和悲观锁）</h1><ul>
<li>悲观锁：共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源转让给其他线程。传统关系型数据库里边就用到了很多这种锁机制，行锁表锁读锁写锁，都是在操作前先上锁。</li>
<li>乐观锁：在更新时判断在此期间别人有没有去更新这个数据，可以使用<strong>版本号机制和 CAS 算法</strong>实现。乐观锁适用于<strong>多读</strong>的应用类型，这样可以提供吞吐量。</li>
</ul>
<h2 id="乐观锁实现方式一：版本号机制"><a href="#乐观锁实现方式一：版本号机制" class="headerlink" title="乐观锁实现方式一：版本号机制"></a>乐观锁实现方式一：版本号机制</h2><p>一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数，当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</p>
<pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> name<span class="token punctuation">,</span> version <span class="token keyword">from</span> goods <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token comment" spellcheck="true">#{id};</span>
<span class="token keyword">update</span> goods <span class="token keyword">set</span> name <span class="token operator">=</span> <span class="token comment" spellcheck="true">#{name}, version = version + 1;</span>
<span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token comment" spellcheck="true">#{id} and version = #{version};</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="乐观锁实现方式二：CAS-算法"><a href="#乐观锁实现方式二：CAS-算法" class="headerlink" title="乐观锁实现方式二：CAS 算法"></a>乐观锁实现方式二：CAS 算法</h2><p>即<strong>compare and swap（比较与交换）</strong>，是一种有名的<strong>无锁算法</strong>。<br>CAS 算法涉及到三个操作数：</p>
<ul>
<li>需要读写的内存值 V</li>
<li>进行比较的值 A</li>
<li>拟写入的新值 B<br>当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</li>
</ul>
<h2 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h2><ul>
<li>ABA 问题：不能保证一个值 A 被改为 B 后又改为 A，CAS 认为他没有被修改过。</li>
<li>循环时间开销大：如果长时间不成功，会给 CPU 带来非常大的执行开销。</li>
<li>只能保证一个共享变量的原子操作。</li>
</ul>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。</p>
<p>如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗 CPU。使用不当会造成 CPU 使用率极高。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://draveness.me/mysql-transaction" target="_blank" rel="noopener">『浅入深出』MySQL 中事务的实现</a></li>
<li><a href="https://juejin.im/post/5cb2e3b46fb9a0686e40c5cb#heading-1" target="_blank" rel="noopener">MySQL 事务实现原理</a></li>
<li><a href="https://www.qiancheng.me/post/coding/mysql-001" target="_blank" rel="noopener">MYSQL解密：INNODB存储引擎重做日志漫游</a></li>
<li><a href="http://mysql.taobao.org/monthly/2018/12/04/" target="_blank" rel="noopener">MySQL · 原理介绍 · 再议MySQL的故障恢复</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961498&idx=1&sn=058097f882ff9d32f5cdf7922644d083&chksm=bd2d0d468a5a845026b7d2c211330a6bc7e9ebdaa92f8060265f60ca0b166f8957cbf3b0182c&scene=21#wechat_redirect" target="_blank" rel="noopener">4种事务的隔离级别，InnoDB如何巧妙实现？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961428&idx=1&sn=31a9eb967941d888fbd4bb2112e9602b&chksm=bd2d0d888a5a849e7ebaa7756a8bc1b3d4e2f493f3a76383fc80f7e9ce7657e4ed2f6c01777d&scene=21#wechat_redirect" target="_blank" rel="noopener">InnoDB，5项最佳实践，知其所以然？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961471&idx=1&sn=da257b4f77ac464d5119b915b409ba9c&chksm=bd2d0da38a5a84b5fc1417667fe123f2fbd2d7610b89ace8e97e3b9f28b794ad147c1290ceea&scene=21#wechat_redirect" target="_blank" rel="noopener">InnoDB，select为啥会阻塞insert？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961461&idx=1&sn=b73293c71d8718256e162be6240797ef&chksm=bd2d0da98a5a84bfe23f0327694dbda2f96677aa91fcfc1c8a5b96c8a6701bccf2995725899a&scene=21#wechat_redirect" target="_blank" rel="noopener">InnoDB并发插入，居然使用意向锁？</a></li>
<li><a href="https://yq.aliyun.com/articles/646976" target="_blank" rel="noopener">浅谈MySQL的七种锁</a></li>
<li><a href="https://cyc2018.github.io/CS-Notes/#/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">数据库系统原理</a></li>
<li><a href="https://www.jianshu.com/p/cef49aeff36b" target="_blank" rel="noopener">MVCC 能解决幻读吗？</a></li>
<li><a href="https://www.cnblogs.com/gongchixin/articles/7945767.html" target="_blank" rel="noopener">MySQL InnoDB四个事务级别 与 脏读、不重复读、幻读</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liuyuqi21.github.io/2020/01/17/MySQL-%E4%BA%8B%E5%8A%A1-%E6%97%A5%E5%BF%97-%E9%94%81/" data-id="ckd5czhhm000nnnnrcyacbq5h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA 基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/15/JAVA%20%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2020-01-15T03:10:19.000Z" itemprop="datePublished">2020-01-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/15/JAVA%20%E5%9F%BA%E7%A1%80/">Java 基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="基本类型和包装类型"><a href="#基本类型和包装类型" class="headerlink" title="基本类型和包装类型"></a>基本类型和包装类型</h1><ul>
<li>基本类型：byte(8),short(16),int(32),long(64),float(32),double(64),boolean,char(16)</li>
<li>boolean 可以使用 1 bit来存储，JVM 会在编译时期将 boolean 类型的数据转换为 int。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</li>
<li>基本类型不可以为 null，包装类型可以，所以 POJO 里只能用包装类型，因为数据库得查询结果可能是 null，如果使用基本类型，会抛空指针异常</li>
<li>基本类型在栈中直接存储具体数值，而包装类型存储的是堆中的引用</li>
<li>引用类型：对象、数组都是引用数据类型。所有引用类型的默认值都是 null。</li>
</ul>
<h2 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h2><ul>
<li>new Integer(123) 每次都会新建一个对象</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用取得同一个对象的引用</li>
<li>valueOf() 方法会先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容</li>
<li>在 Java 8 中，Integer 缓存池的大小默认为 -128~127，但是上界是可调的，在启动 jvm 的时候，通过 <code>-XX:AutoBoxCacheMax=&lt;size&gt;</code> 来指定这个缓冲池的大小</li>
<li>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</li>
</ul>
<pre class="line-numbers language-java"><code class="language-java">Integer x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//装箱 调用了 Integer.valueOf(2)</span>
<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token operator">-</span>x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//拆箱 调用了 x.intValue()</span>

Integer m <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
Integer n <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m <span class="token operator">==</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>

Integer x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Integer y <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x <span class="token operator">==</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// false</span>
Integer z <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Integer k <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>z <span class="token operator">==</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><ul>
<li>String 被声明为 final，不可变。</li>
<li>null 和空字符串不一样</li>
</ul>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>
    <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span><span class="token punctuation">,</span> Comparable<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/** The value is used for character storage. */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h2><ol>
<li>可以缓存 hash 值<br> 因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li>
<li>String Pool 的需要<br> 如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</li>
<li>线程安全</li>
</ol>
<h2 id="String-Pool-字符串常量池"><a href="#String-Pool-字符串常量池" class="headerlink" title="String Pool 字符串常量池"></a>String Pool 字符串常量池</h2><p>字符串常量池保存着所有字符串的字面量，这些字面量在编译时期就确定，可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。</p>
<p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p>
<pre class="line-numbers language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
String s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// false</span>
String s3 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
String s4 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span> s4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span>

String s5 <span class="token operator">=</span> <span class="token string">"bbb"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//会自动创建字面量，自动放入 String Pool 中</span>
String s6 <span class="token operator">=</span> <span class="token string">"bbb"</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s5 <span class="token operator">==</span> s6<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p>
<h3 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h3><p>当 String Pool 中还没有 “abc” 字符串对象的时候，new String(“abc”) 会创建两个字符串对象。</p>
<ul>
<li>编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字面量。</li>
<li>使用 new 方式会在堆中创建一个字符串对象</li>
</ul>
<h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><p>Java 的参数使用的是值传递，不是引用传递。在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。</p>
<h1 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h1><p>int 比 short 精度高，不能隐式向下转型为 short 类型。但是使用 += 或者 ++ 运算符会执行隐式类型转换。</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><ul>
<li>局部变量在栈上分配</li>
<li>没有默认值，被声明后，必须经过初始化，才可以使用</li>
</ul>
<h2 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h2><ul>
<li>声明在一个类中，但在方法，构造方法和语句块之外</li>
<li>当一个对象被实例化之后，每个实例变量的值就跟着确定</li>
<li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁</li>
<li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息</li>
<li>实例变量可以声明在使用前或者使用后</li>
<li>访问修饰符可以修饰实例变量</li>
<li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰- 符可以使实例变量对子类可见</li>
<li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量- 的值可以在声明时指定，也可以在构造方法中指定</li>
<li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName</li>
</ul>
<h3 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h3><ul>
<li>类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法、构造方法和语句块之外。</li>
<li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li>
<li>静态变量除了被声明为常量外很少使用。常量是指声明为 public/private，final 和 static 类型的变量。常量初始化后不可改变。</li>
<li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。</li>
<li>静态变量在程序开始时创建，在程序结束时销毁。</li>
<li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。</li>
<li>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是 false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li>
<li>静态变量可以通过：ClassName.VariableName的方式访问。</li>
<li>类变量被声明为 public static final类型时，类变量名称必须使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</li>
</ul>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul>
<li>声明数据：对于基本类型，final 使数值不变；对于引用类型， 对象的引用不能改变，但是里面的值可以改变。</li>
<li>声明方法不能被子类重写</li>
<li>声明类不允许被继承，final 类中的所有成员方法都会被隐式地指定为 final 方法。</li>
<li>如果在匿名类或 Lambda 表达式中访问的局部变量，如果不是 final 类型的话，编译器自动加上 final 修饰符。（<a href="https://xsinx.com/2019/06/16/为何Lambda中的局部变量必须是final/#5-静态变量和实例变量" target="_blank" rel="noopener">【译】为何Lambda中的局部变量必须是final</a>）<ul>
<li>为什么 Lambda 表达式(匿名类) 不能访问非 final 的局部变量呢？因为实例变量存在堆中，而局部变量是在栈上分配，Lambda 表达(匿名类) 会在另一个线程中执行。如果在线程中要直接访问一个局部变量，可能线程执行时该局部变量已经被销毁了，而 final 类型的局部变量在 Lambda 表达式(匿名类) 中其实是局部变量的一个拷贝。</li>
</ul>
</li>
</ul>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul>
<li><strong>静态变量</strong>：又称为类变量，这个变量属于类，类的所有实例都共享静态变量，可以直接通过类名访问，静态变量在内存中只有一份，存放于 Java 内存区域的<strong>方法区</strong>。</li>
<li><strong>静态方法</strong>：静态方法在类加载时就存在，所有静态方法必须有实现，不能是抽象方法。只能访问所属类的<strong>静态字段和静态方法</strong>，方法中不能有 this 和 super 关键字，因此这两个关键字与具体对象关联。</li>
<li><strong>静态代码块</strong>：定义在类方法外，在非静态代码块之前执行（静态代码块—&gt;构造代码块—&gt;构造方法），只在类初始化时运行一次</li>
<li><strong>静态内部类（static修饰类的话只能修饰内部类）</strong>：静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：<ol>
<li>它的创建是不需要依赖外围类的创建。</li>
<li>它不能使用任何外围类的非static成员变量和方法。</li>
</ol>
</li>
</ul>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>super 关键字用于从子类访问父类的变量和方法。</p>
<ul>
<li>在构造器中使用<code>super()</code>调用父类中的其他构造方法时，该语句必须处于构造器的首行，<code>this</code>调用本类中地其他构造方法时，也要放在首行。</li>
<li><code>this</code>、<code>super</code>不能放在<code>static</code>方法中。</li>
</ul>
<p>被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， <strong>this 和 super 是属于对象范畴的东西，而静态方法是属于类范畴的东西</strong>。</p>
<h1 id="Object-通用方法"><a href="#Object-通用方法" class="headerlink" title="Object 通用方法"></a>Object 通用方法</h1><p><code>clone(),equals(),finalize(),getClass(),hashCode(),notify(),notifyAll(),registerNatives(),toString(),wait()</code></p>
<h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><ul>
<li>对于引用类型 == 判断两个对象的地址是否相等，equals() 判断值是否相等。如果变量为null，调用equals()会报错，用(s!=null&amp;&amp;equals(“abc”))或者把非null的对象放在前面”abc”.equals(s)</li>
<li>在类没有覆盖equals()方法的时候，equals() 等价于 ==</li>
</ul>
<h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h2><ul>
<li>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同</li>
<li>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。</li>
<li>HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。</li>
</ul>
<h2 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h2><ul>
<li>clone() 是 Object 的 proceted 方法，一个类不显式去重写 clone()，其他类就不能直接去调用该类实例的 clone() 方法。</li>
<li>实现了 clone() 方法的类必须实现 Cloneable 接口，否则会抛出 CloneNotSupportedException 异常</li>
</ul>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h2><ol>
<li>从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li>
<li>从变量在内存中的存储方式来看:如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的，如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>
<li>从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li>
<li>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li>
</ol>
<h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><ul>
<li>默认的，也称为default，在同一包内可见，不使用任何修饰符。</li>
<li>私有的，以 private 修饰符指定，在同一类内可见。</li>
<li>共有的，以 public 修饰符指定，对所有类可见。</li>
<li>受保护的，以 protected 修饰符指定，对同一包内的类和所有子类可见。</li>
</ul>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类里可以有抽象方法，如果一个类中包含抽象方法，那么这个类必须声明为抽象类。抽象类不能被实例化，只能被继承。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口不能有任何的方法实现。接口的字段和方法默认是 public 的，并且不允许定义为 private 或者 protected，接口的字段默认是 static 和 final 的。</p>
<ol>
<li>jdk8 之后的接口可以有默认方法,如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。</li>
<li>JDK8 中，接口也可以定义静态方法，可以直接用接口名调用。</li>
<li>Jdk 9 在接口中引入了私有方法和私有静态方法。</li>
</ol>
<h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ul>
<li>从设计层面来说，抽象是对类的抽象，提供了一种 IS-A 的关系，是一种模板设计，接口是行为的抽象，是一种 LIKE-A 关系，是一种行为的规范。</li>
<li>从使用上来看，一个类可以实现多个接口，但是不能继承多个类</li>
<li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li>
<li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li>
</ul>
<p>需要让不相关的类都实现一个方法的时候，可以使用接口。<br>需要在几个相关的类中共享代码使用抽象类。</p>
<h2 id="super-1"><a href="#super-1" class="headerlink" title="super"></a>super</h2><p>如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</p>
<h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>为了满足里氏替换原则，重写有三个限制</p>
<ul>
<li>子类方法的访问权限必须大于等于父类方法；</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li>
<li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li>
</ul>
<p>使用 <code>@Override</code> 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p>
<blockquote>
<p> 构造方法不能被重写，但是可以被重载。</p>
</blockquote>
<p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p>
<ul>
<li>this.func(this)</li>
<li>super.func(this)</li>
<li>this.func(super)</li>
<li>super.func(super)</li>
</ul>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><ul>
<li>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是<strong>参数类型、个数、顺序</strong>至少有一个不同，<strong>方法返回值和访问修饰符</strong>可以不同。</li>
<li>返回值不同，其它都相同不算是重载。</li>
</ul>
<h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法。</p>
<p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承实现了 <strong>IS-A</strong> 关系，继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<h2 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><ul>
<li><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></li>
<li><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong>。</li>
</ul>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java语言的反射机制。</p>
<p>每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p>
<p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 Class.forName(“com.mysql.jdbc.Driver”) 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>
<p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p>
<p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p>
<ul>
<li>Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li>
<li>Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li>
<li>Constructor ：可以用 Constructor 的 newInstance() 创建新的对象。</li>
</ul>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： Error 和 Exception。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：</p>
<ul>
<li>受检异常（IOException） ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复。</li>
<li>非受检异常/运行时异常 （RuntimeException）：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li>
</ul>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ul>
<li>泛型就是编写模板代码来适应任意类型</li>
<li>不必对类型进行强制转换</li>
<li>可以省略编译器能自动推断出的类型 <code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code></li>
<li>不指定泛型参数类型时，编译器会给出警告，且只能将 <T> 视为Object类型</li>
<li>泛型不能是基本类型</li>
</ul>
<h2 id="编写泛型"><a href="#编写泛型" class="headerlink" title="编写泛型"></a>编写泛型</h2><ul>
<li>编写泛型时，需要定义泛型类型 <code>&lt;T&gt;</code></li>
<li>静态方法不能引用泛型类型 <code>&lt;T&gt;</code>，必须定义其他类型 <code>&lt;K&gt;</code> 来实现泛型</li>
<li>泛型可以同时定义多种类型 <code>&lt;T,K&gt;</code></li>
</ul>
<h2 id="擦拭法"><a href="#擦拭法" class="headerlink" title="擦拭法"></a>擦拭法</h2><ul>
<li>Java 泛型采用擦拭法实现</li>
</ul>
<h2 id="extends通配符"><a href="#extends通配符" class="headerlink" title="extends通配符"></a>extends通配符</h2><ul>
<li>使用类似 <code>&lt;? extends Number&gt;</code> 通配符作为方法参数时表示方法内部可以调用获取 Number 引用的方法，无法传入</li>
<li>使用类似 <code>&lt;T extends Number&gt;</code> 定义泛型类时表示泛型类型限定为Number或其子类</li>
</ul>
<h2 id="super通配符"><a href="#super通配符" class="headerlink" title="super通配符"></a>super通配符</h2><ul>
<li>使用类似 <code>&lt;?super super Integer&gt;</code> 通配符作为方法参数时表示方法内部可以传入获取 Integer 引用的方法，无法调用</li>
<li>使用类似 <code>&lt;T super Integer&gt;</code> 定义泛型类时表示泛型类型限定为Integer或其超类</li>
</ul>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="有三种实现线程的方法"><a href="#有三种实现线程的方法" class="headerlink" title="有三种实现线程的方法"></a>有三种实现线程的方法</h2><ol>
<li>继承 Thread 类</li>
<li>实现 Runnable 接口</li>
<li>实现 Callable 接口，可以有返回值</li>
</ol>
<p>推荐使用 Runnable 接口，因为 Java 不支持多继承。<br>Callable 接口中的 call() 方法有单绘制，是一个泛型，和 Future，FutureTask 配合用来获取异步执行的结果。</p>
<h2 id="sleep-和-wait"><a href="#sleep-和-wait" class="headerlink" title="sleep() 和 wait()"></a>sleep() 和 wait()</h2><ul>
<li>sleep 没有释放锁，wait 释放了锁</li>
<li>wait 通常被用于线程间的交互/通信，sleep 通常被用于暂停执行</li>
<li>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout) 超时后线程会自动苏醒。</li>
</ul>
<h2 id="为什么调用-start-方法会执行-run-方法，为什么不能直接调用-run-方法"><a href="#为什么调用-start-方法会执行-run-方法，为什么不能直接调用-run-方法" class="headerlink" title="为什么调用 start() 方法会执行 run() 方法，为什么不能直接调用 run() 方法"></a>为什么调用 start() 方法会执行 run() 方法，为什么不能直接调用 run() 方法</h2><p>调用 start 方法方可启动线程并使线程进入就绪状态，start 内部调用了 run 方法，直接调用 run 方法还是在主线程里执行，没有新的线程启动。</p>
<h2 id="守护线程和非守护线程"><a href="#守护线程和非守护线程" class="headerlink" title="守护线程和非守护线程"></a>守护线程和非守护线程</h2><p>程序运行完毕，JVM 会等待非守护线程完成后关闭，但是 JVM 不会等待守护线程，比如 GC 线程就是守护线程。</p>
<h2 id="什么是多线程上下文切换"><a href="#什么是多线程上下文切换" class="headerlink" title="什么是多线程上下文切换"></a>什么是多线程上下文切换</h2><p>多线程的上下文切换是指 CPU 控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取 CPU 执行权的线程的过程。</p>
<h2 id="什么导致线程阻塞"><a href="#什么导致线程阻塞" class="headerlink" title="什么导致线程阻塞"></a>什么导致线程阻塞</h2><ul>
<li>sleep()：sleep 允许指定以毫秒为单位的一段时间作为参数，使得线程在指定的时间进入阻塞状态，不能得到 CPU 时间，指定的时间一过，线程重新进入可执行状态。阻塞时不会释放占用的锁。</li>
<li>yield()：yield 使当前线程放弃已经分得的 CPU 时间，但不使当前线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。</li>
<li>suspend() 和 resume()：suspend 使得线程进入阻塞状态，不会自动恢复，只有 resume 被调用，才能使得线程重新进入可执行状态。</li>
<li>wait() 和 notify()：wait 可以指定毫秒单位的时间作为参数，也可以不指定，当超出时间或者调用 notify 方法时，线程进入可执行状态。这一对方法必须在 synchorized 方法或者块中调用，只有在 synchronized 方法或块中当前线程才占有锁，才有锁可以释放。</li>
</ul>
<h2 id="synchronized-和-ReentrantLock"><a href="#synchronized-和-ReentrantLock" class="headerlink" title="synchronized 和 ReentrantLock"></a>synchronized 和 ReentrantLock</h2><ul>
<li>ReentrantLock 是一个接口，而 synchorized 是关键字</li>
<li>都是可重入锁</li>
<li>ReentrantLock 需要显示的加锁和释放锁，synchorized 是自动的</li>
<li>ReentrantLock 支持公平锁和非公平锁</li>
<li>ReentrantLock 可相应中断、可轮回，synchorized 不可以</li>
</ul>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><ul>
<li>IO 流是一种顺序读写数据的模式</li>
<li>二进制数据以 byte 为最小单位在 InputStream/OuputStream 中单向流动（字节流）</li>
<li>字符数据以 char 为最小单位在 Reader/Writer 中单向流动</li>
<li>java.io 包提供了同步 IO 功能</li>
</ul>
<h2 id="Java-中-IO-流分为几种"><a href="#Java-中-IO-流分为几种" class="headerlink" title="Java 中 IO 流分为几种"></a>Java 中 IO 流分为几种</h2><p>Java IO 流有4个抽象基类:</p>
<table>
<thead>
<tr>
<th></th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输出流</td>
<td>OutPutStream</td>
<td>Writer</td>
</tr>
<tr>
<td>输入流</td>
<td>InputStream</td>
<td>Reader</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/cellophane/image/raw/master/20200411233959.png" alt=""></p>
<ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>在 Java 的 I/O 中使用到装饰器模式,下面以 InputStream 为例：</p>
<ul>
<li>InputStream是抽象组件；</li>
<li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；</li>
<li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能</li>
</ul>
<p>在实际开发中，实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可，例如：</p>
<pre class="line-numbers language-java"><code class="language-java">FileInputStream fileInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>
BufferedInputStream bufferedInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span>fileInputStream<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="Java-与-C-的区别"><a href="#Java-与-C-的区别" class="headerlink" title="Java 与 C++ 的区别"></a>Java 与 C++ 的区别</h1><ul>
<li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li>
<li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li>
<li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li>
<li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li>
<li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li>
<li>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li>
<li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">Java 基础</a></li>
<li><a href="https://www.zhihu.com/question/31203609/answer/50992895" target="_blank" rel="noopener">Java 到底是值传递还是引用传递？</a></li>
<li><a href="https://juejin.im/post/5b57b81af265da0f4b7a9ae5" target="_blank" rel="noopener">bat等大公司常考java多线程面试题</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453141826&idx=2&sn=759e6e18c4694b510ac8e0af31608b6c&chksm=8cf2dbc1bb8552d7575b31770cf5af9b25c470f57aa6a9727446ab99ae2d76b2c5767ff280f6&scene=0&xtrack=1#rd" target="_blank" rel="noopener">为什么阿里巴巴不建议在for循环中使用”+”进行字符串拼接</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liuyuqi21.github.io/2020/01/15/JAVA%20%E5%9F%BA%E7%A1%80/" data-id="ckd5czhhe0008nnnr1oog6its" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-扫码登录实现原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/11/%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2020-01-11T08:12:34.000Z" itemprop="datePublished">2020-01-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/11/%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">扫码登录实现原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://gitee.com/cellophane/image/raw/master/qrcode.png" alt=""></p>
<p>passport 中涉及的接口：</p>
<h2 id="getQRCode（pc-端获得登录二维码）"><a href="#getQRCode（pc-端获得登录二维码）" class="headerlink" title="getQRCode（pc 端获得登录二维码）"></a>getQRCode（pc 端获得登录二维码）</h2><ol>
<li>生成一个随机字符串 code，调用 setex 命令，将这个 code 拼接前缀后作为 key 存入 redis 同时设置一个过期时间，过期后二维码失效需要刷新重新获取。</li>
<li>存储成功后返回 code。</li>
</ol>
<pre class="line-numbers language-php"><code class="language-php"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function">getQRCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token variable">$code</span> <span class="token operator">=</span> self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">gen64Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token variable">$redis</span> <span class="token operator">=</span> self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getRedis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token variable">$redis</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setEx</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">makeQrCode</span><span class="token punctuation">(</span><span class="token variable">$code</span><span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token constant">QR_CODE_VALID_TIME</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token variable">$ret</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
        <span class="token string">'token'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$code</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> Error<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">serviceRet</span><span class="token punctuation">(</span>Error<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token constant">ERR_NO_SUCCESS</span><span class="token punctuation">,</span> <span class="token variable">$ret</span><span class="token punctuation">,</span> <span class="token string">'获取成功！'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="appLogin（app-扫码）"><a href="#appLogin（app-扫码）" class="headerlink" title="appLogin（app 扫码）"></a>appLogin（app 扫码）</h2><ol>
<li>手机扫码可以得到 code 和登录接口，app 调用 appLogin 接口传入用户 memberId 和 code。</li>
<li>服务器解析得到用户 memberId 和 code，用 code 去 redis 查询二维码是否过期。</li>
<li>如果没过期，将 code 作为键 memberID 作为值存入 redis，建立 memberId 与 code 的联系。</li>
<li>踢出其他登录信息。</li>
</ol>
<pre class="line-numbers language-php"><code class="language-php"><span class="token variable">$status</span> <span class="token operator">=</span> <span class="token variable">$redis</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">makeQrCode</span><span class="token punctuation">(</span><span class="token variable">$code</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$status</span> <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Error<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">serviceRet</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'二维码已失效，请刷新重试!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token variable">$redis</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">set</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">makeQrCode</span><span class="token punctuation">(</span><span class="token variable">$code</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token variable">$redis</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setEx</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">makeQrToken</span><span class="token punctuation">(</span><span class="token variable">$code</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">$validTime</span><span class="token punctuation">,</span> <span class="token variable">$memberId</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// 踢出其他登录的信息</span>
<span class="token variable">$loginToken</span> <span class="token operator">=</span> <span class="token variable">$redis</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">makeQrLoginTokenKey</span><span class="token punctuation">(</span><span class="token variable">$memberId</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$loginToken</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token variable">$redis</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">delete</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">makeQrLoginToken</span><span class="token punctuation">(</span><span class="token variable">$loginToken</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="getQRStatus（pc-轮询扫码状态）"><a href="#getQRStatus（pc-轮询扫码状态）" class="headerlink" title="getQRStatus（pc 轮询扫码状态）"></a>getQRStatus（pc 轮询扫码状态）</h2><ol>
<li>浏览器拿到二维码之后，每隔一秒向浏览器发送一次登录是否成功的请求（调用接口 ‘getQRStatus’）。</li>
<li>请求中携带 code，先查询二维码是否失效，失效则返回二维码已失效。</li>
<li>然后用 code 查询 redis 是否有 memberId。</li>
<li>如果有 memberId 就登陆成功并设置对应的 loginToken，返回 loginToken，没有就继续轮询。</li>
</ol>
<pre class="line-numbers language-php"><code class="language-php"><span class="token variable">$redis</span> <span class="token operator">=</span> self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">getRedis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token variable">$status</span> <span class="token operator">=</span> <span class="token variable">$redis</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">makeQrCode</span><span class="token punctuation">(</span><span class="token variable">$code</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$status</span> <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Error<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">serviceRet</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'二维码已失效!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token variable">$memberId</span> <span class="token operator">=</span> <span class="token variable">$redis</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">makeQrToken</span><span class="token punctuation">(</span><span class="token variable">$token</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$memberId</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 登陆成功</span>
    <span class="token variable">$redis</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">del</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">makeQrToken</span><span class="token punctuation">(</span><span class="token variable">$token</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token variable">$redis</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">del</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">makeQrCode</span><span class="token punctuation">(</span><span class="token variable">$token</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token variable">$loginToken</span> <span class="token operator">=</span> self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">gen64Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 设置对应的登陆token</span>
    <span class="token variable">$redis</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setEx</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">makeQrLoginToken</span><span class="token punctuation">(</span><span class="token variable">$loginToken</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">$validTime</span><span class="token punctuation">,</span> <span class="token variable">$memberId</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 保存用户的登录信息，以便下次用户扫描二维码时将该loginToken失效</span>
    <span class="token variable">$redis</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">setEx</span><span class="token punctuation">(</span>self<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">makeQrLoginTokenKey</span><span class="token punctuation">(</span><span class="token variable">$memberId</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">$validTime</span><span class="token punctuation">,</span> <span class="token variable">$loginToken</span><span class="token punctuation">)</span>
    <span class="token variable">$ret</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
        <span class="token string">'loginToken'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$loginToken</span><span class="token punctuation">,</span>
        <span class="token string">'status'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$status</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> Error<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">serviceRet</span><span class="token punctuation">(</span>Error<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token constant">ERR_NO_SUCCESS</span><span class="token punctuation">,</span> <span class="token variable">$ret</span><span class="token punctuation">,</span> <span class="token string">'登录成功！'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxNjk4ODE4OQ==&mid=2247488299&idx=1&sn=0cbdefeef1555167247b266011943f56&chksm=9bed3259ac9abb4fde1b13d913803c99645b0b89e504ed35e0888908b9d025cc0843c72a4d2e&mpshare=1&scene=23&srcid=02107idLn2aTJVrxHWuQX96z&sharer_sharetime=1581317735054&sharer_shareid=da3c4e6d38e0827ddba7900a4fab3cd4#rd" target="_blank" rel="noopener">阿里面试官：分别说说微信和淘宝扫码登录背后的实现原理？</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liuyuqi21.github.io/2020/01/11/%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" data-id="ckd5czhij003lnnnr200618be" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-random主题归档页问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/05/random%E4%B8%BB%E9%A2%98%E5%BD%92%E6%A1%A3%E9%A1%B5%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-01-05T09:44:29.000Z" itemprop="datePublished">2020-01-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%97%AE%E9%A2%98/">问题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/05/random%E4%B8%BB%E9%A2%98%E5%BD%92%E6%A1%A3%E9%A1%B5%E9%97%AE%E9%A2%98/">random 主题归档页问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一直喜欢 random 主题，用过好多个发现还是这个对我胃口，但是最近发现归档页有问题，只能显示出 10 篇文章。去拉了主题的最新代码发现，文章是显示出来了，但是顺序乱七八糟的。</p>
<h2 id="找到归档页的代码"><a href="#找到归档页的代码" class="headerlink" title="找到归档页的代码"></a>找到归档页的代码</h2><p>虽然不是前端，但还是硬着头皮看了看代码。发现新的代码里使用的是 <code>site.posts</code>，旧的代码是 <code>page.posts</code>。搜了一下这两个东西，发现是 hexo 的变量，<code>site.posts</code> 会显示出全部文章，<code>page.posts</code> 是当前页文章。打印出 <code>site.posts</code> 发现显示出来就是乱序的，<code>page.posts</code>只有十条。</p>
<p>于是我下了个 next 主题，看看别人是怎么写的，发现 next 代码里用的是 <code>page</code> 变量，打开页面，发现文章是分页显示的，打开 hexo 的文档，又看到了分页相关的变量，折腾了好久终于想到了问题的所在，random 没有分页，但是 <code>page</code> 变量只能显示第一页，于是作者改成了 <code>site</code>，但是顺序又不对。</p>
<h2 id="使归档不分页"><a href="#使归档不分页" class="headerlink" title="使归档不分页"></a>使归档不分页</h2><p>怎么办呢，网上肯定有不分页的办法哈哈哈，果然，<a href="https://sobaigu.com/hexo-archives-show-all-in-one-page.html" target="_blank" rel="noopener">Hexo博客归档不分页显示设置方法</a>。由于我的文章不多，而且时间宝贵不想折腾别的了，就采取了第一种最简单的方式，在 hexo 配置里加一条</p>
<pre class="line-numbers language-yml"><code class="language-yml">archive:  1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>好了，赶紧干正事去，折腾了三四个小时了都😭</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liuyuqi21.github.io/2020/01/05/random%E4%B8%BB%E9%A2%98%E5%BD%92%E6%A1%A3%E9%A1%B5%E9%97%AE%E9%A2%98/" data-id="ckd5czhi8002knnnr4mo0cr4i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Redis-应用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/16/Redis-%E5%BA%94%E7%94%A8/" class="article-date">
  <time datetime="2019-11-16T14:03:29.000Z" itemprop="datePublished">2019-11-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/16/Redis-%E5%BA%94%E7%94%A8/">Redis-应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="为什么选择-Redis"><a href="#为什么选择-Redis" class="headerlink" title="为什么选择 Redis"></a>为什么选择 Redis</h1><h2 id="Redis-的优势"><a href="#Redis-的优势" class="headerlink" title="Redis 的优势"></a>Redis 的优势</h2><ul>
<li>速度快，因为数据存在内存中</li>
<li>支持丰富的数据类型</li>
<li>支持事务</li>
<li>可以持久化数据</li>
<li>支持 master-salve 模式的数据备份 </li>
</ul>
<h2 id="Redis-与-Memchche-的区别"><a href="#Redis-与-Memchche-的区别" class="headerlink" title="Redis 与 Memchche 的区别"></a>Redis 与 Memchche 的区别</h2><ul>
<li>性能相差不大</li>
<li>Redis 在 2.0 版本后增加了自己的 VM 特性，突破物理内存的限制。Memcache 可以修改最大可用内存，采用 LR 算法</li>
<li>Redis 以来客户端实现分布式读写 Memcache 本身没有数据冗余机制</li>
<li>Redis 支持快照、AOF，依赖快照进行持久化，AOF 增强了可靠性的同时，对性能有所影响</li>
<li>Memcache 不支持持久化，通常做缓存，提升性能</li>
<li>Memcachche 在并发场景下，用 CAS 保证一致性，redis事务支持比较弱，只能保证事务中的每个操作连续行</li>
<li>Redis 支持多种数据类型</li>
<li>Redis 用于数据量较小的高性能操作和运算上</li>
<li>Memcache 用于在动态系统中减少数据库负载，提升性能</li>
</ul>
<h2 id="数据类型的应用场景"><a href="#数据类型的应用场景" class="headerlink" title="数据类型的应用场景"></a>数据类型的应用场景</h2><ul>
<li>String：一般做一些复杂计数功能的缓存</li>
<li>hash：存放的是结构化的对象，方便的用来操作其中某个字段，可以用来存储用户信息。</li>
<li>list：可以做简单的消息队列，可以利用 lrange 做基于 Redis 的分页功能。</li>
<li>set：做全局的去重功能，或者利用交集、并集、差集计算共同爱好，全部的爱好，自己独有的爱好。</li>
<li>zset：可以做排行榜应用，取 Top N 操作，还可以用来做延时任务，范围查找。</li>
</ul>
<h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><p>高可用相关技术：</p>
<ul>
<li>持久化：持久化是最简单的高可用方法(有时甚至不被归为高可用的手段)，主要作用是数据备份，即将数据存储在硬盘，保证数据不会因进程退出而丢失。</li>
<li>复制：复制是高可用 Redis 的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。</li>
<li>哨兵：在复制的基础上，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机的限制。</li>
<li>集群：通过集群，Redis解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。</li>
</ul>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>持久化的功能：Redis是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将Redis中的数据以某种形式(数据或命令)从内存保存到硬盘；当下次Redis重启时，利用持久化文件实现数据恢复。除此之外，为了进行灾难备份，可以将持久化文件拷贝到一个远程位置。</p>
<p>RDB 做镜像全量持久化，AOF 做增量持久化。两者会配合来使用。redis 重启时，会使用 RDB 持久化文件重新构建内存，再使用 AOF 重放近期操作指令来完整恢复。</p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB 会将当前进程中的数据生成快照保存到硬盘，生成多个数据文件，每个数据文件分别都代表了某一时刻 Redis 里面的数据，保存的文件后缀是 rdb，当 Redis 重启时，可以读取快照文件恢复数据。</p>
<p>RDB 持久化的触发分为手动触发和自动触发。</p>
<ul>
<li>手动触发：save 命令和 bgsave 命令都可以生成 RDB 文件<ul>
<li>save 命令会阻塞 Redis 服务器进程，直到 RDB 文件创建完毕为止，在 Redis 服务器阻塞期间，服务器不能处理任何命令请求。</li>
<li>bgsave 命令会创建一个子进程，由子进程来负责创建 RDB 文件，父进程(即 Redis 主进程)则继续处理请求。</li>
</ul>
</li>
<li>自动触发：在配置文件中通过<code>save m n</code>，指定 m 秒发生 n 次变化时触发 bgsave。 </li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF 把每条写入的命令存入日志，以 append-only 的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像 Mysql 中的 binlog。</p>
<p>一般使用定时 sync，比如 1 秒 1 次，这个时候最多就会丢失 1s 的数据。</p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。</p>
<h3 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a><strong>主从复制的作用</strong></h3><ul>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li>
<li>高可用基石：主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li>
</ul>
<p>Redis Sentinal 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master，继续提供服务。</p>
<p>Redis Cluster 着眼于扩展性，在单个 redis 内存不足时，使用 Cluster 进行分片存储。</p>
<h3 id="主从复制步骤"><a href="#主从复制步骤" class="headerlink" title="主从复制步骤"></a>主从复制步骤</h3><p>在本机上模拟主从复制可以通过复制配置文件，在不同端口打开 Redis 实例来模拟主从复制。</p>
<h4 id="配置多个端口的-Redis-实例"><a href="#配置多个端口的-Redis-实例" class="headerlink" title="配置多个端口的 Redis 实例"></a>配置多个端口的 Redis 实例</h4><ol>
<li>复制 Redis 配置文件，修改 port。</li>
<li>输入命令 <code>sudo redis-server /etc/redis/redis6380.conf</code> 启动 Redis。</li>
<li>输入命令 <code>redis-cli -p 6380</code> 进入 Redis 实例。</li>
</ol>
<h4 id="配置主从复制"><a href="#配置主从复制" class="headerlink" title="配置主从复制"></a>配置主从复制</h4><p><strong>主从复制的开启，完全是在从节点发起的；不需要我们在主节点做任何事情。</strong></p>
<p>有三种方式开启主从复制</p>
<ul>
<li>在从服务器的配置文件中加入：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li>
<li>redis-server 启动命令后加入 <code>--slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li>
<li>Redis 服务器启动后，直接通过客户端执行命令：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code>，则该Redis实例成为从节点。</li>
</ul>
<p>如：在 6380 端口的 Redis 实例输入命令 <code>slaveof 17.0.0.1 6379</code> ，6380 的 Redis 就成为了 6379 Redis 的从节点。</p>
<h4 id="断开复制"><a href="#断开复制" class="headerlink" title="断开复制"></a>断开复制</h4><p>从节点输入 <code>slaveof no one</code> 就可以断开复制。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h2 id="哨兵（Sentinel）"><a href="#哨兵（Sentinel）" class="headerlink" title="哨兵（Sentinel）"></a>哨兵（Sentinel）</h2><p>哨兵是基于 Redis 主从复制，主要作用是<strong>解决主节点故障恢复的自动化问题</strong>，进一步提高系统的高可用性。</p>
<ul>
<li>监控（Monitoring）：哨兵会不断地检查主节点和从节点是否运作正常。</li>
<li>自动故障转移（Automatic failover）：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</li>
<li>配置提供者（Configuration provider）：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。</li>
<li>通知（Notification）：哨兵可以将故障转移的结果发送给客户端。</li>
</ul>
<p><img src="https://gitee.com/cellophane/image/raw/master/20200402235846.png" alt="哨兵架构图"></p>
<p>哨兵架构由两部分组成：</p>
<ul>
<li>哨兵节点：哨兵系统由一个或多个哨兵节点组成，<strong>哨兵节点是特殊的 redis 节点</strong>，不存储数据。</li>
<li>数据节点：主节点和从节点都是数据节点。</li>
</ul>
<p>哨兵进程是用于<strong>监控 Redis 集群中 Master 主服务器工作的状态</strong>。</p>
<p>在 Master 主服务器发生故障的时候，可以实现 Master 和 Slave 服务器的切换，保证系统的高可用（High Availability）</p>
<p>哨兵至少要用<strong>三个实例</strong>去保证自己的健壮性。</p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>包含 1 个主节点，2 个从节点和 3 个哨兵节点。</p>
<ol>
<li>部署主从节点，参考主从复制步骤。</li>
<li>节点启动后，列检主节点查看主从状态是否正常<code>info replication</code>。</li>
<li>在哨兵节点的配置中添加 <code>sentinel monitor mymaster 127.0.0.1 6379 2</code>，该哨兵节点监控192.168.92.128:6379这个主节点，该主节点的名称是 mymaster，最后的 2 的含义与主节点的故障判定有关：至少需要2个哨兵节点同意，才能判定主节点故障并进行故障转移。</li>
</ol>
<h2 id="集群（Cluster）"><a href="#集群（Cluster）" class="headerlink" title="集群（Cluster）"></a>集群（Cluster）</h2><p>Redis Cluster是社区版推出的Redis分布式集群解决方案，主要解决Redis分布式方面的需求，比如，当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster能起到很好的负载均衡的目的。</p>
<p>Redis Cluster集群节点最小配置6个节点以上（3主3从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</p>
<p>分布式数据库把整个数据按分区规则映射到多个节点，即把数据划分到多个节点上，每个节点负责整体数据的一个子集。比如我们库有900条用户数据，有3个redis节点，将900条分成3份，分别存入到3个redis节点。</p>
<p>集群的作用有两点：</p>
<ul>
<li>数据分区：集群将数据分散到多个节点，一方面突破了Redis单机内存大小的限制，存储容量大大增加；另一方面每个主节点都可以对外提供读服务和写服务，大大提高了集群的响应能力。</li>
<li>高可用：集群支持主从复制和主节点的自动故障转移（与哨兵类似）；当任一节点发生故障时，集群仍然可以对外提供服务。</li>
</ul>
<p><a href="https://www.cnblogs.com/kismetv/p/9853040.html" target="_blank" rel="noopener">集群搭建步骤</a></p>
<h1 id="缓存数据不一致"><a href="#缓存数据不一致" class="headerlink" title="缓存数据不一致"></a>缓存数据不一致</h1><h2 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h2><p><img src="https://gitee.com/cellophane/image/raw/master/20200414172723.png" alt=""></p>
<p>这个是逻辑是错误的。两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是旧的数据，导致缓存中的数据一直是旧数据。</p>
<h2 id="先更新数据库，再删除缓存（Cache-Aside-Pattern）"><a href="#先更新数据库，再删除缓存（Cache-Aside-Pattern）" class="headerlink" title="先更新数据库，再删除缓存（Cache Aside Pattern）"></a>先更新数据库，再删除缓存（Cache Aside Pattern）</h2><p><img src="https://gitee.com/cellophane/image/raw/master/20200414172927.png" alt=""></p>
<p>这种情况发生的不一致，是因为缓存突然失效了。而且还要保证请求B更新操作 比 请求A的查询操作还要快；才会导致不一致。<strong>这种情况概率会很少。一般要求不高的项目可以采用此方式</strong>。</p>
<h2 id="采用延时双删策略"><a href="#采用延时双删策略" class="headerlink" title="采用延时双删策略"></a>采用延时双删策略</h2><ul>
<li>先删除缓存</li>
<li>再写数据库</li>
<li>休眠 500 毫秒（时间根据自己项目的读业务逻辑的耗时，目的是确保读请求结束，写请求可以删除读请求造成的缓存脏数据）</li>
<li>再次删除缓存</li>
</ul>
<h2 id="异步更新缓存（基于订阅-binlog-的同步机制）"><a href="#异步更新缓存（基于订阅-binlog-的同步机制）" class="headerlink" title="异步更新缓存（基于订阅 binlog 的同步机制）"></a>异步更新缓存（基于订阅 binlog 的同步机制）</h2><p><img src="https://gitee.com/cellophane/image/raw/master/20200414171925.png" alt=""></p>
<p>MySQL binlog增量订阅消费+消息队列+增量数据更新到redis</p>
<ul>
<li>读 Redis：热数据基本都在 Redis</li>
<li>写 MySQL:增删改都是操作 MySQL</li>
<li>更新 Redis 数据：读取 binlog 后分析 ，利用消息队列，推送更新各台的 redis 缓存数据。</li>
</ul>
<h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>数据未加载到缓存中，或者缓存同一时间大面积失效，导致所有请求都去查数据库，导致数据库和 CPU 和内存负载过高。</p>
<p>解决方式：</p>
<ul>
<li>在批量往 Redis 存数据的时候，把每个失效时间都加个随机值。</li>
<li>缓存降级：利用本地缓存暂时支持，对源服务器访问进行限流，资源隔离（熔断）。</li>
<li>Redis 备份和快速缓存预热。</li>
<li>提前演练：在项目上线前，演练缓存层宕掉后，应用以及后端的负载情况以及可能出现的问题，对高可用提前预演，发现问题。</li>
<li>缓存预热：系统上线后，将相关的缓存数据直接加载到缓存系统。</li>
</ul>
<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>指查询一个不存在的数据，从缓存 Redis 没有命中，需要从 MySQL 数据库查询，查不到数据不写入缓存，导致这个不存则的数据每次请求都要数据库查询。</p>
<p>解决方法：</p>
<ul>
<li>如果查询数据库为空，直接设置一个默认值存放到缓存。</li>
<li>给 key 设置一些格式规则，查询之前先过滤掉不符合规则的 key</li>
<li>布隆过滤器</li>
</ul>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把他们置为 1。检索时，只要看看这些点是不是都是 1 就知道集合里有没有它。</p>
<p>缺点：存在误判、删除困难。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.cnblogs.com/rjzheng/p/9096228.html" target="_blank" rel="noopener">【原创】分布式之redis复习精讲</a></li>
<li><a href="https://www.cnblogs.com/kismetv/p/9236731.html" target="_blank" rel="noopener">深入学习Redis（3）：主从复制</a></li>
<li><a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">缓存更新的套路</a></li>
<li><a href="https://www.cnkirito.moe/cache-line/" target="_blank" rel="noopener">JAVA 拾遗 — CPU Cache 与缓存行</a></li>
<li><a href="https://www.toutiao.com/i6669945231242166791/?group_id=6669945231242166791" target="_blank" rel="noopener">你知道如何更新缓存吗？如何保证缓存和数据库双写一致性？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961368&idx=1&sn=82a59f41332e11a29c5759248bc1ba17&chksm=bd2d0dc48a5a84d293f5999760b994cee9b7e20e240c04d0ed442e139f84ebacf608d51f4342&scene=21#wechat_redirect" target="_blank" rel="noopener">缓存架构 一篇足够？</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://liuyuqi21.github.io/2019/11/16/Redis-%E5%BA%94%E7%94%A8/" data-id="ckd5czhhw001mnnnr89dj1qmo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/">PHP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">系统设计</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%97%AE%E9%A2%98/">问题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Elasticsearch/" rel="tag">Elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JWT/" rel="tag">JWT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Laravel/" rel="tag">Laravel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/" rel="tag">Nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP/" rel="tag">PHP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RocketMQ/" rel="tag">RocketMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ZooKeeper/" rel="tag">ZooKeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redisson/" rel="tag">redisson</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typora/" rel="tag">typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%90%E8%A7%82%E9%94%81/" rel="tag">乐观锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" rel="tag">分布式事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%91%E6%8C%87Offer/" rel="tag">剑指Offer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="tag">知识点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" rel="tag">负载均衡</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag">面经</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%98%E7%9B%AE/" rel="tag">题目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" rel="tag">高并发</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/Elasticsearch/" style="font-size: 10px;">Elasticsearch</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/JAVA/" style="font-size: 10px;">JAVA</a> <a href="/tags/JWT/" style="font-size: 10px;">JWT</a> <a href="/tags/Java/" style="font-size: 17.5px;">Java</a> <a href="/tags/Laravel/" style="font-size: 10px;">Laravel</a> <a href="/tags/Linux/" style="font-size: 12.5px;">Linux</a> <a href="/tags/MySQL/" style="font-size: 20px;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/PHP/" style="font-size: 17.5px;">PHP</a> <a href="/tags/Redis/" style="font-size: 17.5px;">Redis</a> <a href="/tags/RocketMQ/" style="font-size: 12.5px;">RocketMQ</a> <a href="/tags/ZooKeeper/" style="font-size: 10px;">ZooKeeper</a> <a href="/tags/leetcode/" style="font-size: 12.5px;">leetcode</a> <a href="/tags/redisson/" style="font-size: 10px;">redisson</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/typora/" style="font-size: 10px;">typora</a> <a href="/tags/%E4%B9%90%E8%A7%82%E9%94%81/" style="font-size: 10px;">乐观锁</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">分布式</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" style="font-size: 12.5px;">分布式事务</a> <a href="/tags/%E5%89%91%E6%8C%87Offer/" style="font-size: 20px;">剑指Offer</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">排序</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 12.5px;">操作系统</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 10px;">消息队列</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/" style="font-size: 10px;">知识点</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 10px;">缓存</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 12.5px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">读书笔记</a> <a href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" style="font-size: 10px;">负载均衡</a> <a href="/tags/%E9%9D%A2%E7%BB%8F/" style="font-size: 12.5px;">面经</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">面试</a> <a href="/tags/%E9%A2%98%E7%9B%AE/" style="font-size: 15px;">题目</a> <a href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">高并发</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/11/leetcode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">leetcode 数据结构</a>
          </li>
        
          <li>
            <a href="/2020/04/01/%E9%9D%A2%E8%AF%95%E8%8C%83%E5%9B%B4/">面试范围</a>
          </li>
        
          <li>
            <a href="/2020/03/23/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">负载均衡</a>
          </li>
        
          <li>
            <a href="/2020/03/20/JAVA%20%E5%B9%B6%E5%8F%91/">Java 并发</a>
          </li>
        
          <li>
            <a href="/2020/03/10/typora%E5%BF%AB%E6%8D%B7%E9%94%AE/">typora 快捷键</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Cellophane<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>