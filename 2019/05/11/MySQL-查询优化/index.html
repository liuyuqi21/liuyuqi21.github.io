






<!doctype html>
<html lang="zh-CN">
<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="author" content="Cellophane">
  
  
  
  
    <meta name="description" content="分析先说明如何定位低效 SQL 语句，然后根据 SQL 语句可能低效的原因做排查，先从索引着手，如果索引没有问题，考虑其他几个方面，数据访问的问题，长难语句的问题还是一些特定类型优化的问题

通过脚本，刷新观察 status
是否周期性故障或者波动

一般由访问高峰或缓存崩溃引起，加缓存并更改缓存失效策略，使失效时间分散或夜间定时失效

show processlist 或开启慢查询 获取有...">
  
  <title>MySQL 查询优化 [ Cellophane ]</title>
  
  
    <link rel="shortcut icon" href="/Blinky.ico">
  
  
  <link rel="stylesheet" href="/css/random.css">
<link rel="stylesheet" href="/css/vegas.min.css">
<link rel="stylesheet" href="/css/styles/railscasts.css">
<link rel="stylesheet" href="/css/jquery.fancybox.css">
<link rel="stylesheet" href="/css/iconfont/iconfont.css">
<link rel="stylesheet" href="/css/jquery.fancybox-thumbs.css">
<link rel="stylesheet" href="/css/plyr.css">
<link rel="stylesheet" href="/css/prism.css">
  
</head>

<body>
<div class="side-navigate hide-area">
  
    <div class="item prev">
      <a href="/2019/05/16/面试知识点/">
        <div class="item-icon"></div>
      </a>
      <div class="item-title">
        面试知识点
      </div>
    </div>
  
  
    <div class="item next">
      <a href="/2019/05/09/MySQL-基础/">
        <div class="item-icon"></div>
      </a>
      <div class="item-title">
        MySQL 基础
      </div>
    </div>
  
</div>
<div id="outer-container" class="hide-area">
<div id="container">
  <div id="menu-outer" class="slide-down">
    <div id="menu-inner">
      <div id="brand">
        
        <a onClick="openUserCard()">
          <img id="avatar" src="/images/me3.jpg"/>
          <div id="homelink">Cellophane</div>
        </a>
      </div>
      <div id="menu-list">
        <ul>
        
        
          
            <li>
          
            <a href="/index.html">首页</a>
            
          </li>
        
          
            <li>
          
            <a href="/archives">文章</a>
            
          </li>
        
          
            <li>
          
            <a href="/tags">标签</a>
            
          </li>
        
          
            <li>
          
            <a href="/categories">分类</a>
            
          </li>
        
        </ul>
      </div>
      <div id="show-menu">
        <button>Menu</button>
      </div>
    </div>
  </div>

  <div id="content-outer">
    <div id="content-inner">
      
      
  

  <article id="post">
    <h1>MySQL 查询优化</h1>
    <p class="page-title-sub">
      <span id = "post-title-date">撰写于 2019-05-11</span>
      
      
      <span id = "post-title-categories">分类
      
      
        
        
        <a href="/categories/基础/">基础</a>
      
      </span>
      
      
      <span id = "post-title-tags">
      标签
      
      
        
        
        <a href="/tags/MySQL/">MySQL</a>
      
      </span>
      
    </p>
    
    <h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>先说明如何定位低效 SQL 语句，然后根据 SQL 语句可能低效的原因做排查，先从索引着手，如果索引没有问题，考虑其他几个方面，数据访问的问题，长难语句的问题还是一些特定类型优化的问题</p>
<ol>
<li>通过脚本，刷新观察 status</li>
<li><p>是否周期性故障或者波动</p>
</li>
<li><p>一般由访问高峰或缓存崩溃引起，加缓存并更改缓存失效策略，使失效时间分散或夜间定时失效</p>
</li>
<li>show processlist 或开启慢查询 获取有问题的 sql</li>
<li>profiling 分析语句及 explain 分析语句<ol>
<li>如果语句等待时间长：调优服务器参数（如缓冲区，线程数）</li>
<li>如果语句执行时间长：可能是表设计有缺陷，索引没优化 语句没优化</li>
</ol>
</li>
</ol>
<h2 id="排查命令"><a href="#排查命令" class="headerlink" title="排查命令"></a>排查命令</h2><ul>
<li><code>show status</code> 返回计数器</li>
<li><code>show global status</code> 查看服务器级别的所有计数</li>
<li><code>show processlist</code> 观察是否有大量线程处于不正常的状态或特征</li>
</ul>
<h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><ul>
<li>开启慢查询日志<ol>
<li>以命令行的方式设置参数，不需要重启 MySQL 服务 <code>set global slow_query_log = ON;</code></li>
<li>以配置文件的方式设置，需要重启 MySQL 服务。</li>
</ol>
</li>
<li>设置 long_query_time 值：<code>set long_query_time=10;</code></li>
<li>查看慢查询日志：<code>more show-query.log</code> 或者 <code>mysqldumpslow show-query.log</code></li>
</ul>
<h2 id="使用-Explain-进行分析"><a href="#使用-Explain-进行分析" class="headerlink" title="使用 Explain 进行分析"></a>使用 Explain 进行分析</h2><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td>表示找到所需数据使用的扫描方式</td>
</tr>
<tr>
<td>select_type</td>
<td>查询类型，有简单查询、联合查询、子查询等</td>
</tr>
<tr>
<td>table</td>
<td>表名</td>
</tr>
<tr>
<td>key</td>
<td>使用的索引</td>
</tr>
<tr>
<td>row</td>
<td>扫描的行数</td>
</tr>
<tr>
<td>Extra</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>type</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>system</td>
<td>系统表，少量数据，往往不需要磁盘 IO</td>
</tr>
<tr>
<td>const</td>
<td>常量连接，主键或者唯一索引上的等值查询</td>
</tr>
<tr>
<td>eq_ref</td>
<td>主键索引或者非空唯一索引上的 join 查询，等值扫描，对于前表的每一行，后表只有一行命中</td>
</tr>
<tr>
<td>ref</td>
<td>非主键非唯一索引等值扫描</td>
</tr>
<tr>
<td>range</td>
<td>范围扫描，如 between</td>
</tr>
<tr>
<td>index</td>
<td>索引树扫描，需要扫描索引上的全部数据，如 InnoDB 的count</td>
</tr>
<tr>
<td>ALL</td>
<td>全表扫描</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Extra</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Using Where</td>
<td>SQL 使用了 where 条件过滤数据</td>
</tr>
<tr>
<td>Using index</td>
<td>返回的所有列数据均在一颗所引述上，无需访问实际行记录（索引覆盖）</td>
</tr>
<tr>
<td>Using index condition</td>
<td>命中索引但是没有索引覆盖</td>
</tr>
<tr>
<td>using filesort</td>
<td>得到所需结果集，需要对所有记录进行文件排序（在没有建立索引的列上 order by）</td>
</tr>
<tr>
<td>using temporary</td>
<td>需要建立临时表(temporary table)来暂存中间结果(group by 和 order by 同时存在，且作用于不同的字段时）</td>
</tr>
<tr>
<td>Using join buffer(Block Nested Loop)</td>
<td>需要进行循环嵌套计算（两个关联表join，关联字段均未建立索引）</td>
</tr>
</tbody>
</table>
<h2 id="profiling-分析查询"><a href="#profiling-分析查询" class="headerlink" title="profiling 分析查询"></a>profiling 分析查询</h2><ul>
<li>profiling 默认是关闭的，通过<code>select @@profiling;</code>查看是否开启，通过<code>set profiling=1;</code>开启</li>
<li>执行需要测试的 sql 语句</li>
<li><code>show profiles\G;</code> 得到被执行的 SQL 语句的时间和 ID。</li>
<li><code>show profile for query 1;</code>得到 id 为 2 的语句执行的详细信息</li>
</ul>
<h1 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h1><ul>
<li>数据表数据类型和表结构优化</li>
<li>索引优化</li>
<li>SQL语句的优化</li>
<li>存储引擎的优化</li>
<li>数据库服务器架构的优化</li>
</ul>
<h1 id="数据表数据类型和表结构优化"><a href="#数据表数据类型和表结构优化" class="headerlink" title="数据表数据类型和表结构优化"></a>数据表数据类型和表结构优化</h1><h2 id="建表原则"><a href="#建表原则" class="headerlink" title="建表原则"></a>建表原则</h2><ul>
<li>定常与变长分离</li>
<li>常用字段和不常用字段分离</li>
<li>在 1 对多，需要关联统计的字段上，添加冗余字段</li>
<li>不允许 null</li>
</ul>
<h2 id="列类型选择"><a href="#列类型选择" class="headerlink" title="列类型选择"></a>列类型选择</h2><ul>
<li>字段类型优先级 int date,time enum char varchar blob text</li>
<li>整形：定长，没有国家/地区之分，没有字符集差异，char 需要考虑字符集与校对集（排序规则）</li>
<li>enum：能起约束的目的，内部用整形存储，但与 char 联查时，内部要经历串和值的转化</li>
<li>varchar：不定长，速度慢</li>
<li>text/blob：无法使用内存临时表（排序等操作只能在磁盘上进行）</li>
<li>varchar(10) 和 varchar(300) 在表联查时花更多内存</li>
<li>尽量避免null，不利于索引，要用特殊字节标注，在磁盘占据的空间更大（mysql5.5对null做了改进）</li>
<li>ip 地址的存储，用字符串浪费空间。可以用 iptolong 函数转化为整形存储 </li>
</ul>
<h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><h2 id="索引的创建原则"><a href="#索引的创建原则" class="headerlink" title="索引的创建原则"></a>索引的创建原则</h2><ul>
<li>最适合索引的列是出现在where，on，group by，order by 子句中的列</li>
<li>尽量选择区分度高的列作为索引</li>
<li>对较小的数据列使用索引,这样会使索引文件更小,同时内存中也可以装载更多的索引键</li>
<li>索引基数越大效果越好</li>
<li>避免创建过多索引</li>
<li>主键尽可能选择较短的数据类型，可以有效减少索引的磁盘占用提高查询效率</li>
</ul>
<h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>在需要使用多个列作为条件进行查询时，使用复合索引比使用多个单列索引性能更好。</p>
<h3 id="左前缀原则"><a href="#左前缀原则" class="headerlink" title="左前缀原则"></a>左前缀原则</h3><p>原理：比如，我们在（a,b,c）字段上创建一个联合索引，则索引记录会首先按照 A 字段排序，然后再按照 B 字段排序然后再是 C 字段。类似于查字典。</p>
<pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">index</span><span class="token punctuation">(</span><span class="token number">a</span><span class="token punctuation">,</span><span class="token number">b</span><span class="token punctuation">,</span><span class="token number">c</span><span class="token punctuation">)</span>
<span class="token keyword">where</span> <span class="token number">a</span><span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> <span class="token number">b</span><span class="token operator">></span><span class="token number">7</span> <span class="token operator">and</span> <span class="token number">c</span><span class="token operator">=</span><span class="token number">2</span> <span class="token comment" spellcheck="true">//只能使用 a，b。b用了一半，无法使用到c（使用到范围查询和模糊查询后面的索引都用不到）</span>
<span class="token keyword">where</span> <span class="token number">a</span><span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> <span class="token number">b</span><span class="token operator">=</span><span class="token number">3</span> <span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token number">c</span> <span class="token comment" spellcheck="true">//都能用上</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="索引与排序"><a href="#索引与排序" class="headerlink" title="索引与排序"></a>索引与排序</h2><ul>
<li>对于覆盖索引，直接在索引上查询时，就是有序的，using index</li>
<li>在 InnoDB 引擎中，沿着索引字段排序，自然是有序的， MyISAM 引擎，如果按某索引字段排序，但取出的字段中有未索引字段的做法不是索引-&gt;回行，索引-&gt;回行，而是先取出所有行，再排序</li>
<li>group by 和 order by 同时存在，且作用于不同的字段时，先取出数据，形成临时表做 filesort</li>
</ul>
<h2 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h2><p>如果查询的列恰好是索引的一部分，那么查询只需要在索引文件上进行,不需要回到磁盘再找数据<br>如 </p>
<pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">index</span> index_birthday_and_user_name <span class="token keyword">on</span> user_info<span class="token punctuation">(</span>birthday<span class="token punctuation">,</span> user_name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> user_name <span class="token keyword">from</span> user_info <span class="token keyword">where</span> birthday <span class="token operator">=</span> <span class="token string">'1991-11-1'</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h2><ul>
<li>ASC，DESC混用</li>
<li>WHERE 字句中出现非排序使用到的索引</li>
<li>排序列包含非同一个索引的列</li>
<li>排序列使用了复杂的表达式</li>
<li>复合索引遵循左前缀原则</li>
<li>like 查询，% 在前，索引失效，可以使用全文索引</li>
<li>如果 MySQL 估计使用索引比全表扫描更慢,会放弃使用索引</li>
<li>or 条件中的列有索引，后面的没有,索引不会被用到</li>
<li>负向条件 <code>!=、&lt;&gt;、not in、not exists、not like</code> 等查询不能使用索引，可以优化为 in 查询。</li>
<li>索引列不能是表达式的一部分，也不能是函数的参数</li>
<li>建立索引的列不允许为 null，column is null 可以命中索引，is not null 不能命中。</li>
<li>列的值是字符串，查询时一定要给值加引号,否则索引失效</li>
</ul>
<h2 id="伪哈希索引"><a href="#伪哈希索引" class="headerlink" title="伪哈希索引"></a>伪哈希索引</h2><ul>
<li>同时存在 url 列 hash 列，存储时 crcurl=crc32(url)</li>
</ul>
<h2 id="索引列的顺序"><a href="#索引列的顺序" class="headerlink" title="索引列的顺序"></a>索引列的顺序</h2><p>让选择性最强的索引列放在前面。<br>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。</p>
<h2 id="对较长的字段使用前缀索引"><a href="#对较长的字段使用前缀索引" class="headerlink" title="对较长的字段使用前缀索引"></a>对较长的字段使用前缀索引</h2><p>可以节约大量索引空间<br>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。<br>对于前缀长度的选取需要根据索引选择性来确定。</p>
<h2 id="索引的使用条件"><a href="#索引的使用条件" class="headerlink" title="索引的使用条件"></a>索引的使用条件</h2><ul>
<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li>
<li>对于中到大型的表，索引就非常有效；</li>
<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>
</ul>
<h2 id="索引碎片与维护"><a href="#索引碎片与维护" class="headerlink" title="索引碎片与维护"></a>索引碎片与维护</h2><ul>
<li>在长期的数据更改过程中，索引文件和数据文件，都将产生空洞，形成碎片，可以通过一个不产生对数据实质影响的操作来修改表</li>
<li>或者使用 optimize table 也可以修复</li>
</ul>
<h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><ul>
<li>大大减少服务器需要扫描的数据量</li>
<li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表）。</li>
<li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li>
<li>大大提高查询速度，降低写的速度，占用磁盘</li>
</ul>
<h1 id="SQL语句的优化"><a href="#SQL语句的优化" class="headerlink" title="SQL语句的优化"></a>SQL语句的优化</h1><h2 id="切分大查询"><a href="#切分大查询" class="headerlink" title="切分大查询"></a>切分大查询</h2><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。<br>将一个大的查询分解成多个小的相同的查询。<br>一次性删除 1000 万的数据要比一次删除 1 万，暂停一会儿的方案更损耗服务器开销。</p>
<pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> messages <span class="token keyword">WHERE</span> <span class="token keyword">create</span> <span class="token operator">&lt;</span> DATE_SUB<span class="token punctuation">(</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> INTERVAL <span class="token number">3</span> MONTH<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//切分后</span>
rows_affected <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">do</span> {
rows_affected <span class="token operator">=</span> do_query<span class="token punctuation">(</span>
<span class="token string">"DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000"</span><span class="token punctuation">)</span>
} <span class="token keyword">while</span> rows_affected <span class="token operator">></span> <span class="token number">0</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h2><p>将一个关联查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联。</p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
<li>减少锁竞争。</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li>
<li>查询本身效率也可能会有所提升。</li>
</ul>
<h2 id="优化特定类型的查询语句"><a href="#优化特定类型的查询语句" class="headerlink" title="优化特定类型的查询语句"></a>优化特定类型的查询语句</h2><ul>
<li>count(*) 会忽略所有列，直接统计所有列数，不要使用 count(列名)。count()在查询 &lt; 时快，查询 &gt;100 时可以用总的减去 &lt;=100。</li>
<li>group by 和 distinct 可以使用索引来优化</li>
<li>如果不需要使用 order by 进行 group by 时使用 order by null，MySQL 就不会再进行文件排序</li>
<li>优化关联查询：确定 on 或者 using 子句的列上有索引，确保 group by 和 order by 中只有一个表中的列，这样 MySQl 才有可能使用索引</li>
<li>优化子查询：用关联查询替代</li>
<li>优化 limit 分页：limit 偏移量大的时候，查询效率较低。 优化方法：<ol>
<li>从业务上解决，不允许翻过 100 页</li>
<li>不用 offset，用条件查询,记录上次查询最大 ID，下次查询时直接根据 ID 查询</li>
</ol>
</li>
<li>优化 UNION 查询：UNION ALL 效率更高，会查询出重复的数据，但是可以在应用层筛选。 UNION 的子句要尽量具体，查询更少的行</li>
<li>union、in、or 都能够命中索引，建议使用 in。</li>
<li>min/max 优化</li>
<li>当只要一行数据是使用 limit 1，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据</li>
<li>为查询缓存优化，某些查询语句会让 MySQL 不使用缓存。请看下面的示例</li>
</ul>
<pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> username <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> signup_date <span class="token operator">>=</span> curdate <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> username <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> signup_date <span class="token operator">>=</span> <span class="token string">'2016-06-24'</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>上面两条SQL语句的差别就是 curdate() ，MySQL的查询缓存对这个函数不起作用。所以，像 now() 和 rand() 或是其它的诸如此类的SQL函数都不会开启查询缓存，因为这些函数的返回是会不定的易变的。所以，你所需要的就是用一个变量来代替 MySQL 的函数，从而开启缓存。</p>
<h2 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h2><ul>
<li>改变数据库和表的结构，修改数据表的范式，冗余</li>
<li>只返回必要的列：最好不要使用 SELECT * 语句。</li>
<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li>
<li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>
<li>使用索引来覆盖查询</li>
</ul>
<h1 id="数据库服务器架构的优化"><a href="#数据库服务器架构的优化" class="headerlink" title="数据库服务器架构的优化"></a>数据库服务器架构的优化</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>一主多从，主库提供写服务，从库提供读服务。</p>
<p>分组解决的是“数据库读写高并发量高”问题</p>
<h2 id="分片（水平分割）"><a href="#分片（水平分割）" class="headerlink" title="分片（水平分割）"></a>分片（水平分割）</h2><p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。<br>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p>
<h3 id="库内分表还是分库分表"><a href="#库内分表还是分库分表" class="headerlink" title="库内分表还是分库分表"></a>库内分表还是分库分表</h3><p>建议分库</p>
<ul>
<li>库内分表虽然将表拆分，但子表还是在同一个数据库实例中，只是解决了单一表数据量过大的问题，并没有将拆分后的表分布的不同机器的库上。还在竞争同一个物理机的 CPU、内存、网络 IO。</li>
<li>分库能够很容易的将数据迁移到不同数据库实例，甚至数据库机器上，扩展性更好</li>
</ul>
<h3 id="Sharding-策略"><a href="#Sharding-策略" class="headerlink" title="Sharding 策略"></a>Sharding 策略</h3><ul>
<li>哈希取模：hash(key) % N；</li>
<li>范围：可以是 ID 范围也可以是时间范围；</li>
<li>映射表：使用单独的一个数据库来存储映射关系。<br>Sharding 存在的问题：</li>
</ul>
<ol>
<li>事务问题：使用分布式事务来解决，比如 XA 接口。</li>
<li>连接：可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</li>
<li>ID 唯一性<ul>
<li>使用全局唯一 ID（GUID）</li>
<li>为每个分片指定一个 ID 范围</li>
<li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li>
</ul>
</li>
</ol>
<h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><ul>
<li>线性提升数据库写性能，需要注意的是，分组架构是不能线性提升数据库写性能的</li>
<li>降低单库数据容量</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>跨分片的事务一致性难以保证</li>
<li>给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需要 UNION 操作</li>
<li>扩容的难度和维护量较大</li>
</ul>
<h2 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h2><ul>
<li>垂直分库:垂直分库是基于业务分类的。比如分为订单 DB、支付 DB、商品 DB。</li>
<li>垂直分表:垂直分表是将一张表按列切分成多个表，通常是按照<strong>列的关系密集程度</strong>进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。例如可以把一个表中长度大且访问不频繁的字段，拆分出来创建一个单独的扩展表 <code>work_extend</code> 进行存储。</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>业务间解耦，不同业务的数据进行独立的维护、监控、扩展。</li>
<li>在高并发场景下，一定程度上缓解了数据库的压力</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>提升了开发的复杂度，由于业务的隔离性，很多表无法直接访问，必须通过接口方式聚合数据</li>
<li>分布式事务管理难度增加</li>
<li>管理冗余列，查询所有数据需要 JOIN 操作</li>
</ul>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>所有数据，逻辑上还在一个表中，但物理上，可以根据一定的规则放在不同的文件中。这是 MySQL5.1 之后支持的功能，业务代码无需改动。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>创建表时使用 partition by 子句定义每个分区存放的数据，执行查询时，优化器会根据分区定义过滤那些没有我们需要数据的分区，这样查询只需要查询所需要数据在的分区即可</p>
<h3 id="分区的使用场景"><a href="#分区的使用场景" class="headerlink" title="分区的使用场景"></a>分区的使用场景</h3><ul>
<li>表非常大，无法全部存在内存，或者只在表的最后有热点数据，其他都是历史数据</li>
<li>分区表的数据更易维护，可以对独立的分区进行独立的操作</li>
<li>分区表的数据可以分布在不同的机器上，从而高效利用资源</li>
<li>可以备份和恢复独立的分区</li>
</ul>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ul>
<li>一个表最多有 1024 个分区</li>
<li>5.1 版本中，分区表表达式必须是整数，5.5 可以使用列分区</li>
<li>分区字段中如果有主键和唯一索引列，那么主键和唯一索引列必须包含进来</li>
<li>分区表中无法使用<strong>外键</strong>索引</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li>燕十八.MySQL 优化视频</li>
<li><a href="https://juejin.im/post/5e53aa67f265da573b0da9f6" target="_blank" rel="external">面试总被问分库分表怎么办？你可以这样怼他</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651962514&amp;idx=1&amp;sn=550c48c9395b52b7ec561741e86e5ce0&amp;chksm=bd2d094e8a5a80589117a653a30d062b5760ec20f8ab9e2154a63ab782d3353d1b1da50b9bc2&amp;scene=21#wechat_redirect" target="_blank" rel="external">同一个SQL语句，为啥性能差异咋就这么大呢？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651962587&amp;idx=1&amp;sn=d197aea0090ce93b156e0774c6dc3019&amp;chksm=bd2d09078a5a801138922fb5f2b9bb7fdaace7e594d55f45ce4b3fc25cbb973bbc9b2deb2c31&amp;scene=21#wechat_redirect" target="_blank" rel="external">如何利用工具，迅猛定位低效SQL？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651963031&amp;idx=1&amp;sn=f52b724ff33ef008668ef9165c51d39b&amp;chksm=bd2d0b4b8a5a825df41252dd381d0206e141f6a54f253086030113f14584bb11612308ce8e16&amp;scene=21#wechat_redirect" target="_blank" rel="external">数据库架构设计中，最重要的“基概”！！！</a></li>
</ul>

  </article>
  <div class="random-toc-area">
  <button class="btn-hide-toc btn-hide-toc-show" style="display: none" onclick="TOCToggle()">显示目录</button>
  <button class="btn-hide-toc btn-hide-toc-hide" onclick="TOCToggle()">隐藏目录</button>
  <div class="random-toc">
    <h2>目录</h2>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#分析"><span class="toc-text">分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#排查命令"><span class="toc-text">排查命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#慢查询日志"><span class="toc-text">慢查询日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-Explain-进行分析"><span class="toc-text">使用 Explain 进行分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#profiling-分析查询"><span class="toc-text">profiling 分析查询</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#优化方向"><span class="toc-text">优化方向</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据表数据类型和表结构优化"><span class="toc-text">数据表数据类型和表结构优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#建表原则"><span class="toc-text">建表原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#列类型选择"><span class="toc-text">列类型选择</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#索引优化"><span class="toc-text">索引优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#索引的创建原则"><span class="toc-text">索引的创建原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#联合索引"><span class="toc-text">联合索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#左前缀原则"><span class="toc-text">左前缀原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引与排序"><span class="toc-text">索引与排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引覆盖"><span class="toc-text">索引覆盖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引失效的情况"><span class="toc-text">索引失效的情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#伪哈希索引"><span class="toc-text">伪哈希索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引列的顺序"><span class="toc-text">索引列的顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对较长的字段使用前缀索引"><span class="toc-text">对较长的字段使用前缀索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引的使用条件"><span class="toc-text">索引的使用条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引碎片与维护"><span class="toc-text">索引碎片与维护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引的优点"><span class="toc-text">索引的优点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SQL语句的优化"><span class="toc-text">SQL语句的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#切分大查询"><span class="toc-text">切分大查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分解关联查询"><span class="toc-text">分解关联查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优化特定类型的查询语句"><span class="toc-text">优化特定类型的查询语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优化数据访问"><span class="toc-text">优化数据访问</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据库服务器架构的优化"><span class="toc-text">数据库服务器架构的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#主从复制"><span class="toc-text">主从复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分片（水平分割）"><span class="toc-text">分片（水平分割）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#库内分表还是分库分表"><span class="toc-text">库内分表还是分库分表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sharding-策略"><span class="toc-text">Sharding 策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决的问题"><span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缺点"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垂直切分"><span class="toc-text">垂直切分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优点"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缺点-1"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分区"><span class="toc-text">分区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#工作原理"><span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分区的使用场景"><span class="toc-text">分区的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#限制"><span class="toc-text">限制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考文章"><span class="toc-text">参考文章</span></a></li></ol>
  </div>
</div>

  
<nav id="pagination">
  
    <a href="/2019/05/16/面试知识点/" class="prev">&larr; 上一篇 面试知识点</a>
  

  

  
    <a href="/2019/05/09/MySQL-基础/" class="next">下一篇 MySQL 基础 &rarr;</a>
  
</nav>

  <!-- JiaThis Button BEGIN -->

<!-- JiaThis Button END -->


      
      
    </div>
  </div>

  <div id="bottom-outer">
    <div id="bottom-inner">
      Site by Cellophane using
      <a href="http://hexo.io">Hexo</a> & <a href="https://github.com/stiekel/hexo-theme-random">Random</a>
      <br>
      
    </div>
  </div>
</div>

</div>


<div id="user-card">
  <div class="center-field">
    <img class="avatar" src="/images/me3.jpg">
    <p id="description"></p>
    <ul class="social-icon">
  
  
    <li>
      <a href="https://github.com/liuyuqi21">
        
          <i class="icon iconfont github">&#xe606;</i>
        
      </a>
    </li>
  
    <li>
      <a href="https://www.zhihu.com/people/ding-wei-33-1/activities">
        
          <i class="icon iconfont zhihu">&#xe60b;</i>
        
      </a>
    </li>
  
    <li>
      <a href="http://chensd.com">
        
          <i class="icon iconfont rss">&#xe60e;</i>
        
      </a>
    </li>
  
</ul>
  </div>
</div>


<div id="btn-view">Hide</div>

<script>
// is trigger analytics / tongji script
var isIgnoreHost = false;

if(window && window.location && window.location.host) {
  isIgnoreHost = ["localhost","127.0.0.1"].some(function(address){
    return 0 === window.location.host.indexOf(address);
  });
}

var isTriggerAnalytics = !( true && isIgnoreHost );

</script>




  
  
    <script src="/js/jquery-2.2.3.min.js"></script>
  
    <script src="/js/vegas.min.js"></script>
  
    <script src="/js/random.js"></script>
  
    <script src="/js/highlight.pack.js"></script>
  
    <script src="/js/jquery.mousewheel.pack.js"></script>
  
    <script src="/js/jquery.fancybox.pack.js"></script>
  
    <script src="/js/jquery.fancybox-thumbs.js"></script>
  
    <script src="/js/plyr.js"></script>
  
    <script src="/js/prism.js"></script>
  

<script>

  // fancybox
  var backgroundImages = [];
  
  $('#post').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox') || $(this).parent().hasClass('fancybox-thumb')) return;
      var alt = this.alt || this.title;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'post' + i);
    });
  });
  $(".fancybox").fancybox();

var vegasConfig = {"preload­Image":true,"transition":["flash"],"timer":true,"delay":1500000,"shuffle":true,"count":12};
var unsplashConfig = {"gravity":"center"};
// is show background images
var turnoffBackgroundImage = false;




var backgroundColor = "34495E";

$(".fancybox-thumb").fancybox({
  prevEffect: 'none',
  nextEffect: 'none',
  helpers: {
    title: {
      type: 'outside'
    },
    thumbs: {
      width: 50,
      height: 50
    }
  }
});

// show video with plyr
$(".video-container iframe").each(function(i){
  var url = $(this).attr('src');
  var id = url.split('/').pop();
  var plyrContainer = document.createElement('div');
  plyrContainer.className = 'plyr';
  var plyrElement = document.createElement('div');
  plyrElement.dataset.videoId = id;
  switch(true) {
    case url.search('youtube.com') >= 0:
      plyrElement.dataset.type = 'youtube';
      break;
    case url.search('vimeo.com') >= 0:
      plyrElement.dataset.type = 'vimeo';
      break;
    default:
      return;
  };
  plyrContainer.appendChild(plyrElement);
  $(this).parent().html(plyrContainer);
});
plyr.setup('.plyr', {iconUrl: '/css/sprite.svg'});
</script>
</body>
</html>

