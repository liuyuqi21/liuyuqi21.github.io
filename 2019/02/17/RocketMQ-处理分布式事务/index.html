






<!doctype html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="author" content="Cellophane">
  
  
  
  
    <meta name="description" content="在 RocketMQ 中生产者有三种角色 NormalProducer(普通)、OrderProducer(顺序)、TransactionProducer(事务)。
RocketMQ 是一种最终一致性的分布式事务。
分布式事务中，如果使用消息中间件来实现最终一致性的分布式事务，是先更新数据库再发消息还是先发消息再更新数据库，这两个操作不是原子的，无论谁先谁后都是有问题的。为了解决该问题，Ro...">
  
  <title>RocketMQ 处理分布式事务 [ Cellophane's blog ]</title>
  
  
    <link rel="shortcut icon" href="/icon.ico">
  
  
  
<link rel="stylesheet" href="/css/random.css">
<link rel="stylesheet" href="/css/vegas.min.css">
<link rel="stylesheet" href="/css/highlight-railscasts.css">
<link rel="stylesheet" href="/css/jquery.fancybox.css">
<link rel="stylesheet" href="/css/iconfont/iconfont.css">
<link rel="stylesheet" href="/css/jquery.fancybox-thumbs.css">
<link rel="stylesheet" href="/css/plyr.css">

  
<meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/css/prism-coy.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/js/prism.js"></script>
<script src="/js/prism-line-numbers.min.js"></script></head>

<body>
<div class="side-navigate hide-area">
  
    <div class="item prev">
      <a href="/2019/04/10/PHP-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">
        <div class="item-icon"></div>
      </a>
      <div class="item-title">
        PHP 基础
      </div>
    </div>
  
  
    <div class="item next">
      <a href="/2018/11/13/laravel/">
        <div class="item-icon"></div>
      </a>
      <div class="item-title">
        laravel 笔记
      </div>
    </div>
  
</div>
<div id="outer-container" class="hide-area">
<div id="container">
  <div id="menu-outer" class="slide-down">
    <div id="menu-inner">
      <div id="brand">
        
        <a onClick="openUserCard()">
          <img id="avatar" src="https://i.loli.net/2020/07/27/qrXwW2ghKUdkG9x.png"/>
          <div id="homelink">Cellophane's blog</div>
        </a>
      </div>
      <div id="menu-list">
        <ul>
        
        
          
            <li>
          
            <a href="/index.html">Home</a>
            
          </li>
        
          
            <li>
          
            <a href="/archives">Archives</a>
            
          </li>
        
          
            <li>
          
            <a href="/tags">Tags</a>
            
          </li>
        
          
            <li>
          
            <a href="/categories">Categories</a>
            
          </li>
        
          
            <li>
          
            <a href="/about">About</a>
            
          </li>
        
        </ul>
      </div>
      <div id="show-menu">
        <button>Menu</button>
      </div>
    </div>
  </div>

  <div id="content-outer">
    <div id="content-inner">
      
      
  

  <article id="post">
    <h1>RocketMQ 处理分布式事务</h1>
    <p class="page-title-sub">
      <span id = "post-title-date">Created at 2019-02-17</span>
      
        <span id = "post-title-updated">Updated at 2020-07-27</span>
      
      
      <span id = "post-title-categories">Category
      
      
        
        
        <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
      
      </span>
      
      
        <span id = "post-title-tags">
          Tag
          
          
            
            
            <a href="/tags/RocketMQ/">RocketMQ</a>
          
            
              /
            
            
            <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">分布式事务</a>
          
        </span>
      
      <span id="/2019/02/17/RocketMQ-处理分布式事务/" class="leancloud-visitors" data-flag-title="RocketMQ 处理分布式事务">
        <i class="leancloud-visitors-count"></i>
        <em class="post-meta-item-text"> views </em>
      </span>
    </p>
    
    <p>在 RocketMQ 中生产者有三种角色 NormalProducer(普通)、OrderProducer(顺序)、TransactionProducer(事务)。</p>
<p>RocketMQ 是一种<strong>最终一致性</strong>的分布式事务。</p>
<p>分布式事务中，如果使用消息中间件来实现最终一致性的分布式事务，是先更新数据库再发消息还是先发消息再更新数据库，这两个操作不是原子的，无论谁先谁后都是有问题的。为了解决该问题，RocketMQ 提出了“事务消息的概念”。</p>
<h2 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h2><p><img src="https://gitee.com/cellophane/image/raw/master/200226.jpg" alt="">发送消息时涉及两个操作：</p>
<ol>
<li>上游服务处理本地事务</li>
<li>发送消息到消息队列<br>当这两个操作有一个失败的而情况下就会出现数据不一致。所以可靠消息要将消息的状态存进数据库，后台会有一个定时运行的线程不停的检查各个消息的状态。如果一直是“待确认”状态，就可以回调上游服务提供的一个接口来查询上游服务是否执行成功。</li>
</ol>
<h3 id="为什么不能把业务处理和发送消息到-MQ-放到一个本地事务？"><a href="#为什么不能把业务处理和发送消息到-MQ-放到一个本地事务？" class="headerlink" title="为什么不能把业务处理和发送消息到 MQ 放到一个本地事务？"></a>为什么不能把业务处理和发送消息到 MQ 放到一个本地事务？</h3><p>如果本地事务处理成功，消息存储成功，MQ 处理超时，ACK 确认失败，会导致本地事务回滚。然而消息却已经发出去，下游就会消费这条消息，就会导致数据不一致。</p>
<p>RocketMQ 的事务消息，就实现了可靠消息服务的所有功能，核心思想跟上面类似。</p>
<h2 id="Half-Message-半消息"><a href="#Half-Message-半消息" class="headerlink" title="Half Message 半消息"></a>Half Message 半消息</h2><p>指暂不能被 Consumer 消费的消息。Producer 已经把消息成功发送到了 Broker 端，但此消息被标记为暂不能投递状态，处于该种状态下的消息称为半消息。需要 Producer</p>
<p>对消息的<strong>二次确认</strong>后，Consumer才能去消费它。</p>
<h3 id="为什么要先发送-Half-Message"><a href="#为什么要先发送-Half-Message" class="headerlink" title="为什么要先发送 Half Message"></a>为什么要先发送 Half Message</h3><ol>
<li>可以先确认 Brock 服务器是否正常，如果半消息都发送失败了，说明 Brock 挂了。</li>
<li>可以通过半消息来回查事务，如果半消息发送成功后一直没有被二次确认，那么就会回查事务状态。</li>
</ol>
<h2 id="消息回查"><a href="#消息回查" class="headerlink" title="消息回查"></a>消息回查</h2><p>Brock 服务器会定时扫描长期处于半消息的消息，会主动询问 Producer 端 该消息的最终状态(Commit 或者 Rollback),该消息即为消息回查。</p>
<h3 id="什么情况会会查"><a href="#什么情况会会查" class="headerlink" title="什么情况会会查"></a>什么情况会会查</h3><ol>
<li>执行本地事务的时候，由于突然网络等原因一直没有返回执行事务的结果(commit 或者 rollback)导致最终返回 UNKNOW，那么就会回查。</li>
<li>本地事务执行成功后，返回 Commit 进行消息二次确认的时候的服务挂了，在重启服务那么这个时候在 brock 端，它还是个 Half Message(半消息)，这也会回查。</li>
</ol>
<h2 id="分布式事务交互流程"><a href="#分布式事务交互流程" class="headerlink" title="分布式事务交互流程"></a>分布式事务交互流程</h2><p><img src="https://gitee.com/cellophane/image/raw/master/0217.jpg" alt="整体交互流程图"></p>
<ol>
<li>A 服务先发送个 Half Message 给 Brock 端，消息中携带 B 服务 即将要 +100 元的信息。 </li>
<li>当 A 服务知道 Half Message 发送成功后，那么开始第 3 步执行本地事务。 </li>
<li>执行本地事务(会有三种情况 1、执行成功。2、执行失败。3、网络等原因导致没有响应) </li>
<li>如果本地事务成功，那么 Product 像 Brock 服务器发送 Commit，这样 B 服务就可以消费该 message。 </li>
<li>如果本地事务失败，那么 Product 像 Brock 服务器发送 Rollback,那么就会直接删除上面这条半消息。</li>
<li>如果因为网络等原因迟迟没有返回失败还是成功，那么会执行 RocketMQ 的回调接口,来进行事务的回查。</li>
</ol>
<p>只有 A 服务本地事务执行成功，B 服务才能消费该 message。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="为什么不在业务成功之后再发送消息？"><a href="#为什么不在业务成功之后再发送消息？" class="headerlink" title="为什么不在业务成功之后再发送消息？"></a>为什么不在业务成功之后再发送消息？</h3><p>如果业务成功，再去发消息，还没来得及发送消息，业务系统就宕机了，根本没有记录之前是否发送过消息，这样就会导致业务执行成功，消息最终没发出去的情况。</p>
<h3 id="如果-consumer-消费失败，是否需要-producer-做回滚呢？"><a href="#如果-consumer-消费失败，是否需要-producer-做回滚呢？" class="headerlink" title="如果 consumer 消费失败，是否需要 producer 做回滚呢？"></a>如果 consumer 消费失败，是否需要 producer 做回滚呢？</h3><p>这里的事务消息，producer 不会因为 consumer 消费失败而做回滚，采用事务消息的应用，其所追求的是高可用和最终一致性，消息消费失败的话，MQ 自己会负责重推消息，直到消费成功。因此，事务消息是针对生产端而言的，而消费端的一致性是通过MQ的重试机制来完成的。</p>
<h3 id="如何保证下游服务的可靠接收"><a href="#如何保证下游服务的可靠接收" class="headerlink" title="如何保证下游服务的可靠接收"></a>如何保证下游服务的可靠接收</h3><ol>
<li>在可靠消息服务里开发一个后台线程，不断的检查消息状态。</li>
<li>如果消息状态一直是“已发送”，始终没有变成“已完成”，那么就说明下游服务始终没有处理成功。</li>
<li>此时可靠消息服务就可以再次尝试重新投递消息到 MQ，让下游服务来再次处理。</li>
<li>只要下游服务的接口逻辑实现<strong>幂等性</strong>，保证多次处理一个消息，不会插入重复数据即可。</li>
</ol>
<h3 id="下游服务如果处理完成后但是通知-Brocker-的过程中挂掉了怎么办"><a href="#下游服务如果处理完成后但是通知-Brocker-的过程中挂掉了怎么办" class="headerlink" title="下游服务如果处理完成后但是通知 Brocker 的过程中挂掉了怎么办"></a>下游服务如果处理完成后但是通知 Brocker 的过程中挂掉了怎么办</h3><p>可靠消息服务会启动相应的后台线程，轮询一直处于“已发送”状态的消息，判断状态持续时间是否超过了规定时间，如果超时，可靠消息服务就会再次向 MQ 服务投递此消息，从而确保消息能被再次消费处理。（注意，也可能出现下游服务处理成功，但是通知消息发送失败的情况，所以为了确保幂等，下游服务也需要在业务逻辑上做好相应的防重处理）。</p>
<h3 id="当-MQ-故障时怎么办"><a href="#当-MQ-故障时怎么办" class="headerlink" title="当 MQ 故障时怎么办"></a>当 MQ 故障时怎么办</h3><p>使用基于 KV 存储的队列支持高可用降级方案。</p>
<ol>
<li>封装 MQ 客户端组件与故障感知，连续 n 次重试尝试投递消息到 MQ 都报错，说明 MQ 故障，此时可以自动感知记忆自动触发降级开关。</li>
<li>通过 zookeeper 触发降级开关。</li>
<li>当 MQ 挂掉之后，使用 redis 的队列来代替。</li>
<li>redis 中要根据实际场景划分 n 个队列，然后通过 hash 算法，均匀写入固定好 n 个 key 对应的 kv 存储队列中。（因为只往一个 key 中写入消息会导致负载过大）</li>
<li>降级开关打开后，需要开启一个线程，每隔一段时间尝试给 MQ 投递一个消息看是否恢复了。</li>
<li>如果恢复了，zk 就可以关闭降级开关，继续往 MQ 投递消息，下游服务在确认 kv 存储的各个队列中已经没有数据之后，就可以重新切换为从 MQ 消费消息。</li>
</ol>
<h3 id="如何保证不被重复消费"><a href="#如何保证不被重复消费" class="headerlink" title="如何保证不被重复消费"></a>如何保证不被重复消费</h3><p>强校验：将 <code>id + 业务场景</code> 的唯一标识写入数据库中，将这个操作和业务操作放到同一个事务里，先用唯一标识去数据库查这条消息有没有被消费，如果没有被消费，就执行事务，被消费了就直接返回。<br>弱校验：将唯一标识作为 Redis 的 key 写入 Redis 里，就算 kv 丢了可能这样的场景也没关系，比如短信通知。</p>
<h3 id="如何保证消费的可靠性传输"><a href="#如何保证消费的可靠性传输" class="headerlink" title="如何保证消费的可靠性传输"></a>如何保证消费的可靠性传输</h3><ol>
<li>生产者丢数据</li>
<li>消息队列丢数据：开启持久化磁盘配置</li>
<li>消费者丢数据</li>
</ol>
<h3 id="如何保证顺序消费"><a href="#如何保证顺序消费" class="headerlink" title="如何保证顺序消费"></a>如何保证顺序消费</h3><p>场景：数据库主从同步，数据量过大，写入消息队列。而增删改的操作一定要是顺序的，比如增改删，变成了改删增，这样本应该被删掉的数据就还在。<br>RocketMQ 中的实现：一个 topic 下面有多个队列，为了保证发送有序，RocketMQ 提供了 MessageQueueSelector 队列选择机制。RocketMQ 的 topic内的队列机制,可以保证存储满足FIFO（First Input First Output 简单说就是指先进先出）,剩下的只需要消费者顺序消费即可。RocketMQ仅保证顺序发送，顺序消费由消费者业务保证。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.cnblogs.com/qdhxhz/p/11191399.html" target="_blank" rel="noopener">分布式事务(3)—RocketMQ实现分布式事务原理</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU3NDY4NzQwNQ==&mid=2247484545&idx=1&sn=107192bd8e5ce3e40cf01c2c598cdf67&chksm=fd2fd543ca585c55efc7032e49bedfc28abd59753b42fc99f1307561739e8ed887d9ef207261&mpshare=1&scene=1&srcid=0310aB2Xzg0FJP4newiZ0Fp0&sharer_sharetime=1583774285457&sharer_shareid=da3c4e6d38e0827ddba7900a4fab3cd4#rd" target="_blank" rel="noopener">分布式事务之如何基于RocketMQ的事务消息特性实现分布式系统的最终一致性？</a></li>
<li><a href="http://www.tianshouzhi.com/api/tutorials/distributed_transaction/389" target="_blank" rel="noopener">7.0 柔性事务：可靠消息最终一致性</a></li>
<li><a href="https://juejin.im/post/5bf2c6b6e51d456693549af4" target="_blank" rel="noopener">【坑爹呀！】最终一致性分布式事务如何保障实际生产中99.99%高可用？</a></li>
<li><a href="https://juejin.im/post/5d8882bdf265da03c9273821#heading-5" target="_blank" rel="noopener">MQ消息最终一致性解决方案</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25933039" target="_blank" rel="noopener">分布式事务？No, 最终一致性</a></li>
</ul>

  </article>
  <div class="random-toc-area">
  <button class="btn-hide-toc btn-hide-toc-show" style="display: none" onclick="TOCToggle()">Show TOC</button>
  <button class="btn-hide-toc btn-hide-toc-hide" onclick="TOCToggle()">Hide TOC</button>
  <div class="random-toc">
    <h2>Table of Content</h2>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#最终一致性"><span class="toc-text">最终一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么不能把业务处理和发送消息到-MQ-放到一个本地事务？"><span class="toc-text">为什么不能把业务处理和发送消息到 MQ 放到一个本地事务？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Half-Message-半消息"><span class="toc-text">Half Message 半消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要先发送-Half-Message"><span class="toc-text">为什么要先发送 Half Message</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息回查"><span class="toc-text">消息回查</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么情况会会查"><span class="toc-text">什么情况会会查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分布式事务交互流程"><span class="toc-text">分布式事务交互流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见问题"><span class="toc-text">常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么不在业务成功之后再发送消息？"><span class="toc-text">为什么不在业务成功之后再发送消息？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如果-consumer-消费失败，是否需要-producer-做回滚呢？"><span class="toc-text">如果 consumer 消费失败，是否需要 producer 做回滚呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何保证下游服务的可靠接收"><span class="toc-text">如何保证下游服务的可靠接收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#下游服务如果处理完成后但是通知-Brocker-的过程中挂掉了怎么办"><span class="toc-text">下游服务如果处理完成后但是通知 Brocker 的过程中挂掉了怎么办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#当-MQ-故障时怎么办"><span class="toc-text">当 MQ 故障时怎么办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何保证不被重复消费"><span class="toc-text">如何保证不被重复消费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何保证消费的可靠性传输"><span class="toc-text">如何保证消费的可靠性传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何保证顺序消费"><span class="toc-text">如何保证顺序消费</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文章"><span class="toc-text">参考文章</span></a></li></ol>
  </div>
</div>

  
  
<nav id="pagination">
  
    <a href="/2019/04/10/PHP-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="prev">&larr; Prev post PHP 基础</a>
  

  

  
    <a href="/2018/11/13/laravel/" class="next">Next post laravel 笔记 &rarr;</a>
  
</nav>

  <!-- JiaThis Button BEGIN -->

<!-- JiaThis Button END -->


      
      
    </div>
  </div>

  <div id="bottom-outer">
    <div id="bottom-inner">
      Site by Cellophane using
      <a href="http://hexo.io" target="_blank" rel="noopener">Hexo</a> & <a href="https://github.com/stiekel/hexo-theme-random" target="_blank" rel="noopener">Random</a>
      <br>
      
    </div>
  </div>
</div>

</div>


<div id="user-card">
  <div class="center-field">
    <img class="avatar" src="https://i.loli.net/2020/07/27/qrXwW2ghKUdkG9x.png">
    <p id="description"></p>
    <ul class="social-icon">
  
  
    <li>
      <a href="https://github.com/liuyuqi21" target="_blank" rel="noopener">
        
          <i class="icon iconfont github">&#xe606;</i>
        
      </a>
    </li>
  
    <li>
      <a href="823458299@qq.com">
        
          M
        
      </a>
    </li>
  
</ul>
  </div>
</div>


<div id="btn-view">Hide</div>

<script>
// is trigger analytics / tongji script
var isIgnoreHost = false;

if(window && window.location && window.location.host) {
  isIgnoreHost = ["localhost","127.0.0.1"].some(function(address){
    return 0 === window.location.host.indexOf(address);
  });
}

var isTriggerAnalytics = !( true && isIgnoreHost );

</script>




  
  
    <script src="/js/jquery-2.2.3.min.js"></script>
  
    <script src="/js/vegas.min.js"></script>
  
    <script src="/js/random.js"></script>
  
    <script src="/js/highlight.pack.js"></script>
  
    <script src="/js/jquery.mousewheel.pack.js"></script>
  
    <script src="/js/jquery.fancybox.pack.js"></script>
  
    <script src="/js/jquery.fancybox-thumbs.js"></script>
  
    <script src="/js/plyr.js"></script>
  

<script>

  // fancybox
  var backgroundImages = [];
  
  $('#post').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox') || $(this).parent().hasClass('fancybox-thumb')) return;
      var alt = this.alt || this.title;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'post' + i);
    });
  });
  $(".fancybox").fancybox();

var vegasConfig = {"preload­Image":true,"transition":["flash"],"timer":true,"delay":1500000,"shuffle":true,"count":12};
var unsplashConfig = {"gravity":"center"};
// is show background images
var turnoffBackgroundImage = false;




var backgroundColor = "34495E";

$(".fancybox-thumb").fancybox({
  prevEffect: 'none',
  nextEffect: 'none',
  helpers: {
    title: {
      type: 'outside'
    },
    thumbs: {
      width: 50,
      height: 50
    }
  }
});

// show video with plyr
$(".video-container iframe").each(function(i){
  var url = $(this).attr('src');
  var id = url.split('/').pop();
  var plyrContainer = document.createElement('div');
  plyrContainer.className = 'plyr';
  var plyrElement = document.createElement('div');
  plyrElement.dataset.videoId = id;
  switch(true) {
    case url.search('youtube.com') >= 0:
      plyrElement.dataset.type = 'youtube';
      break;
    case url.search('vimeo.com') >= 0:
      plyrElement.dataset.type = 'vimeo';
      break;
    default:
      return;
  };
  plyrContainer.appendChild(plyrElement);
  $(this).parent().html(plyrContainer);
});
plyr.setup('.plyr', {iconUrl: '/css/sprite.svg'});
</script>
</body>
</html>

