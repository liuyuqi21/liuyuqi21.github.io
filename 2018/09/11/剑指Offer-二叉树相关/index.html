






<!doctype html>
<html lang="zh-CN">
<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="author" content="Cellophane">
  
  
  
  
    <meta name="description" content="7. 重建二叉树leetcode 105
public TreeNode reConstructBinaryTree(int[] pre, int[] in)
{
    if (pre == null || in == null)
    {
        return null;
    }
    return func(pre, 0, pre.length - 1, in, 0, ...">
  
  <title>剑指Offer-二叉树相关 [ Cellophane ]</title>
  
  
    <link rel="shortcut icon" href="/Blinky.ico">
  
  
  <link rel="stylesheet" href="/css/random.css">
<link rel="stylesheet" href="/css/vegas.min.css">
<link rel="stylesheet" href="/css/jquery.fancybox.css">
<link rel="stylesheet" href="/css/iconfont/iconfont.css">
<link rel="stylesheet" href="/css/jquery.fancybox-thumbs.css">
<link rel="stylesheet" href="/css/plyr.css">
<link rel="stylesheet" href="/css/prism.css">
  
</head>

<body>
<div class="side-navigate hide-area">
  
    <div class="item prev">
      <a href="/2018/09/12/剑指Offer-数组相关/">
        <div class="item-icon"></div>
      </a>
      <div class="item-title">
        剑指Offer-数组相关
      </div>
    </div>
  
  
    <div class="item next">
      <a href="/2018/06/10/剑指Offer-链表相关/">
        <div class="item-icon"></div>
      </a>
      <div class="item-title">
        剑指Offer-链表相关
      </div>
    </div>
  
</div>
<div id="outer-container" class="hide-area">
<div id="container">
  <div id="menu-outer" class="slide-down">
    <div id="menu-inner">
      <div id="brand">
        
        <a onClick="openUserCard()">
          <img id="avatar" src="/images/me3.jpg"/>
          <div id="homelink">Cellophane</div>
        </a>
      </div>
      <div id="menu-list">
        <ul>
        
        
          
            <li>
          
            <a href="/index.html">首页</a>
            
          </li>
        
          
            <li>
          
            <a href="/archives">文章</a>
            
          </li>
        
          
            <li>
          
            <a href="/tags">标签</a>
            
          </li>
        
          
            <li>
          
            <a href="/categories">分类</a>
            
          </li>
        
        </ul>
      </div>
      <div id="show-menu">
        <button>Menu</button>
      </div>
    </div>
  </div>

  <div id="content-outer">
    <div id="content-inner">
      
      
  

  <article id="post">
    <h1>剑指Offer-二叉树相关</h1>
    <p class="page-title-sub">
      <span id = "post-title-date">撰写于 2018-09-11</span>
      
      
      <span id = "post-title-categories">分类
      
      
        
        
        <a href="/categories/算法/">算法</a>
      
      </span>
      
      
      <span id = "post-title-tags">
      标签
      
      
        
        
        <a href="/tags/面试/">面试</a>
      
        
          /
        
        
        <a href="/tags/剑指Offer/">剑指Offer</a>
      
        
          /
        
        
        <a href="/tags/算法/">算法</a>
      
      </span>
      
    </p>
    
    <h2 id="7-重建二叉树"><a href="#7-重建二叉树" class="headerlink" title="7. 重建二叉树"></a>7. 重建二叉树</h2><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="external">leetcode 105</a></p>
<pre><code class="language-java">public TreeNode reConstructBinaryTree(int[] pre, int[] in)
{
    if (pre == null || in == null)
    {
        return null;
    }
    return func(pre, 0, pre.length - 1, in, 0, in.length - 1);
}
public TreeNode func(int[] pre, int startPre, int endPre, int[] in, int startIn, int endIn)
{
    if (startPre &gt; endPre || startIn &gt; endIn)
        return null;
    TreeNode node = new TreeNode(pre[startPre]);
    for (int i = startIn; i &lt;= endIn; i++)
    {
        if (in[i] == pre[startPre])
        {
            node.left = func(pre, startPre + 1, i - startIn + startPre, in, startIn, i - 1);
            node.right = func(pre, i - startIn + startPre + 1, endPre, in, i + 1, endIn);
            break;
        }
    }

    return node;
}
</code></pre>
<h2 id="8-二叉树的下一个结点"><a href="#8-二叉树的下一个结点" class="headerlink" title="8. 二叉树的下一个结点"></a>8. 二叉树的下一个结点</h2><p><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;tqId=11210&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github" target="_blank" rel="external">牛客 二叉树的下一个结点</a></p>
<pre><code class="language-java">public TreeLinkNode GetNext(TreeLinkNode pNode) {
    if (pNode == null) {
        return null;
    }
    if (pNode.right != null) {
        pNode = pNode.right;
        while (pNode.left != null) {
            pNode = pNode.left;
        }
        return pNode;
    }
    while (pNode.next != null) {
        if (pNode.next.left == pNode) {
            return pNode.next;
        }
        pNode = pNode.next;
    }
    return null;
}
</code></pre>
<h2 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26. 树的子结构"></a>26. 树的子结构</h2><p><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" target="_blank" rel="external">leetcode 572</a></p>
<pre><code class="language-cpp">bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
{
    if (pRoot1 == nullptr || pRoot2 == nullptr) {
        return false;
    }
    bool result = false;

    if (pRoot1-&gt;val == pRoot2-&gt;val) {
        result = isSubTree(pRoot1, pRoot2);
    }
    if (!result) {
        result = HasSubtree(pRoot1-&gt;left, pRoot2);
    }
    if (!result) {
        result = HasSubtree(pRoot1-&gt;right, pRoot2);
    }
    return result;
}
bool isSubTree(TreeNode* pRoot1, TreeNode* pRoot2) {
    if (pRoot2 == nullptr) {
        return true;
    }
    if (pRoot1 == nullptr) {
        return false;
    }
    if (pRoot1-&gt;val == pRoot2-&gt;val) {
        return isSubTree(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; isSubTree(pRoot1-&gt;right, pRoot2-&gt;right);
    }
    else {
        return false;
    }
}
</code></pre>
<h2 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27. 二叉树的镜像"></a>27. 二叉树的镜像</h2><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="external">leetcode 226</a></p>
<pre><code class="language-cpp"> void Mirror(TreeNode *pRoot) {
    if (pRoot == nullptr) {
        return;
    }
    if (pRoot-&gt;left) {
        Mirror(pRoot-&gt;left);
    }
    if (pRoot-&gt;right) {
        Mirror(pRoot-&gt;right);
    }
    TreeNode* p = pRoot-&gt;left;
    pRoot-&gt;left = pRoot-&gt;right;
    pRoot-&gt;right = p;
}
</code></pre>
<h2 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28. 对称的二叉树"></a>28. 对称的二叉树</h2><p><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="external">leetcode 101</a></p>
<pre><code class="language-cpp">bool isSymmetrical(TreeNode*pRoot) {
    if (pRoot == nullptr) {
        return true;
    }
    return isSymmetrical(pRoot -&gt; left, pRoot -&gt; right);
}
bool isSymmetrical(TreeNode*p1, TreeNode*p2) {
    if (p1 == nullptr)
        return p1 == p2;
    if (p2 == nullptr)
        return false;
    if (p1 -&gt; val != p2 -&gt; val)
        return false;
    return isSymmetrical(p1 -&gt; left, p2 -&gt; right) &amp;&amp; isSymmetrical(p1 -&gt; right, p2 -&gt; left);
}
</code></pre>
<h2 id="32-1-从上往下打印二叉树"><a href="#32-1-从上往下打印二叉树" class="headerlink" title="32.1 从上往下打印二叉树"></a>32.1 从上往下打印二叉树</h2><pre><code class="language-cpp">vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) {
    vector&lt;int&gt; list;
    if (root==nullptr) {
        return list;
    }
    queue&lt;TreeNode*&gt; nodes;
    nodes.push(root);
    while (nodes.size()) {
        TreeNode* p = nodes.front();
        list.push_back(p-&gt;val);
        nodes.pop();
        if (p-&gt;left) {
            nodes.push(p-&gt;left);
        }
        if (p-&gt;right) {
            nodes.push(p-&gt;right);
        }
    }
    return list;
}
</code></pre>
<h2 id="32-2-分行从上到下打印二叉树"><a href="#32-2-分行从上到下打印二叉树" class="headerlink" title="32.2 分行从上到下打印二叉树"></a>32.2 分行从上到下打印二叉树</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal" target="_blank" rel="external">leetcode 102</a></p>
<pre><code class="language-cpp">vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) {
        vector&lt;vector&lt;int&gt;&gt; print;
        if (pRoot == nullptr) {
            return print;
        }
        vector&lt;int&gt; line;
        queue&lt;TreeNode*&gt; nodes;
        nodes.push(pRoot);
        while (nodes.size()) {
            int size = nodes.size();
            while (size != 0) {
                TreeNode* p = nodes.front();
                line.push_back(p-&gt;val);
                nodes.pop();
                size--;
                if (p-&gt;left) {
                    nodes.push(p-&gt;left);
                }
                if (p-&gt;right) {
                    nodes.push(p-&gt;right);
                }
            }
            print.push_back(line);
            line.clear();
        }
        return print;
    }
</code></pre>
<h3 id="用两个队列"><a href="#用两个队列" class="headerlink" title="用两个队列"></a>用两个队列</h3><pre><code class="language-cpp">vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) {
    vector&lt;vector&lt;int&gt; &gt; res;
    if (pRoot == nullptr) {
        return res;
    }
    queue&lt;TreeNode*&gt; q1;
    queue&lt;TreeNode*&gt; q2;
    vector&lt;int&gt; line;
    q1.push(pRoot);
    while (q1.size() || q2.size()) {
        while (q1.size()) {
            TreeNode* top = q1.front();
            if (top-&gt;left) {
                q2.push(top-&gt;left);
            }
            if (top-&gt;right) {
                q2.push(top-&gt;right);
            }
            line.push_back(top-&gt;val);
            q1.pop();
        }
        if (line.size())
            res.push_back(line);
        line.clear();
        while (q2.size()) {
            TreeNode* top = q2.front();
            if (top-&gt;left) {
                q1.push(top-&gt;left);
            }
            if (top-&gt;right) {
                q1.push(top-&gt;right);
            }
            line.push_back(top-&gt;val);
            q2.pop();
        }
        if (line.size())
            res.push_back(line);
        line.clear();
    }
    return res;
}
</code></pre>
<h2 id="32-3-之字形打印二叉树"><a href="#32-3-之字形打印二叉树" class="headerlink" title="32.3 之字形打印二叉树"></a>32.3 之字形打印二叉树</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/comments/" target="_blank" rel="external">leetcode 103</a></p>
<h3 id="使用两个栈"><a href="#使用两个栈" class="headerlink" title="使用两个栈"></a>使用两个栈</h3><pre><code class="language-cpp">vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) {
    vector&lt;vector&lt;int&gt;&gt; res;
    if (pRoot == nullptr) {
        return res;
    }
    stack&lt;TreeNode*&gt; s1;
    stack&lt;TreeNode*&gt; s2;
    vector&lt;int&gt; line;
    s1.push(pRoot);
    while (s1.size() || s2.size()) {

        while (s1.size()) {
            TreeNode* p = s1.top();
            if (p-&gt;left) {
                s2.push(p-&gt;left);
            }
            if (p-&gt;right) {
                s2.push(p-&gt;right);
            }
            line.push_back(p-&gt;val);
            s1.pop();
        }
        if (line.size());
        res.push_back(line);
        line.clear();
        while (s2.size()) {
            TreeNode* p = s2.top();
            if (p-&gt;right) {
                s1.push(p-&gt;right);
            }
            if (p-&gt;left) {
                s1.push(p-&gt;left);
            }
            line.push_back(p-&gt;val);
            s2.pop();
        }
        if (line.size())
            res.push_back(line);
        line.clear();
    }
    return res;
}
</code></pre>
<h3 id="使用一个双向队列"><a href="#使用一个双向队列" class="headerlink" title="使用一个双向队列"></a>使用一个双向队列</h3><pre><code class="language-java">public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) {
    List&lt;List&lt;Integer&gt;&gt; ret = new LinkedList&lt;&gt;();
    if (root == null)
        return ret;
    LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.push(root);
    boolean startLeft = true;
    while (!queue.isEmpty()) {
        int size = queue.size();
        List&lt;Integer&gt; level = new LinkedList&lt;&gt;();
        for (int i = 0; i &lt; size; i++) {
            TreeNode n = queue.removeLast();
            if (n.left != null)
                queue.push(n.left);
            if (n.right != null)
                queue.push(n.right);
            if (startLeft)
                level.add(n.val);
            else
                level.add(0, n.val);
        }
        ret.add(level);
        startLeft = !startLeft;
    }
    return ret;
}
</code></pre>
<h2 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33. 二叉搜索树的后序遍历序列"></a>33. 二叉搜索树的后序遍历序列</h2><p><a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&amp;tqId=11176&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github" target="_blank" rel="external">牛客 二叉搜索树的后序遍历序列</a></p>
<pre><code class="language-cpp">bool VerifySquenceOfBST(vector&lt;int&gt; sequence) {
    if(sequence.size() == 0){
        return false;
    }
    if(sequence.size() == 1){
        return true;
    }
    return Verify(sequence,0,sequence.size()-1);
}
bool Verify(vector&lt;int&gt; sequence,int l,int r){
    if(l &gt;= r){
        return true;
    }
    int i = l;
    while(sequence[i] &lt; sequence[r]){
        i++;
    }
    for(int j=i;j&lt;r;j++){
        if(sequence[j] &lt; sequence[r]){
            return false;
        }
    }
    return Verify(sequence,l,i-1) &amp;&amp; Verify(sequence,i,r-1);
}
</code></pre>
<h2 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34. 二叉树中和为某一值的路径"></a>34. 二叉树中和为某一值的路径</h2><p><a href="https://leetcode-cn.com/problems/path-sum-ii/submissions/" target="_blank" rel="external">leetcode 113</a></p>
<pre><code class="language-cpp">
vector&lt;vector&lt;int&gt;&gt; ret;
vector&lt;int&gt; trace;
vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) {
    if(root){
        path(root,expectNumber);
    }
    return ret;
}
void path(TreeNode* root, int expectNumber) {
    trace.push_back(root-&gt;val);
    if (root-&gt;val == expectNumber&amp;&amp;root-&gt;left == nullptr&amp;root-&gt;right == nullptr) {
        ret.push_back(trace);
    }
    else {
        if (root-&gt;left) {
            path(root-&gt;left, expectNumber - root-&gt;val);
        }
        if (root-&gt;right) {
            path(root-&gt;right, expectNumber - root-&gt;val);
        }
    }
    trace.pop_back();
}
</code></pre>
<p>扩展：<a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="external">leetcode 437</a></p>
<h2 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36. 二叉搜索树与双向链表"></a>36. 二叉搜索树与双向链表</h2><pre><code class="language-cpp">TreeNode* last = nullptr;
TreeNode* Convert(TreeNode*pRootOfTree) {
    if (pRootOfTree == nullptr) {
        return nullptr;
    }
    convertHelper(pRootOfTree);
    while (last != nullptr &amp;&amp; last -&gt; left != nullptr) {
        last = last -&gt; left;
    }
    return last;
}
void convertHelper(TreeNode*pNode) {
    if (pNode == nullptr) {
        return;
    }
    if (pNode -&gt; left) {
        convertHelper(pNode -&gt; left);
    }
    pNode -&gt; left = last;
    if (last != nullptr) {
        last -&gt; right = pNode;
    }
    last = pNode;
    if (pNode -&gt; right) {
        convertHelper(pNode -&gt; right);
    }
}
</code></pre>
<p>相关题目：</p>
<ul>
<li>有序链表转换二叉搜索树 <a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="external">leetcode 109</a></li>
<li>二叉树展开为链表 <a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/comments/" target="_blank" rel="external">leetcode 114</a></li>
</ul>
<h2 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37. 序列化二叉树"></a>37. 序列化二叉树</h2><p><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="external">leetcode 297</a></p>
<pre><code class="language-java">public String serialize(TreeNode root) {
    StringBuilder res = strHelp(root, new StringBuilder());
    return res.toString();
}
public StringBuilder strHelp(TreeNode root, StringBuilder str) {
    if (root == null) {
        str.append(&quot;#,&quot;);
        return str;
    }
    str.append(root.val);
    str.append(&quot;,&quot;);
    strHelp(root.left, str);
    strHelp(root.right, str);
    return str;
}
public TreeNode deserialize(String data) {
    String[] strWord = data.split(&quot;,&quot;);
    Deque&lt;String&gt; listWord = new LinkedList&lt;&gt;(Arrays.asList(strWord));
    return deserHelp(listWord);
}
public TreeNode deserHelp(Deque&lt;String&gt; deque) {
    if (deque.peek().equals(&quot;#&quot;)) {
        deque.pop();
        return null;
    }
    TreeNode res = new TreeNode(Integer.valueOf(deque.pop()));
    res.left = deserHelp(deque);
    res.right = deserHelp(deque);
    return res;
}
</code></pre>
<p>相关题目：</p>
<ul>
<li>先序遍历构造二叉树 <a href="https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/" target="_blank" rel="external">leetcode 1008</a></li>
<li>序列化和反序列化二叉搜索树 <a href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst/comments/" target="_blank" rel="external">leetcode 449</a></li>
</ul>
<h2 id="54-二叉搜索树的第K大节点"><a href="#54-二叉搜索树的第K大节点" class="headerlink" title="54. 二叉搜索树的第K大节点"></a>54. 二叉搜索树的第K大节点</h2><p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst" target="_blank" rel="external">leetcode 230</a></p>
<pre><code class="language-cpp">TreeNode* ret = nullptr;
int cnt = 0;
TreeNode* KthNode(TreeNode* pRoot, int k){
    inOrder(pRoot, k);
    return ret;
}
void inOrder(TreeNode* pRoot, int k) {
    if (pRoot == nullptr || k &lt;= 0) {
        return;
    }
    inOrder(pRoot-&gt;left, k);
    cnt++;
    if (cnt == k)
        ret = pRoot;
    inOrder(pRoot-&gt;right, k);
}
</code></pre>
<h2 id="55-1-二叉树的深度"><a href="#55-1-二叉树的深度" class="headerlink" title="55.1 二叉树的深度"></a>55.1 二叉树的深度</h2><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/submissions/" target="_blank" rel="external">leetcode 104</a></p>
<pre><code class="language-cpp">int TreeDepth(TreeNode* pRoot) {
    if (pRoot == nullptr) {
        return 0;
    }
    int left = TreeDepth(pRoot-&gt;left);
    int right = TreeDepth(pRoot-&gt;right);
    return (left &gt; right) ? (left + 1) : (right + 1);
}
</code></pre>
<h2 id="55-2-平衡二叉树"><a href="#55-2-平衡二叉树" class="headerlink" title="55.2 平衡二叉树"></a>55.2 平衡二叉树</h2><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="external">leetcode 110</a></p>
<pre><code class="language-`cpp">bool res = true;
bool IsBalanced_Solution(TreeNode *pRoot)
{
    isBalance(pRoot);
    return res;
}
int isBalance(TreeNode *pRoot)
{
    if (pRoot == nullptr)
    {
        return 0;
    }
    int left = isBalance(pRoot-&gt;left);
    int right = isBalance(pRoot-&gt;right);
    int diff = left - right;
    if (diff &gt; 1 || diff &lt; -1)
    {
        res = false;
    }
    return left &gt; right ? left + 1 : right + 1;
}
</code></pre>
<h2 id="69-树中两个节点的最低公共祖先"><a href="#69-树中两个节点的最低公共祖先" class="headerlink" title="69. 树中两个节点的最低公共祖先"></a>69. 树中两个节点的最低公共祖先</h2><h3 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h3><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="external">leetocde 235</a></p>
<pre><code class="language-java">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || p == root || q == root) {
        return root;
    }
    while (root != null) {
        if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) {
            root = root.left;
        } else if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) {
            root = root.right;
        } else {
            return root;
        }
    }
    return null;
}
</code></pre>
<h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h3><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="external">leetcode 236</a></p>
<pre><code class="language-java">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q) {
        return root;
    }
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    if (left == null) {
        return right;
    }
    if (right == null) {
        return left;
    }
    return root;
}
</code></pre>

  </article>
  <div class="random-toc-area">
  <button class="btn-hide-toc btn-hide-toc-show" style="display: none" onclick="TOCToggle()">显示目录</button>
  <button class="btn-hide-toc btn-hide-toc-hide" onclick="TOCToggle()">隐藏目录</button>
  <div class="random-toc">
    <h2>目录</h2>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-重建二叉树"><span class="toc-text">7. 重建二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-二叉树的下一个结点"><span class="toc-text">8. 二叉树的下一个结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-树的子结构"><span class="toc-text">26. 树的子结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-二叉树的镜像"><span class="toc-text">27. 二叉树的镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-对称的二叉树"><span class="toc-text">28. 对称的二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-1-从上往下打印二叉树"><span class="toc-text">32.1 从上往下打印二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-2-分行从上到下打印二叉树"><span class="toc-text">32.2 分行从上到下打印二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用两个队列"><span class="toc-text">用两个队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-3-之字形打印二叉树"><span class="toc-text">32.3 之字形打印二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用两个栈"><span class="toc-text">使用两个栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用一个双向队列"><span class="toc-text">使用一个双向队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-二叉搜索树的后序遍历序列"><span class="toc-text">33. 二叉搜索树的后序遍历序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-二叉树中和为某一值的路径"><span class="toc-text">34. 二叉树中和为某一值的路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-二叉搜索树与双向链表"><span class="toc-text">36. 二叉搜索树与双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-序列化二叉树"><span class="toc-text">37. 序列化二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-二叉搜索树的第K大节点"><span class="toc-text">54. 二叉搜索树的第K大节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-1-二叉树的深度"><span class="toc-text">55.1 二叉树的深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-2-平衡二叉树"><span class="toc-text">55.2 平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#69-树中两个节点的最低公共祖先"><span class="toc-text">69. 树中两个节点的最低公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉搜索树的最近公共祖先"><span class="toc-text">二叉搜索树的最近公共祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的最近公共祖先"><span class="toc-text">二叉树的最近公共祖先</span></a></li></ol></li></ol>
  </div>
</div>

  
<nav id="pagination">
  
    <a href="/2018/09/12/剑指Offer-数组相关/" class="prev">&larr; 上一篇 剑指Offer-数组相关</a>
  

  

  
    <a href="/2018/06/10/剑指Offer-链表相关/" class="next">下一篇 剑指Offer-链表相关 &rarr;</a>
  
</nav>

  <!-- JiaThis Button BEGIN -->

<!-- JiaThis Button END -->


      
      
    </div>
  </div>

  <div id="bottom-outer">
    <div id="bottom-inner">
      Site by Cellophane using
      <a href="http://hexo.io">Hexo</a> & <a href="https://github.com/stiekel/hexo-theme-random">Random</a>
      <br>
      
    </div>
  </div>
</div>

</div>


<div id="user-card">
  <div class="center-field">
    <img class="avatar" src="/images/me3.jpg">
    <p id="description"></p>
    <ul class="social-icon">
  
  
    <li>
      <a href="https://github.com/liuyuqi21">
        
          <i class="icon iconfont github">&#xe606;</i>
        
      </a>
    </li>
  
    <li>
      <a href="https://www.zhihu.com/people/ding-wei-33-1/activities">
        
          <i class="icon iconfont zhihu">&#xe60b;</i>
        
      </a>
    </li>
  
    <li>
      <a href="http://chensd.com">
        
          <i class="icon iconfont rss">&#xe60e;</i>
        
      </a>
    </li>
  
</ul>
  </div>
</div>


<div id="btn-view">Hide</div>

<script>
// is trigger analytics / tongji script
var isIgnoreHost = false;

if(window && window.location && window.location.host) {
  isIgnoreHost = ["localhost","127.0.0.1"].some(function(address){
    return 0 === window.location.host.indexOf(address);
  });
}

var isTriggerAnalytics = !( true && isIgnoreHost );

</script>




  
  
    <script src="/js/jquery-2.2.3.min.js"></script>
  
    <script src="/js/vegas.min.js"></script>
  
    <script src="/js/random.js"></script>
  
    <script src="/js/jquery.mousewheel.pack.js"></script>
  
    <script src="/js/jquery.fancybox.pack.js"></script>
  
    <script src="/js/jquery.fancybox-thumbs.js"></script>
  
    <script src="/js/plyr.js"></script>
  
    <script src="/js/prism.js"></script>
  

<script>

  // fancybox
  var backgroundImages = [];
  
  $('#post').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox') || $(this).parent().hasClass('fancybox-thumb')) return;
      var alt = this.alt || this.title;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'post' + i);
    });
  });
  $(".fancybox").fancybox();

var vegasConfig = {"preload­Image":true,"transition":["flash"],"timer":true,"delay":1500000,"shuffle":true,"count":12};
var unsplashConfig = {"gravity":"center"};
// is show background images
var turnoffBackgroundImage = false;




var backgroundColor = "34495E";

$(".fancybox-thumb").fancybox({
  prevEffect: 'none',
  nextEffect: 'none',
  helpers: {
    title: {
      type: 'outside'
    },
    thumbs: {
      width: 50,
      height: 50
    }
  }
});

// show video with plyr
$(".video-container iframe").each(function(i){
  var url = $(this).attr('src');
  var id = url.split('/').pop();
  var plyrContainer = document.createElement('div');
  plyrContainer.className = 'plyr';
  var plyrElement = document.createElement('div');
  plyrElement.dataset.videoId = id;
  switch(true) {
    case url.search('youtube.com') >= 0:
      plyrElement.dataset.type = 'youtube';
      break;
    case url.search('vimeo.com') >= 0:
      plyrElement.dataset.type = 'vimeo';
      break;
    default:
      return;
  };
  plyrContainer.appendChild(plyrElement);
  $(this).parent().html(plyrContainer);
});
plyr.setup('.plyr', {iconUrl: '/css/sprite.svg'});
</script>
</body>
</html>

