






<!doctype html>
<html lang="zh-CN">
<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="author" content="Cellophane">
  
  
  
  
    <meta name="description" content="链表6. 从尾到头打印链表使用栈vector&lt;int&gt; printListFromTailToHead(ListNode *head){
    vector&lt;int&gt; list;
    stack&lt;ListNode *&gt; s;
    while (head != nullptr){
        s.push(head);
        head...">
  
  <title>剑指Offer-链表相关 [ Cellophane ]</title>
  
  
    <link rel="shortcut icon" href="/Blinky.ico">
  
  
  <link rel="stylesheet" href="/css/random.css">
<link rel="stylesheet" href="/css/vegas.min.css">
<link rel="stylesheet" href="/css/jquery.fancybox.css">
<link rel="stylesheet" href="/css/iconfont/iconfont.css">
<link rel="stylesheet" href="/css/jquery.fancybox-thumbs.css">
<link rel="stylesheet" href="/css/plyr.css">
<link rel="stylesheet" href="/css/prism.css">
  
</head>

<body>
<div class="side-navigate hide-area">
  
    <div class="item prev">
      <a href="/2018/09/11/剑指Offer-二叉树相关/">
        <div class="item-icon"></div>
      </a>
      <div class="item-title">
        剑指Offer-二叉树相关
      </div>
    </div>
  
  
    <div class="item next">
      <a href="/2017/11/27/chrome插件推荐/">
        <div class="item-icon"></div>
      </a>
      <div class="item-title">
        chrome插件推荐
      </div>
    </div>
  
</div>
<div id="outer-container" class="hide-area">
<div id="container">
  <div id="menu-outer" class="slide-down">
    <div id="menu-inner">
      <div id="brand">
        
        <a onClick="openUserCard()">
          <img id="avatar" src="/images/me3.jpg"/>
          <div id="homelink">Cellophane</div>
        </a>
      </div>
      <div id="menu-list">
        <ul>
        
        
          
            <li>
          
            <a href="/index.html">首页</a>
            
          </li>
        
          
            <li>
          
            <a href="/archives">文章</a>
            
          </li>
        
          
            <li>
          
            <a href="/tags">标签</a>
            
          </li>
        
          
            <li>
          
            <a href="/categories">分类</a>
            
          </li>
        
        </ul>
      </div>
      <div id="show-menu">
        <button>Menu</button>
      </div>
    </div>
  </div>

  <div id="content-outer">
    <div id="content-inner">
      
      
  

  <article id="post">
    <h1>剑指Offer-链表相关</h1>
    <p class="page-title-sub">
      <span id = "post-title-date">撰写于 2018-06-10</span>
      
      
      <span id = "post-title-categories">分类
      
      
        
        
        <a href="/categories/算法/">算法</a>
      
      </span>
      
      
      <span id = "post-title-tags">
      标签
      
      
        
        
        <a href="/tags/面试/">面试</a>
      
        
          /
        
        
        <a href="/tags/剑指Offer/">剑指Offer</a>
      
        
          /
        
        
        <a href="/tags/算法/">算法</a>
      
      </span>
      
    </p>
    
    <h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="6-从尾到头打印链表"><a href="#6-从尾到头打印链表" class="headerlink" title="6. 从尾到头打印链表"></a>6. 从尾到头打印链表</h2><h3 id="使用栈"><a href="#使用栈" class="headerlink" title="使用栈"></a>使用栈</h3><pre><code class="language-cpp">vector&lt;int&gt; printListFromTailToHead(ListNode *head){
    vector&lt;int&gt; list;
    stack&lt;ListNode *&gt; s;
    while (head != nullptr){
        s.push(head);
        head = head-&gt;next;
    }
    while (!s.empty()){
        ListNode *node;
        node = s.top();
        list.push_back(node-&gt;val);
        s.pop();
    }
    return list;
}
</code></pre>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><pre><code class="language-cpp">vector&lt;int&gt; printListFromTailToHead(ListNode *head){
    vector&lt;int&gt; list;
    if (head != nullptr){
        list = printListFromTailToHead(head-&gt;next);
        list.push_back(head-&gt;val);
    }

    return list;
}
</code></pre>
<h2 id="18-1-删除链表的节点"><a href="#18-1-删除链表的节点" class="headerlink" title="18.1 删除链表的节点"></a>18.1 删除链表的节点</h2><pre><code class="language-cpp">void DeleteNode(ListNode **pListHead, ListNode *pToBeDeleted) {
    if (pListHead == nullptr || pToBeDeleted == nullptr) {
        return;
    }
    if (pToBeDeleted-&gt;next != nullptr) {
        pToBeDeleted-&gt;val = pToBeDeleted-&gt;next-&gt;val;
        pToBeDeleted-&gt;next = pToBeDeleted-&gt;next-&gt;next;
    }
    else if (*pListHead==pToBeDeleted) {
        delete pToBeDeleted;
        pToBeDeleted = nullptr;
        *pListHead = nullptr;
    }
    else {
        ListNode *pNode = *pListHead;
        while (pNode-&gt;next != pToBeDeleted) {
            pNode = pNode-&gt;next;
        }
        pNode-&gt;next = nullptr;
        delete pToBeDeleted;
        pToBeDeleted = nullptr;
    }
}
</code></pre>
<h2 id="18-2-删除链表中重复的节点"><a href="#18-2-删除链表中重复的节点" class="headerlink" title="18.2 删除链表中重复的节点"></a>18.2 删除链表中重复的节点</h2><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii" target="_blank" rel="external">leetcode 82</a></p>
<h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><pre><code class="language-cpp">ListNode* deleteDuplication(ListNode* pHead){
    if(pHead==nullptr||pHead-&gt;next==nullptr){
        return pHead;
    }
    ListNode* next=pHead-&gt;next;
    if(pHead-&gt;val==next-&gt;val){
        while(next!=nullptr&amp;&amp;pHead-&gt;val==next-&gt;val){
             next=next-&gt;next;
        }
        return deleteDuplication(next);
    }else{
        pHead-&gt;next=deleteDuplication(pHead-&gt;next);
        return pHead;
    }
}
</code></pre>
<h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><pre><code class="language-cpp">ListNode *deleteDuplication(ListNode *pHead)
{
    if (pHead == nullptr || pHead-&gt;next == nullptr)
    {
        return pHead;
    }
    ListNode *newHead = new ListNode(-1);
    newHead-&gt;next = pHead;
    ListNode *pNode = pHead;
    ListNode *preNode = newHead;
    while (pNode != nullptr)
    {
        ListNode *pNext = pNode-&gt;next;
        if (pNext != nullptr &amp;&amp; pNext-&gt;val == pNode-&gt;val)
        {
            int value = pNode-&gt;val;
            while (pNode != nullptr &amp;&amp; pNode-&gt;val == value)
            {
                pNode = pNode-&gt;next;
            }
            preNode-&gt;next = pNode;
        }
        else
        {
            preNode = pNode;
            pNode = pNode-&gt;next;
        }
    }
    return newHead-&gt;next;
}
</code></pre>
<h2 id="22-链表中倒数第k个节点"><a href="#22-链表中倒数第k个节点" class="headerlink" title="22. 链表中倒数第k个节点"></a>22. 链表中倒数第k个节点</h2><pre><code class="language-cpp">ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) {
    if (pListHead == nullptr || k == 0) {
        return nullptr;
    }
    ListNode* first = pListHead;
    ListNode* second = pListHead;
    for (int i = 0; i &lt; k - 1; i++) {
        if (second-&gt;next != nullptr) {
            second = second-&gt;next;
        }
        else {
            return nullptr;
        }
    }
    while (second-&gt;next != nullptr) {
        first = first-&gt;next;
        second = second-&gt;next;
    }
    return first;
}
</code></pre>
<h2 id="23-链表中环的入口节点"><a href="#23-链表中环的入口节点" class="headerlink" title="23. 链表中环的入口节点"></a>23. 链表中环的入口节点</h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="external">leetcode 142</a></p>
<pre><code class="language-java">public ListNode detectCycle(ListNode head) {
    if(head==null||head.next==null||head.next.next==null){
        return null;
    }
    ListNode fast=head.next.next;
    ListNode slow=head.next;

    while(fast!=slow){
        if(fast.next!=null&amp;&amp;fast.next.next!=null){
            fast=fast.next.next;
            slow=slow.next;
        }else{
            return null;
        }
    }
    fast=head;
    while(fast!=slow){
        fast=fast.next;
        slow=slow.next;
    }

    return slow;
}
</code></pre>
<p>扩展：<a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="external">leetcode 287</a></p>
<h2 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24. 反转链表"></a>24. 反转链表</h2><p><a href="https://leetcode-cn.com/problems/reverse-linked-list" target="_blank" rel="external">leetcode 206</a></p>
<pre><code class="language-cpp">ListNode* ReverseList(ListNode* pHead) {
       if (pHead == nullptr) {
              return nullptr;
       }
       ListNode* pre = nullptr;
       ListNode* next;
       ListNode* pNode = pHead;
       while (pNode!=nullptr) {
              next = pNode-&gt;next;
              pNode-&gt;next = pre;
              pre = pNode;
              pNode = next;
       }
       return pre;
}
</code></pre>
<h2 id="25-合并两个排序链表"><a href="#25-合并两个排序链表" class="headerlink" title="25. 合并两个排序链表"></a>25. 合并两个排序链表</h2><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="external">leetcode 21</a></p>
<h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><pre><code class="language-cpp">ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
{
       if (!pHead1) {
              return pHead2;
       }else if (!pHead2) {
              return pHead1;
       }
       ListNode* pHead = nullptr;
       if (pHead1-&gt;val &lt; pHead2-&gt;val) {
              pHead = pHead1;
              pHead-&gt;next = Merge(pHead1-&gt;next, pHead2);
       }
       else {
              pHead = pHead2;
              pHead-&gt;next = Merge(pHead1, pHead2-&gt;next);
       }
       return pHead;
}
</code></pre>
<h3 id="非递归-1"><a href="#非递归-1" class="headerlink" title="非递归"></a>非递归</h3><pre><code class="language-cpp">ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
{
    if (pHead1 == nullptr) {
        return pHead2;
    }
    if (pHead2 == nullptr) {
        return pHead1;
    }
    ListNode* newHead;
    if (pHead1-&gt;val &lt; pHead2-&gt;val) {
        newHead = pHead1;
        pHead1 = pHead1-&gt;next;
    }
    else {
        newHead = pHead2;
        pHead2 = pHead2-&gt;next;
    }
    ListNode* node = newHead;
    while (pHead1 != nullptr &amp;&amp; pHead2 != nullptr) {
        if (pHead1-&gt;val &lt; pHead2-&gt;val) {
            node-&gt;next = pHead1;
            pHead1 = pHead1-&gt;next;
        }
        else {
            node-&gt;next = pHead2;
            pHead2 = pHead2-&gt;next;
        }
        node = node-&gt;next;
    }
    if (pHead1 != nullptr) {
        node-&gt;next = pHead1;
    }
    if (pHead2 != nullptr) {
        node-&gt;next = pHead2;
    }
    return newHead;
}
</code></pre>
<h2 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35. 复杂链表的复制"></a>35. 复杂链表的复制</h2><pre><code class="language-cpp">RandomListNode* Clone(RandomListNode* pHead)
    {
        if (pHead == nullptr)
            return nullptr;
        //插入新节点
        RandomListNode* cur = pHead;
        while (cur != nullptr) {
            RandomListNode* clone = new RandomListNode(cur-&gt;label);
            clone-&gt;next = cur-&gt;next;
            cur-&gt;next = clone;
            cur = clone-&gt;next;
        }
        //建立 random 链接
        cur = pHead;
        while (cur != nullptr) {
            RandomListNode* clone = cur-&gt;next;
            if (cur-&gt;random != nullptr)
                clone-&gt;random = cur-&gt;random-&gt;next;
            cur = clone-&gt;next;
        }
        //拆分
        cur = pHead;
        RandomListNode* pCloneHead = pHead-&gt;next;
        while (cur-&gt;next != nullptr) {
            RandomListNode* next = cur-&gt;next;
            cur-&gt;next = next-&gt;next;
            cur = next;
        }
        return pCloneHead;
    }
</code></pre>
<h2 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52. 两个链表的第一个公共节点"></a>52. 两个链表的第一个公共节点</h2><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists" target="_blank" rel="external">leetcode 160</a></p>
<pre><code class="language-cpp">ListNode* FindFirstCommonNode(ListNode* pHead1, ListNode* pHead2) {
       if (pHead1 == nullptr || pHead2 == nullptr) {
              return nullptr;
       }
       int l1 = getLength(pHead1);
       int l2 = getLength(pHead2);
       int diff;
       if (l1 &gt; l2) {
              diff = l1 - l2;
              for (int i = 0; i &lt; diff; i++) {
                     pHead1 = pHead1-&gt;next;
              }      
       }
       else {
              diff = l2 - l1;
              for (int i = 0; i &lt; diff; i++) {
                     pHead2 = pHead2-&gt;next;
              }
       }
       while (pHead1 != nullptr&amp;&amp;pHead2 != nullptr&amp;&amp;pHead1-&gt;val != pHead2-&gt;val) {
              pHead1 = pHead1-&gt;next;
              pHead2 = pHead2-&gt;next;
       }
       return pHead1;
}
int getLength(ListNode* pHead) {
       int count = 0;
       while (pHead != nullptr) {
              count++;
              pHead = pHead-&gt;next;
       }
       return count;
}
</code></pre>
<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="9-用两个栈实现队列"><a href="#9-用两个栈实现队列" class="headerlink" title="9. 用两个栈实现队列"></a>9. 用两个栈实现队列</h2><pre><code class="language-cpp">void push(int node)
    {
        stack1.push(node);
    }

    int pop()
    {
        if (stack2.size() == 0)
        {
            while (stack1.size())
            {
                int node = stack1.top();
                stack2.push(node);
                stack1.pop();
            }
        }
        int a = stack2.top();
        stack2.pop();
        return a;
    }
</code></pre>
<h2 id="30-包含-min-函数的栈"><a href="#30-包含-min-函数的栈" class="headerlink" title="30. 包含 min 函数的栈"></a>30. 包含 min 函数的栈</h2><pre><code class="language-cpp">stack&lt;int&gt; m_data, m_min;
void push(int value) {
    m_data.push(value);
    if (m_min.empty()||value&lt;m_min.top()) {
        m_min.push(value);
    }
    else {
        m_min.push(m_min.top());
    }
}
void pop() {
    m_data.pop();
    m_min.pop();
}
int top() {
    return m_data.top();
}
int min() {
    return m_min.top();
}
</code></pre>
<h2 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31. 栈的压入、弹出序列"></a>31. 栈的压入、弹出序列</h2><pre><code class="language-cpp">bool IsPopOrder(vector&lt;int&gt; pushV, vector&lt;int&gt; popV)
{
    if (pushV.empty() || popV.empty() || pushV.size() != popV.size())
    {
        return false;
    }
    stack&lt;int&gt; s;
    int j = 0;
    for (int i = 0; i &lt; pushV.size(); i++)
    {
        s.push(pushV[i]);
        while (s.size() &amp;&amp; s.top() == popV[j])
        {
            s.pop();
            j++;
        }
    }
    return s.empty();
}
</code></pre>
<h2 id="59-队列的最大值"><a href="#59-队列的最大值" class="headerlink" title="59. 队列的最大值"></a>59. 队列的最大值</h2>
  </article>
  <div class="random-toc-area">
  <button class="btn-hide-toc btn-hide-toc-show" style="display: none" onclick="TOCToggle()">显示目录</button>
  <button class="btn-hide-toc btn-hide-toc-hide" onclick="TOCToggle()">隐藏目录</button>
  <div class="random-toc">
    <h2>目录</h2>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#链表"><span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-从尾到头打印链表"><span class="toc-text">6. 从尾到头打印链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用栈"><span class="toc-text">使用栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归"><span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-1-删除链表的节点"><span class="toc-text">18.1 删除链表的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-2-删除链表中重复的节点"><span class="toc-text">18.2 删除链表中重复的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#递归-1"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非递归"><span class="toc-text">非递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-链表中倒数第k个节点"><span class="toc-text">22. 链表中倒数第k个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-链表中环的入口节点"><span class="toc-text">23. 链表中环的入口节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-反转链表"><span class="toc-text">24. 反转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-合并两个排序链表"><span class="toc-text">25. 合并两个排序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#递归-2"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非递归-1"><span class="toc-text">非递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-复杂链表的复制"><span class="toc-text">35. 复杂链表的复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-两个链表的第一个公共节点"><span class="toc-text">52. 两个链表的第一个公共节点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#栈和队列"><span class="toc-text">栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-用两个栈实现队列"><span class="toc-text">9. 用两个栈实现队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-包含-min-函数的栈"><span class="toc-text">30. 包含 min 函数的栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-栈的压入、弹出序列"><span class="toc-text">31. 栈的压入、弹出序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59-队列的最大值"><span class="toc-text">59. 队列的最大值</span></a></li></ol></li></ol>
  </div>
</div>

  
<nav id="pagination">
  
    <a href="/2018/09/11/剑指Offer-二叉树相关/" class="prev">&larr; 上一篇 剑指Offer-二叉树相关</a>
  

  

  
    <a href="/2017/11/27/chrome插件推荐/" class="next">下一篇 chrome插件推荐 &rarr;</a>
  
</nav>

  <!-- JiaThis Button BEGIN -->

<!-- JiaThis Button END -->


      
      
    </div>
  </div>

  <div id="bottom-outer">
    <div id="bottom-inner">
      Site by Cellophane using
      <a href="http://hexo.io">Hexo</a> & <a href="https://github.com/stiekel/hexo-theme-random">Random</a>
      <br>
      
    </div>
  </div>
</div>

</div>


<div id="user-card">
  <div class="center-field">
    <img class="avatar" src="/images/me3.jpg">
    <p id="description"></p>
    <ul class="social-icon">
  
  
    <li>
      <a href="https://github.com/liuyuqi21">
        
          <i class="icon iconfont github">&#xe606;</i>
        
      </a>
    </li>
  
    <li>
      <a href="https://www.zhihu.com/people/ding-wei-33-1/activities">
        
          <i class="icon iconfont zhihu">&#xe60b;</i>
        
      </a>
    </li>
  
    <li>
      <a href="http://chensd.com">
        
          <i class="icon iconfont rss">&#xe60e;</i>
        
      </a>
    </li>
  
</ul>
  </div>
</div>


<div id="btn-view">Hide</div>

<script>
// is trigger analytics / tongji script
var isIgnoreHost = false;

if(window && window.location && window.location.host) {
  isIgnoreHost = ["localhost","127.0.0.1"].some(function(address){
    return 0 === window.location.host.indexOf(address);
  });
}

var isTriggerAnalytics = !( true && isIgnoreHost );

</script>




  
  
    <script src="/js/jquery-2.2.3.min.js"></script>
  
    <script src="/js/vegas.min.js"></script>
  
    <script src="/js/random.js"></script>
  
    <script src="/js/jquery.mousewheel.pack.js"></script>
  
    <script src="/js/jquery.fancybox.pack.js"></script>
  
    <script src="/js/jquery.fancybox-thumbs.js"></script>
  
    <script src="/js/plyr.js"></script>
  
    <script src="/js/prism.js"></script>
  

<script>

  // fancybox
  var backgroundImages = [];
  
  $('#post').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox') || $(this).parent().hasClass('fancybox-thumb')) return;
      var alt = this.alt || this.title;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'post' + i);
    });
  });
  $(".fancybox").fancybox();

var vegasConfig = {"preload­Image":true,"transition":["flash"],"timer":true,"delay":1500000,"shuffle":true,"count":12};
var unsplashConfig = {"gravity":"center"};
// is show background images
var turnoffBackgroundImage = false;




var backgroundColor = "34495E";

$(".fancybox-thumb").fancybox({
  prevEffect: 'none',
  nextEffect: 'none',
  helpers: {
    title: {
      type: 'outside'
    },
    thumbs: {
      width: 50,
      height: 50
    }
  }
});

// show video with plyr
$(".video-container iframe").each(function(i){
  var url = $(this).attr('src');
  var id = url.split('/').pop();
  var plyrContainer = document.createElement('div');
  plyrContainer.className = 'plyr';
  var plyrElement = document.createElement('div');
  plyrElement.dataset.videoId = id;
  switch(true) {
    case url.search('youtube.com') >= 0:
      plyrElement.dataset.type = 'youtube';
      break;
    case url.search('vimeo.com') >= 0:
      plyrElement.dataset.type = 'vimeo';
      break;
    default:
      return;
  };
  plyrContainer.appendChild(plyrElement);
  $(this).parent().html(plyrContainer);
});
plyr.setup('.plyr', {iconUrl: '/css/sprite.svg'});
</script>
</body>
</html>

