






<!doctype html>
<html lang="zh-CN">
<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="author" content="Cellophane">
  
  
  
  
    <meta name="description" content="什么是队头阻塞TCP 队头阻塞TCP 要求数据严格按照序号顺序，如果第一个 TCP 分节丢失了，客户端将一直等待丢失的分节重传成功，这样就延缓了后面数据的接收。
如何解决：不使用 TCP 协议，比如 google 推出的 quic 协议，它是在 UDP 基础上实现的可靠传输。还有一个 SCTP（流控制传输协议），它是和 TCP，UDP 在同一层次的传输协议。SCTP 的多流特性也可以尽可能的...">
  
  <title>计算机网络常见问题 [ Cellophane ]</title>
  
  
    <link rel="shortcut icon" href="/Blinky.ico">
  
  
  <link rel="stylesheet" href="/css/random.css">
<link rel="stylesheet" href="/css/vegas.min.css">
<link rel="stylesheet" href="/css/styles/railscasts.css">
<link rel="stylesheet" href="/css/jquery.fancybox.css">
<link rel="stylesheet" href="/css/iconfont/iconfont.css">
<link rel="stylesheet" href="/css/jquery.fancybox-thumbs.css">
<link rel="stylesheet" href="/css/plyr.css">
<link rel="stylesheet" href="/css/prism.css">
  
</head>

<body>
<div class="side-navigate hide-area">
  
    <div class="item prev">
      <a href="/2020/02/02/操作系统常见问题/">
        <div class="item-icon"></div>
      </a>
      <div class="item-title">
        操作系统笔记
      </div>
    </div>
  
  
    <div class="item next">
      <a href="/2020/01/28/Java-虚拟机/">
        <div class="item-icon"></div>
      </a>
      <div class="item-title">
        Java 虚拟机
      </div>
    </div>
  
</div>
<div id="outer-container" class="hide-area">
<div id="container">
  <div id="menu-outer" class="slide-down">
    <div id="menu-inner">
      <div id="brand">
        
        <a onClick="openUserCard()">
          <img id="avatar" src="/images/me3.jpg"/>
          <div id="homelink">Cellophane</div>
        </a>
      </div>
      <div id="menu-list">
        <ul>
        
        
          
            <li>
          
            <a href="/index.html">首页</a>
            
          </li>
        
          
            <li>
          
            <a href="/archives">文章</a>
            
          </li>
        
          
            <li>
          
            <a href="/tags">标签</a>
            
          </li>
        
          
            <li>
          
            <a href="/categories">分类</a>
            
          </li>
        
        </ul>
      </div>
      <div id="show-menu">
        <button>Menu</button>
      </div>
    </div>
  </div>

  <div id="content-outer">
    <div id="content-inner">
      
      
  

  <article id="post">
    <h1>计算机网络常见问题</h1>
    <p class="page-title-sub">
      <span id = "post-title-date">撰写于 2020-01-29</span>
      
        <span id = "post-title-updated">修改于 2020-03-10</span>
      
      
      <span id = "post-title-categories">分类
      
      
        
        
        <a href="/categories/基础/">基础</a>
      
      </span>
      
      
      <span id = "post-title-tags">
      标签
      
      
        
        
        <a href="/tags/计算机网络/">计算机网络</a>
      
      </span>
      
    </p>
    
    <h2 id="什么是队头阻塞"><a href="#什么是队头阻塞" class="headerlink" title="什么是队头阻塞"></a>什么是队头阻塞</h2><h3 id="TCP-队头阻塞"><a href="#TCP-队头阻塞" class="headerlink" title="TCP 队头阻塞"></a>TCP 队头阻塞</h3><p>TCP 要求数据严格按照序号顺序，如果第一个 TCP 分节丢失了，客户端将一直等待丢失的分节重传成功，这样就延缓了后面数据的接收。</p>
<p>如何解决：不使用 TCP 协议，比如 google 推出的 quic 协议，它是在 UDP 基础上实现的可靠传输。还有一个 SCTP（流控制传输协议），它是和 TCP，UDP 在同一层次的传输协议。SCTP 的多流特性也可以尽可能的避免队头阻塞的情况。</p>
<h3 id="HTTP-1-1-队头阻塞"><a href="#HTTP-1-1-队头阻塞" class="headerlink" title="HTTP 1.1 队头阻塞"></a>HTTP 1.1 队头阻塞</h3><p>HTTP 1.1 允许在持久连接上可选的使用管道化（pipeline）特性。管道化允许客户端在已发送的请求收到服务端的响应之前发送下一个请求，，借此来减少等待时间提高吞吐；如果多个请求能在同一个TCP分节发送的话，还能提高网络利用率。</p>
<p>但是管道化要求服务端按照请求发送的顺序返回响应，因为 HTTP 请求和响应没有序号标识，无法将乱序的响应与请求关联起来。所以一个响应返回延迟了，后续的响应都会被延迟，直到队头的响应送达。</p>
<p>如何解决：使用 HTTP 2.0。HTTP 2.0 采用二进制分帧，将阐述信息分割为更小的消息和帧，对他们采用二进制格式编码。比如 header 帧，Data 帧。这些帧可以打散乱序发送，然后根据每个帧首部的流标识符重新组装，并且可以根据优先级，决定优先处理哪个流的数据。</p>
<h2 id="各层协议的作用，以及-TCP-IP-协议的特点。"><a href="#各层协议的作用，以及-TCP-IP-协议的特点。" class="headerlink" title="各层协议的作用，以及 TCP/IP 协议的特点。"></a>各层协议的作用，以及 TCP/IP 协议的特点。</h2><ul>
<li>应用层：为特定应用程序提供数据传输服务。 HTTP、DNS。</li>
<li>传输层：为进程提供通用数据传输服务。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li>
<li>网络层：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li>
<li>数据链路层：为同一链路的主机提供数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li>
<li>物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li>
<li>TCP/IP：只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。TCP/IP 协议体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</li>
</ul>
<h2 id="以太网的特点，以及帧结构。"><a href="#以太网的特点，以及帧结构。" class="headerlink" title="以太网的特点，以及帧结构。"></a>以太网的特点，以及帧结构。</h2><ul>
<li>以太网是一种星型拓扑结构局域网。</li>
<li>以太网帧格式</li>
<li>类型：标记上层使用的协议；</li>
<li>数据：长度在 46-1500 之间秒如果太小则需要填充；</li>
<li>FCS：帧检验序列，使用的是 CRC 检验方法；</li>
</ul>
<h2 id="集线器、交换机、路由器的作用，以及所属的网络层"><a href="#集线器、交换机、路由器的作用，以及所属的网络层" class="headerlink" title="集线器、交换机、路由器的作用，以及所属的网络层"></a><a href="https://www.tianmaying.com/tutorial/NetWorkInstrument" target="_blank" rel="external">集线器、交换机、路由器的作用，以及所属的网络层</a></h2><ul>
<li>集线器：物理层设备。作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其他所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。</li>
<li>交换机：链路层设备。是一种基于 MAC 识别，能完成封装转发数据包功能的网络设备。它不会发生碰撞，能根据 MAC 地址进行存储转发。</li>
<li>路由器：网络层设备。是一种连接多个网络或网段的网络设备，根据 IP 进行转发。</li>
</ul>
<h2 id="IP-数据数据报常见字段的作用。"><a href="#IP-数据数据报常见字段的作用。" class="headerlink" title="IP 数据数据报常见字段的作用。"></a>IP 数据数据报常见字段的作用。</h2><ul>
<li>版本：有 4（IPv4）和 6（IPv6）两个值；</li>
<li>首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li>
<li>区分服务 : 用来获得更好的服务，一般情况下不使用。</li>
<li>总长度 : 包括首部长度和数据部分长度。</li>
<li>生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li>
<li>协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li>
<li>首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li>
<li>标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li>
<li>片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li>
</ul>
<h2 id="ARP-协议的作用，以及维护-ARP-缓存的过程。"><a href="#ARP-协议的作用，以及维护-ARP-缓存的过程。" class="headerlink" title="ARP 协议的作用，以及维护 ARP 缓存的过程。"></a>ARP 协议的作用，以及维护 ARP 缓存的过程。</h2><ul>
<li>ARP 实现由 IP 地址得到 MAC 地址</li>
<li>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到MAC 地址的映射。</li>
</ul>
<h2 id="ICMP-报文种类以及作用；和-IP-数据报的关系；Ping-和-Traceroute-的具体原理。"><a href="#ICMP-报文种类以及作用；和-IP-数据报的关系；Ping-和-Traceroute-的具体原理。" class="headerlink" title="ICMP 报文种类以及作用；和 IP 数据报的关系；Ping 和 Traceroute 的具体原理。"></a>ICMP 报文种类以及作用；和 IP 数据报的关系；Ping 和 Traceroute 的具体原理。</h2><ul>
<li>ICMP 报文分为差错报告报文和询问报文</li>
<li>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但不属于高层协议</li>
<li>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功相应次数估算出数据包往返时间以及丢包率</li>
<li>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</li>
<li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li>
<li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li>
<li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li>
<li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li>
</ul>
<h2 id="UDP-与-TCP-比较，分析上层协议应该使用-UDP-还是-TCP。"><a href="#UDP-与-TCP-比较，分析上层协议应该使用-UDP-还是-TCP。" class="headerlink" title="UDP 与 TCP 比较，分析上层协议应该使用 UDP 还是 TCP。"></a>UDP 与 TCP 比较，分析上层协议应该使用 UDP 还是 TCP。</h2><ul>
<li>传输控制协议 TCP：是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。TCP 主要提供完整性服务。</li>
<li>用户数据报协议 UDP：是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。。主要提供及时性服务。</li>
</ul>
<h2 id="理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME-WAIT-的作用。"><a href="#理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME-WAIT-的作用。" class="headerlink" title="理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME_WAIT 的作用。"></a>理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME_WAIT 的作用。</h2><p><img src="/images/sanciwoshou.jpg" alt=""></p>
<ul>
<li><p>三次握手过程：</p>
<ol>
<li>服务器处于 LISTEN 状态，等待来自客户端的连接请求</li>
<li>客户端向服务器发送连接请求报文 SYN 段，并指明客户端的初始序列号 ISN(c)</li>
<li>服务器收到客服端发来的 SYN，如果同意建立连接，则向客户端发送确认报文 SYN = ISN(s)，并将 ISN(c)+1 作为ACK 数  值，这样每发送一个 SYN，序列号加1，如果有丢失的情况，就会重传。</li>
<li>客户端收到 SYN ACK 后，还要向服务器发出确认报文 ACK，ACK 的值为 ISN(s)+1。</li>
<li>服务器收到 ACK 后，连接建立</li>
</ol>
</li>
<li><p>连接建立以后，ACK 都置为 1</p>
</li>
<li><p>第三次握手可以携带数据，如果不携带数据则不消耗序号</p>
</li>
<li><p>三次握手的原因：<br>第三次握手是为了确认客户端的接收能力。</p>
</li>
</ul>
<p>如果是两次，客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认，客户端超时重发连接请求，这样服务器会对同一个客户端保持多个连接，造成资源浪费。</p>
<p>握手只需要确认双方通信时的初始化序号（ISN 是随机的，防止攻击者猜出确认号和防止同一个连接的不同实例），保证通信不会乱序。<br><img src="/images/sicihuishou.jpg" alt=""></p>
<ul>
<li><p>四次挥手：</p>
<ul>
<li>客户端发送释放报文 FIN</li>
<li>服务器收到 FIN 后发出确认 ACK，此时 TCP 属于半关闭状态（CLOSED_WAIT），服务器能向客户端发送数据但是客户端不能向服务器发送数据</li>
<li>当服务器不再需要连接时，发送连接释放报文 FIN</li>
<li>客户端收到 FIN 后发出确认 ACK，进入 TIME-WAIT 状态，等待 2 倍的 MSL（最大报文存活时间）后释放连接</li>
<li>服务器收到 ACK 后释放连接</li>
</ul>
</li>
<li><p>四次挥手的原因：客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器发送还为传送完毕的数据，传送完毕后，服务器会发送 FIN 连接释放报文。</p>
</li>
<li><p>TIME_WAIT：客户端收到服务端的 FIN 报文址后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ol>
<li>确保最后一个报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li>
<li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，是的下一个连接不会出现九的连接请求报文。</li>
</ol>
</li>
</ul>
<h2 id="说说半连接队列和-SYN-Flood-攻击的关系"><a href="#说说半连接队列和-SYN-Flood-攻击的关系" class="headerlink" title="说说半连接队列和 SYN Flood 攻击的关系"></a>说说半连接队列和 SYN Flood 攻击的关系</h2><p>三次握手前，服务端的状态从 CLOSED  变为LISTEN，同时在内部创建了两个队列：半连接队列和全连接队列，即SYN队列和ACCEPT队列。</p>
<ul>
<li>半连接队列：当客户端发送SYN到服务端，服务端收到以后回复ACK和SYN，状态由LISTEN变为SYN_RCVD，此时这个连接就被推入了SYN队列，也就是半连接队列。</li>
<li>全连接队列：当客户端返回ACK, 服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个 TCP 维护的队列，也就是全连接队列(Accept Queue)。</li>
<li>SYN Flood 攻击原理：SYN Flood 属于典型的 DoS/DDoS 攻击。其攻击的原理很简单，就是用客户端在短时间内伪造大量不存在的 IP 地址，并向服务端疯狂发送SYN。对于服务端而言，会产生两个危险的后果:<ol>
<li>处理大量的SYN包并返回对应ACK, 势必有大量连接处于SYN_RCVD状态，从而占满整个半连接队列，无法处理正常的请求。</li>
<li>由于是不存在的 IP，服务端长时间收不到客户端的ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。</li>
</ol>
</li>
<li>如何应对：<ol>
<li>增加 SYN 连接，也就是增加半连接队列的容量。</li>
<li>减少 SYN + ACK 重试次数，避免大量的超时重发。</li>
<li>利用 SYN Cookie 技术，在服务端接收到SYN后不立即分配连接资源，而是根据这个SYN计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复ACK的时候带上这个Cookie值，服务端验证 Cookie 合法之后才分配连接资源。</li>
</ol>
</li>
</ul>
<h2 id="可靠传输原理，并设计可靠-UDP-协议。"><a href="#可靠传输原理，并设计可靠-UDP-协议。" class="headerlink" title="可靠传输原理，并设计可靠 UDP 协议。"></a>可靠传输原理，并设计可靠 UDP 协议。</h2><ul>
<li>建立连接（标志位）：通信前确认通信实体存在</li>
<li>序号机制（序号、确认号）：确保了数据是按序、完整到达</li>
<li>数据校验（校验和）：CRC 校验全部数据，校验包出错，丢弃报文段，不给出响应，超时重发</li>
<li>超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。<ul>
<li>RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。</li>
<li>RTO：重传间隔，通常每次重传 RTO 是前一次重传间隔的两倍，重传次数达到上限后停止重传。RTO = RTTs + 4*RTTd</li>
</ul>
</li>
<li>流量控制（流量窗口）</li>
<li>拥塞控制（拥塞窗口）</li>
</ul>
<h2 id="流量控制的作用，原理。"><a href="#流量控制的作用，原理。" class="headerlink" title="流量控制的作用，原理。"></a>流量控制的作用，原理。</h2><p>目的是避免发送过量，接收方通过 TCP 头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。</p>
<ul>
<li>发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段来告诉发送方自己的窗口大小，发送方根据这个值来设置自己窗口大小。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态，接收窗口类似。</li>
<li>TCP 是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中发送窗 = 已发送未确认部分 + 未发但可发送部分。接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 = 未接收但准备接收部分。</li>
<li>发送窗内的数据只有当收到接收端某段发送数据的 ACK 响应时才移动发送窗。接收窗口只会对窗口最后一个<strong>按序</strong>到达的字节进行确认。</li>
</ul>
<h2 id="TCP-拥塞控制的作用，理解具体原理。"><a href="#TCP-拥塞控制的作用，理解具体原理。" class="headerlink" title="TCP 拥塞控制的作用，理解具体原理。"></a>TCP 拥塞控制的作用，理解具体原理。</h2><p>作用：为了降低整个网络的拥塞程度。</p>
<p>拥塞控制使用拥塞窗口。TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p>
<ul>
<li>慢开始：发送的最初执行慢开始，令拥塞窗口 cwnd（congestion window） = 1，发送方只能发送一个报文段，当收到确认后，将 cwnd 加倍。</li>
<li>拥塞避免：设置一个慢开始门限 ssthresh ，当cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</li>
<li>快重传：在发送方，如果收到 3 个重复确认，那么知道下一个报文段丢失，此时执行快重传，立刻重传下一个报文段。</li>
<li>快恢复：快重传之后执行快恢复，令 ssthresh = cwnd / 2，cwnd = ssthresh，此时直接进入拥塞避免。</li>
</ul>
<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>
<ul>
<li>流量控制和拥塞控制：<ul>
<li>流量控制属于通信双方协商，拥塞控制涉及通信链路全局</li>
<li>实际最终发送窗口 = min{awnd（流量控制发送窗口）,cwnd（拥塞窗口）}</li>
</ul>
</li>
</ul>
<h2 id="DNS-的端口号；TCP-还是-UDP；作为缓存、负载均衡。"><a href="#DNS-的端口号；TCP-还是-UDP；作为缓存、负载均衡。" class="headerlink" title="DNS 的端口号；TCP 还是 UDP；作为缓存、负载均衡。"></a>DNS 的端口号；TCP 还是 UDP；作为缓存、负载均衡。</h2><p>DNS可以使用 UDP 和 TCP 进行传输，使用的端口号都为53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超市和重传来保证可靠性。在两种情况下会使用 TCP 进行传输：</p>
<ol>
<li>如果返回的响应超过 512 字节（UDP 最大只支持 512 字节的数据）。</li>
<li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li>
</ol>
<h2 id="GET-与-POST-比较：作用、参数、安全性、幂等性、可缓存。"><a href="#GET-与-POST-比较：作用、参数、安全性、幂等性、可缓存。" class="headerlink" title="GET 与 POST 比较：作用、参数、安全性、幂等性、可缓存。"></a>GET 与 POST 比较：作用、参数、安全性、幂等性、可缓存。</h2><ul>
<li>作用：GET 用于获取资源，而 POST 用于传输实体主体。</li>
<li>参数：GET 和 POST 的请求都能使用额外的参数，但是 GET 的 参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为<code>%20</code>。POST 参考支持标准字符集。</li>
<li>安全性：安全的 HTTP 方法不会改变服务器状态，也就是说他只是可读的。GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。安全的方法除了 GET 之外还有：HEAD、OPTIONS。不安全的方法除了 POST 之外还有 PUT、DELETE。</li>
<li>幂等性：幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。所有的安全方法也都是幂等的。在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</li>
<li>可缓存：如果要对响应进行缓存，需要满足以下条件：<ul>
<li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li>
<li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li>
<li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li>
</ul>
</li>
</ul>
<h2 id="HTTP-状态码。"><a href="#HTTP-状态码。" class="headerlink" title="HTTP 状态码。"></a>HTTP 状态码。</h2><table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接受的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Successful（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器请求处理出错</td>
</tr>
</tbody>
</table>
<ul>
<li>100 Continue：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li>
<li>200 Ok</li>
<li>204 No Content：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>
<li>206 Partial Content：表示客户端进行了范围请求，响应报文包含由 Conent-Range 指定范围的实体内容。</li>
<li>301 Moved Permanently：永久重定向</li>
<li>302 Found：临时性重定向</li>
<li>303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li>
<li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li>
<li>304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>
<li>307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>
<li>400 Bad Request：请求报文中存在语法错误</li>
<li>401 Unauthorized：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>
<li>403 Fobidden：请求被拒绝</li>
<li>404 Not Found</li>
<li>500 Internal Server Error ：服务器正在执行请求时发生错误。</li>
<li>503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>
</ul>
<h2 id="Cookie-作用、安全性问题、和-Session-的比较。"><a href="#Cookie-作用、安全性问题、和-Session-的比较。" class="headerlink" title="Cookie 作用、安全性问题、和 Session 的比较。"></a>Cookie 作用、安全性问题、和 Session 的比较。</h2><ul>
<li>用途：</li>
</ul>
<ol>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ol>
<ul>
<li>标记为 HttpOnly 的 Cookie 不能被 Javascript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>document.cookie</code> API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</li>
<li>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</li>
<li>Cookie 与 Session 选择</li>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session；</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li>
<li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li>
</ul>
<h2 id="缓存的-Cache-Control-字段，特别是-Expires-和-max-age-的区别。ETag-验证原理。"><a href="#缓存的-Cache-Control-字段，特别是-Expires-和-max-age-的区别。ETag-验证原理。" class="headerlink" title="缓存的 Cache-Control 字段，特别是 Expires 和 max-age 的区别。ETag 验证原理。"></a>缓存的 Cache-Control 字段，特别是 Expires 和 max-age 的区别。ETag 验证原理。</h2><ul>
<li>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</li>
<li>no-store 指令规定不能对请求或响应的任何一部分进行缓存 <code>Cache-Control：no-store</code></li>
<li>no-cache 指令规定缓存服务器需要先向源服务器验证缓存的有效性，只有当缓存服务器有效才将能使用该缓存对客户端的请求进行相应</li>
<li>private 指令规定了将资源作为私有缓存，只能被单独用户所使用，一般存储在用户浏览器中。public 指令规定了将资源作为公共缓存，可以被多个用户所使用，一般存储在代理服务器中。</li>
<li>max-age 指令出现在请求报文中，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。max-age 指令出现在响应报文中，表示缓存资源在缓存服务器中保存的时间。Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。在 HTTP/1.1 中，会优先处理 max-age 指令；在 HTTP/1.0 中，max-age 指令会被忽略掉。</li>
<li>ETag：它是资源的唯一标识。URL 不能唯一表示资源，例如 <code>http://www.google.com/</code> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。<code>ETag: &quot;82e22293907ce725faf67773957acd12&quot;</code>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。 <code>If-None-Match: &quot;82e22293907ce725faf67773957acd12&quot;</code></li>
</ul>
<h2 id="长连接与短连接原理以及使用场景，流水线。"><a href="#长连接与短连接原理以及使用场景，流水线。" class="headerlink" title="长连接与短连接原理以及使用场景，流水线。"></a>长连接与短连接原理以及使用场景，流水线。</h2><ul>
<li>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</li>
<li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li>
<li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li>
</ul>
<h2 id="HTTP-存在的安全性问题，以及-HTTPs-的加密、认证和完整性保护作用。"><a href="#HTTP-存在的安全性问题，以及-HTTPs-的加密、认证和完整性保护作用。" class="headerlink" title="HTTP 存在的安全性问题，以及 HTTPs 的加密、认证和完整性保护作用。"></a>HTTP 存在的安全性问题，以及 HTTPs 的加密、认证和完整性保护作用。</h2><ul>
<li>安全性问题：</li>
<li>使用明文进行通信，内容可能会被窃听</li>
<li>不验证通信方身份，通信方的身份可能遭遇伪装</li>
<li>无法验证报文的完整性，报文有可能遭篡改</li>
<li>HTTPs：让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPs 使用了隧道进行通信。通过使用 SSL，HTTPs 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</li>
</ul>
<h2 id="HTTP-1-x-的缺陷，以及-HTTP-2-的特点。"><a href="#HTTP-1-x-的缺陷，以及-HTTP-2-的特点。" class="headerlink" title="HTTP/1.x 的缺陷，以及 HTTP/2 的特点。"></a>HTTP/1.x 的缺陷，以及 HTTP/2 的特点。</h2><ul>
<li>HTTP/1.X 缺陷：<ul>
<li>客户端需要使用多个连接才能实现并发和缩短延迟</li>
<li>不会压缩请求和响应首部，从而导致不必要的网络流量</li>
<li>不支持有效的资源优先级，导致底层 TCP 连接的利用率低下</li>
<li>客户端需要主动请求</li>
<li>队头阻塞</li>
</ul>
</li>
<li>HTTP/2：<ul>
<li>二进制分帧层：HTTP 2 是二进制协议，他下用二进制格式传输数据而不是 1.x 的文本格式。它将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。在通信过程中，只会有一个 TCP 连接存在，它承载力任意数量的数据流。</li>
<li>服务器推送：HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</li>
<li>首部压缩：HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</li>
<li>多路复用：HTTP2 让所有的通信都在一个 TCP 连接上完成，实现了请求并发，后面的请求不用再等待，解决了队头阻塞。</li>
</ul>
</li>
</ul>
<h2 id="HTTP-1-1-的特性。"><a href="#HTTP-1-1-的特性。" class="headerlink" title="HTTP/1.1 的特性。"></a>HTTP/1.1 的特性。</h2><ul>
<li>默认是长连接</li>
<li>支持流水线</li>
<li>支持同时打开多个 TCP 连接</li>
<li>支持虚拟主机</li>
<li>新增状态码 100</li>
<li>支持分块传输编码</li>
<li>新增缓存处理指令 max-age</li>
</ul>
<h2 id="HTTP-与-FTP-的比较。"><a href="#HTTP-与-FTP-的比较。" class="headerlink" title="HTTP 与 FTP 的比较。"></a>HTTP 与 FTP 的比较。</h2><ul>
<li>FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件</li>
<li>控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答</li>
<li>数据连接：用来传送一个文件数据</li>
</ul>
<h2 id="Socket-网络-I-O模型"><a href="#Socket-网络-I-O模型" class="headerlink" title="Socket 网络 I/O模型"></a>Socket 网络 I/O模型</h2><p>★★☆ 五种 IO 模型的特点以及比较。</p>
<ul>
<li>阻塞式 I/O：应用进程被阻塞，直到数据复制到应用进程缓冲池中才被返回。</li>
<li>非阻塞式 I/O：应用进程执行系统调用后，内核返回一个错误码。应用进程可以继续执行，但是需要不断地执行系统调用来获知 I/O是否完成，这种方式成为轮询（polling）。</li>
<li>I/O 复用：使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvform 把数据从内核复制到进程中。它可以让单个进程具有处理多个 I/O事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。</li>
<li>信号驱动 I/O：应用进程使用 sigaction 系统调用，内核立即返回，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用程序中。</li>
<li>异步 I/O：应用进程执行 aio_read 系统调用会立即返回，应用程序可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</li>
</ul>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较:"></a>比较:</h4><ol>
<li>同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞。</li>
<li>异步 I/O：不会阻塞。</li>
<li>阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，它们的主要区别在第一个阶段。</li>
<li>非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。</li>
</ol>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://juejin.im/post/5ce37660f265da1bb13f05f0" target="_blank" rel="external">什么是队头阻塞以及如何解决</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="external">HTTP 协议入门</a></li>
<li><a href="https://www.cnblogs.com/qcrao-2018/p/10182185.html" target="_blank" rel="external">“三次握手，四次挥手”你真的懂吗？</a></li>
<li><a href="https://juejin.im/post/5e527c58e51d4526c654bf41" target="_blank" rel="external">TCP协议灵魂之问，巩固你的网路底层基础</a></li>
<li><a href="https://juejin.im/post/5d9c284b518825095879e7a5" target="_blank" rel="external">面试官，不要再问我三次握手和四次挥手</a></li>
</ul>

  </article>
  <div class="random-toc-area">
  <button class="btn-hide-toc btn-hide-toc-show" style="display: none" onclick="TOCToggle()">显示目录</button>
  <button class="btn-hide-toc btn-hide-toc-hide" onclick="TOCToggle()">隐藏目录</button>
  <div class="random-toc">
    <h2>目录</h2>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是队头阻塞"><span class="toc-text">什么是队头阻塞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-队头阻塞"><span class="toc-text">TCP 队头阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-1-队头阻塞"><span class="toc-text">HTTP 1.1 队头阻塞</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#各层协议的作用，以及-TCP-IP-协议的特点。"><span class="toc-text">各层协议的作用，以及 TCP/IP 协议的特点。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#以太网的特点，以及帧结构。"><span class="toc-text">以太网的特点，以及帧结构。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集线器、交换机、路由器的作用，以及所属的网络层"><span class="toc-text">集线器、交换机、路由器的作用，以及所属的网络层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP-数据数据报常见字段的作用。"><span class="toc-text">IP 数据数据报常见字段的作用。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARP-协议的作用，以及维护-ARP-缓存的过程。"><span class="toc-text">ARP 协议的作用，以及维护 ARP 缓存的过程。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ICMP-报文种类以及作用；和-IP-数据报的关系；Ping-和-Traceroute-的具体原理。"><span class="toc-text">ICMP 报文种类以及作用；和 IP 数据报的关系；Ping 和 Traceroute 的具体原理。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP-与-TCP-比较，分析上层协议应该使用-UDP-还是-TCP。"><span class="toc-text">UDP 与 TCP 比较，分析上层协议应该使用 UDP 还是 TCP。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME-WAIT-的作用。"><span class="toc-text">理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME_WAIT 的作用。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#说说半连接队列和-SYN-Flood-攻击的关系"><span class="toc-text">说说半连接队列和 SYN Flood 攻击的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可靠传输原理，并设计可靠-UDP-协议。"><span class="toc-text">可靠传输原理，并设计可靠 UDP 协议。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流量控制的作用，原理。"><span class="toc-text">流量控制的作用，原理。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-拥塞控制的作用，理解具体原理。"><span class="toc-text">TCP 拥塞控制的作用，理解具体原理。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS-的端口号；TCP-还是-UDP；作为缓存、负载均衡。"><span class="toc-text">DNS 的端口号；TCP 还是 UDP；作为缓存、负载均衡。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GET-与-POST-比较：作用、参数、安全性、幂等性、可缓存。"><span class="toc-text">GET 与 POST 比较：作用、参数、安全性、幂等性、可缓存。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-状态码。"><span class="toc-text">HTTP 状态码。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie-作用、安全性问题、和-Session-的比较。"><span class="toc-text">Cookie 作用、安全性问题、和 Session 的比较。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缓存的-Cache-Control-字段，特别是-Expires-和-max-age-的区别。ETag-验证原理。"><span class="toc-text">缓存的 Cache-Control 字段，特别是 Expires 和 max-age 的区别。ETag 验证原理。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#长连接与短连接原理以及使用场景，流水线。"><span class="toc-text">长连接与短连接原理以及使用场景，流水线。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-存在的安全性问题，以及-HTTPs-的加密、认证和完整性保护作用。"><span class="toc-text">HTTP 存在的安全性问题，以及 HTTPs 的加密、认证和完整性保护作用。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-1-x-的缺陷，以及-HTTP-2-的特点。"><span class="toc-text">HTTP/1.x 的缺陷，以及 HTTP/2 的特点。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-1-1-的特性。"><span class="toc-text">HTTP/1.1 的特性。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-与-FTP-的比较。"><span class="toc-text">HTTP 与 FTP 的比较。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket-网络-I-O模型"><span class="toc-text">Socket 网络 I/O模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#比较"><span class="toc-text">比较:</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考文章"><span class="toc-text">参考文章</span></a>
  </div>
</div>

  
<nav id="pagination">
  
    <a href="/2020/02/02/操作系统常见问题/" class="prev">&larr; 上一篇 操作系统笔记</a>
  

  

  
    <a href="/2020/01/28/Java-虚拟机/" class="next">下一篇 Java 虚拟机 &rarr;</a>
  
</nav>

  <!-- JiaThis Button BEGIN -->

<!-- JiaThis Button END -->


      
      
    </div>
  </div>

  <div id="bottom-outer">
    <div id="bottom-inner">
      Site by Cellophane using
      <a href="http://hexo.io">Hexo</a> & <a href="https://github.com/stiekel/hexo-theme-random">Random</a>
      <br>
      
    </div>
  </div>
</div>

</div>


<div id="user-card">
  <div class="center-field">
    <img class="avatar" src="/images/me3.jpg">
    <p id="description"></p>
    <ul class="social-icon">
  
  
    <li>
      <a href="https://github.com/liuyuqi21">
        
          <i class="icon iconfont github">&#xe606;</i>
        
      </a>
    </li>
  
    <li>
      <a href="https://www.zhihu.com/people/ding-wei-33-1/activities">
        
          <i class="icon iconfont zhihu">&#xe60b;</i>
        
      </a>
    </li>
  
    <li>
      <a href="http://chensd.com">
        
          <i class="icon iconfont rss">&#xe60e;</i>
        
      </a>
    </li>
  
</ul>
  </div>
</div>


<div id="btn-view">Hide</div>

<script>
// is trigger analytics / tongji script
var isIgnoreHost = false;

if(window && window.location && window.location.host) {
  isIgnoreHost = ["localhost","127.0.0.1"].some(function(address){
    return 0 === window.location.host.indexOf(address);
  });
}

var isTriggerAnalytics = !( true && isIgnoreHost );

</script>




  
  
    <script src="/js/jquery-2.2.3.min.js"></script>
  
    <script src="/js/vegas.min.js"></script>
  
    <script src="/js/random.js"></script>
  
    <script src="/js/highlight.pack.js"></script>
  
    <script src="/js/jquery.mousewheel.pack.js"></script>
  
    <script src="/js/jquery.fancybox.pack.js"></script>
  
    <script src="/js/jquery.fancybox-thumbs.js"></script>
  
    <script src="/js/plyr.js"></script>
  
    <script src="/js/prism.js"></script>
  

<script>

  // fancybox
  var backgroundImages = [];
  
  $('#post').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox') || $(this).parent().hasClass('fancybox-thumb')) return;
      var alt = this.alt || this.title;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'post' + i);
    });
  });
  $(".fancybox").fancybox();

var vegasConfig = {"preload­Image":true,"transition":["flash"],"timer":true,"delay":1500000,"shuffle":true,"count":12};
var unsplashConfig = {"gravity":"center"};
// is show background images
var turnoffBackgroundImage = false;




var backgroundColor = "34495E";

$(".fancybox-thumb").fancybox({
  prevEffect: 'none',
  nextEffect: 'none',
  helpers: {
    title: {
      type: 'outside'
    },
    thumbs: {
      width: 50,
      height: 50
    }
  }
});

// show video with plyr
$(".video-container iframe").each(function(i){
  var url = $(this).attr('src');
  var id = url.split('/').pop();
  var plyrContainer = document.createElement('div');
  plyrContainer.className = 'plyr';
  var plyrElement = document.createElement('div');
  plyrElement.dataset.videoId = id;
  switch(true) {
    case url.search('youtube.com') >= 0:
      plyrElement.dataset.type = 'youtube';
      break;
    case url.search('vimeo.com') >= 0:
      plyrElement.dataset.type = 'vimeo';
      break;
    default:
      return;
  };
  plyrContainer.appendChild(plyrElement);
  $(this).parent().html(plyrContainer);
});
plyr.setup('.plyr', {iconUrl: '/css/sprite.svg'});
</script>
</body>
</html>

